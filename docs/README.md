# PhotoSorter
Сортировщик фотографий на Яндекс Диске

## Цель проекта

**PhotoSorter** — автоматизировать разбор и наведение порядка в фото/видео на Яндекс.Диске: находить дубликаты по содержимому, определять категорию (люди/дети/семья/животные/без людей) и раскладывать по заранее заданным папкам в `disk:/Фото`, с управлением правилами через Web UI.

## Термины

- **Архив**: в рамках проекта под “архивом” понимается папка **`disk:/Фото`** на Яндекс.Диске.

## Целевые папки и правила сортировки

Список папок и порядок их применения **не захардкожены**: всё задаётся в таблице **`folders`** (колонки `path`, `sort_order`, `content_rule`). Редактирование — на странице **`/folders`**. Имена папок (Агата, Путешествия, Технологии и т.д.) и пути вида `disk:/Фото/...` хранятся в БД; логика выбора папки для файла — в `backend/common/sort_rules.py` (см. раздел «Правила сортировки» ниже).

## inventory_scope (файлы в прогоне и архиве)

В таблице `files` поле **`inventory_scope`** определяет, к какой «зоне» относится файл:

| Значение      | Смысл |
|---------------|--------|
| **source**    | Файл в прогоне, сортируемый: ещё не перенесён в архив. Отчёт шага 4 (sorting-folders) считает только **source** — без local_done, чтобы «Всего в отчёте шага 4» совпадало с «Всего в прогоне» (tab-counts). |
| **local_done**| Файл перенесён локально в папку, которая **остаётся только на диске** (Технологии, Чеки и т.д.) и **не едет в фотоархив**. Выставляется при «Переместить файлы локально» для папок, не входящих в «архивные». В отчёте шага 4 **не участвует** (см. source). |
| **archive**   | Файл в фотоархиве. Определяется по **inventory_scope = 'archive'**, а не по началу пути (`disk:`). Попадает туда после «Перенести в архив». |

**Важно:** для папки **Путешествия** (и подпапок поездок) **никогда** не выставляется `local_done` — они предназначены для фотоархива; при «Переместить локально» путь в БД обновляется, но `inventory_scope` остаётся `source`, чтобы файлы продолжали отображаться в sorting-folders и затем могли быть перенесены в архив.

Схема сущностей: `docs/diagrams/entities_as_is.puml` (класс `files`, примечание к `inventory_scope`).

## Логика главной страницы (пайплайн сортировки)

**Четыре шага** выполняются строго последовательно, без пропусков:

1. **Предочистка** — отделение не-медиа файлов и невалидных медиа.
2. **Дедупликация** — внутри сортируемой папки и с фотоархивом.
3. **Определение лиц** — скан и разложение по категориям (лица / нет лиц).
4. **Сортировка по финальным папкам** — заполнить целевые папки в БД → проверить отчёт → переместить файлы.

**Основной сценарий:** запускаем шаг → смотрим результаты этого шага через Web-интерфейс → при необходимости корректируем → (опционально) нажимаем «переместить файлы» → запускаем следующий шаг.

**На шаге 4** две кнопки перемещения:
- **Переместить локально** — файлы перемещаются в целевые подпапки под корнем прогона; путь в БД обновляется одновременно; пустые папки источника удаляются.
- **Переместить в фотоархив** — файлы загружаются в `disk:/Фото/...`, локальная копия переносится в `_sorted`; в БД выставляется `inventory_scope='archive'`; пустые папки источника удаляются. Перед загрузкой на ЯД создаются родительские папки (если их нет). **Resume**: при прерывании (например перезапуск uvicorn) достаточно снова нажать «Перенести в архив» — переносятся только ещё не перенесённые файлы (path ещё `local:...`). Если файл уже есть на ЯД (409 PathExistsError / DiskResourceAlreadyExistsError) — загрузку не повторяем, обновляем БД (path → archive, inventory_scope) и считаем перенесённым.

**Шаг 4: важные замечания (чтобы не повторять грабли)**

- **Сортируемые файлы в отчёте step4** — для **by_folder** и **unsorted** берутся только файлы с `inventory_scope = 'source'` и `last_run_id = dedup_run_id` (без local_done), чтобы «Всего в отчёте шага 4» совпадало с «Всего в прогоне» (tab-counts). Fill и счётчики вкладок — по тому же критерию. Не по «path под корнем»: на Windows формат путей даёт несовпадение.
- **Шаг 4 без HTTP к себе** — шаги 1–3 выполняются в **отдельном процессе** (subprocess), поэтому прогресс пишется в БД и опрос status не блокируется. Шаг 4 изначально запускался в **потоке того же процесса** и делал HTTP-запросы (clear, fill, sort) к тому же серверу → при одном воркере возникал дедлок, fill не выполнялся, прогресс оставался 0%. Решение: clear, fill и sort вызываются **напрямую** (`clear_target_folders_for_run_impl`, `fill_target_folders_impl`, `sort_into_folders_impl`) из потока шага 4, без HTTP.
- **Ошибки «database is locked»** — не глушить: при `sqlite3.OperationalError` с "locked" в fill пробрасывать исключение; при записи `status="failed"` в run логировать в лог прогона и исходную ошибку, не делать `pass`.
- **resolve_target_folder_for_faces** — при ошибке не подставлять папку «Другие люди»; пропускать файл и писать ошибку (с traceback) в ответ API, чтобы причину можно было исправить.
- **Целевые папки** — в БД записывается полный путь (как в отладочном скрипте `check_sort_target_folders.py`); для папок из таблицы `folders` с `path` на `disk:` используется этот path.

**Шаги 5 и 6 (Переместить локально / Перенести в архив):**
- Прогресс хранится в `pipeline_runs`: `step4_phase` (local | archive), `step4_processed`, `step4_total`, `step5_done`, `step6_done`. Колонки добавляются миграцией: `python backend/scripts/migration/add_pipeline_runs_step4_step6_columns.py`.
- При старте сервера «зависший» статус (step4_phase = local | archive) сбрасывается, чтобы после перезапуска uvicorn можно было снова нажать кнопку (resume). Если был прогресс, но шаг не завершён, UI показывает **«Прервано (можно продолжить)»** вместо «idle».
- При длительном переносе в архив лучше запускать uvicorn **без** `--reload`, иначе сохранение файлов в проекте перезапускает сервер и обрывает перенос.

**Требования к UI:**
- Кнопки начала/продолжения запуска — напротив соответствующего шага.
- Каждый шаг адекватно показывает прогресс.
- Каждый шаг поддерживает **resume** (продолжить с того места, где прервалось в прошлый раз).

**Результаты шагов** отображаются в отдельных интерфейсах:
- Шаг 1 — **preclean-results**
- Шаг 2 — **dedup-results**
- Шаг 3 — **faces**
- Шаг 4 — **sorting-folders**

## Распознавание лиц

**Цель**

Сделать распознавание лиц (фото + видео) как основу для автоматизации сортировки “source → archive” и удобной ручной разметки. По UX близко к Tonfotos, но:
- с большим упором на **автоматизацию** (массовые действия, предложения, якорение),
- с поддержкой **видео**,
- с возможностью **быстро уточнять** результаты вручную.

**Термины**

- **Персона**: человек в справочнике (например “Агата”, “Санек”, “Михаил Заборов”).
- **Группа персон**: логическая группа (например “Семья”, “Дети”, “Синяя диагональ”). Персона может входить в несколько групп.
- **Лицо (face)**: найденная область на фото (bbox/прямоугольник).
- **Трек лица (face track)**: лицо на видео как последовательность bbox во времени + ключевой кадр для разметки.
- **presence_score / доля присутствия**: насколько “сильно” персона представлена в файле:
  - для **фото** — доля площади лица среди всех лиц в кадре: `area(face_bbox) / sum(area(all_face_bbox))` (если лицо одно — 100%),
  - для **видео** — доля времени/кадров, когда виден трек лица.

**Данные в БД (концептуально)**

Для каждого медиа-файла (фото/видео) хранится список найденных лиц/треков и атрибуты:
- **bbox / расположение** лица на фото (прямоугольник; для видео — на ключевом кадре и/или по треку),
- **presence_score** (см. выше),
- **AI предположение**: список кандидатов `[{персона, вероятность/score}]`,
- **ручное подтверждение**: кто это (персона), установленное пользователем,
- **ignore-флаги**:
  - игнорировать конкретное лицо/трек (ошибка детектора / не нужно),
  - режим персоны по приоритету разметки (см. ниже).

**Архитектура привязки лиц к персонам:**

- **Кластеры**: кластеры лиц привязаны к персонам напрямую через `face_clusters.person_id`. Все лица в кластере наследуют персону через JOIN: `face_rectangles → face_cluster_members → face_clusters.person_id`
- **Ручные привязки**: отдельные лица (не через кластеры) привязываются к персонам через таблицу `face_person_manual_assignments` (бывший `face_labels`)
- **Приоритет**: при определении персоны для лица сначала проверяются ручные привязки (`face_person_manual_assignments`), затем привязка через кластер (`face_clusters.person_id`)

**Справочник персон**

Нужен редактируемый справочник людей, распознаваемых системой:
- аватар персоны (типично — лицо-кроп),
- принадлежность к группам (группы редактируемы, персона может быть в нескольких),
- отметка “это я” (Михаил Заборов),
- степень родства/близости по отношению ко мне (как атрибут персоны),
- агрегированные счётчики по статусам (минимум):
  - сколько лиц/файлов **подтверждено вручную**,
  - сколько **определено AI** (без ручного подтверждения),
  - сколько **требует решения** (inbox/unassigned),
  - сколько **игнорировано**.

**Особенности архива (реальность данных)**

Архивные папки не идеальны: внутри могут быть файлы без лиц или с нераспознаваемыми лицами, но смыслово относящиеся к персоне/папке:
- человек снят со спины/в профиль (узнаваем по контексту),
- фото документов/грамот/подарков/вещей, связанных с человеком.

Требование: такие файлы должны поддерживать **якорение (anchoring)**:
- закрепить файл за папкой (и/или персоной), чтобы автосортировка его не переносила.

**Паттерн интерфейса для разметки**

**Основной принцип**: действия разметки выполняются **без подтверждений**, но с возможностью **отмены (undo)**.

- **Без confirm()**: кнопки разметки (назначить персону, пометить как "не лицо", перенести в другой кластер и т.п.) выполняются сразу при клике, без диалога подтверждения.
- **Undo система**: после каждого действия разметки показывается toast-уведомление с кнопкой "Отменить" на 5 секунд. Пользователь может отменить последнее действие.
- **История действий**: система сохраняет последнее действие в стеке undo. При отмене действие полностью откатывается (возвращается исходное состояние).
- **Применение**: этот паттерн применяется ко всем интерфейсам разметки (кластеры лиц, назначение персон, игнорирование, перенос между кластерами и т.п.).

**Исключения**: подтверждения остаются только для **деструктивных операций** (удаление файлов, массовые удаления, операции с gold-данными).

**Требования к интерфейсу (UI)**

1) **Страница "Люди/Персоны"**
- клик по персоне → просмотр подтверждённых лиц/файлов, сгруппированных по папкам,
- быстрые действия: “нет, это другой человек”, “назначить другого”,
- назначение персоны для лица:
  - **Plan A (основной)**: выбрать из **AI‑предложений (top‑K)** прямо в карточке лица,
  - **Plan B (fallback)**: ручной выбор через справочник **группа → персона**.

2) **Отдельный режим “Лица без персоны” (Inbox / Unassigned)**

Цель: быстрый поток разметки “из неопределённого → в конкретных людей”, с упором на кластеризацию и массовые решения.

- **Что попадает в Inbox**:
  - лица/треки, у которых **нет `manual_person`**,
  - и они **не помечены ignore**,
  - (дополнительно) лица/треки с низкой уверенностью или конфликтующими кандидатами — как фильтры.
- **Кластеризация (основной режим)**:
  - группировка похожих лиц в кластеры,
  - массовые действия по кластеру: “это Артём”, “ignore”, “другой человек”, с возможностью исключить отдельные элементы (“всё Артём, кроме этой фотки”).
- **Карточка элемента**:
  - кроп лица/ключевой кадр, ссылка на исходный файл/папку, дата,
  - **AI top‑K кандидатов** (кнопками “это он”),
  - действия: назначить другого (fallback), ignore/не лицо.
- **Фильтры**:
  - по папке архива/источника,
  - по периоду (год/месяц),
  - отдельный фильтр/режим для “много лиц в файле”.

3) **Редактирование лиц на медиа** ✅ РЕАЛИЗОВАНО
- на фото: изменить bbox (через якоря в углах и на сторонах), нарисовать новый bbox, удалить ложный bbox,
- на видео: разметка через **ключевой кадр** трека (минимум на MVP).
- **Единая карточка фотографий** (`photo_card.js`): используется на всех страницах (faces.html, person_detail.html, face_cluster_detail.html) для просмотра и редактирования фото с rectangles. Поддерживает навигацию по списку, UNDO систему, создание новых rectangles (лицо/без лица), изменение типа привязки (кластер ↔ ручная), назначение персон через иерархическое меню.

4) **Страница папок архива**
- показывать аватары распознанных персон для папки,
- клик по аватару → файлы “папка + персона”,
- ручной перенос файла в другую папку с **якорением** в новой папке.

5) **Режим “предложи персону”**

Если система видит много похожих лиц:
- можно завести новую персону (“это …”),
- или назначить режим персоны по приоритету разметки:
  - **Активная**: важна, предлагать и просить разметку,
  - **Отложенная**: узнавать, но предлагать на разметку редко/в конце очереди,
  - **Никогда**: узнавать, но **не предлагать** на разметку (максимальная пессимизация).

**Логика для сортировки с учётом лиц**
- Правила сортировки задаются в таблице `folders` (см. раздел «Правила сортировки»): используются **персоны и группы** из справочника (`person_groups`, `persons`).
- `presence_score` может учитываться при выборе папки (например, приоритет основного лица в кадре).
- Семантика правил «только / вместе / содержажит» (legacy-формат) реализована в `sort_rules.folder_rules_match`.

**Самообучение от ручных правок**
- ручные назначения/исправления bbox должны улучшать качество последующих предложений (механизм уточним отдельно).

## Технологический стек (текущая реализация)

- **Сервер**: Python + **FastAPI** (ASGI)
- **ASGI-сервер**: **Uvicorn**
- **Шаблоны (SSR)**: **Jinja2** (`Jinja2Templates`)
- **Фронт**: серверный HTML (Jinja2) + **ванильный JS** (Fetch к `/api/...`) + встроенный CSS в шаблонах  
  (отдельной сборки/`package.json`/React/Vue сейчас нет)
- **БД**: **SQLite** (`data/photosorter.db`)
- **Интеграция с Я.Диском**: **yadisk** (API-клиент)
- **Конфиги/секреты**: `secrets.env` (основной) или `.env` (fallback) через **python-dotenv**  
  ⚠️ `secrets.env` и `data/photosorter.db` — локальные файлы, в git не коммитим.

## Структура репозитория и модули

```text
PhotoSorter/
  photosorter/                # основной код (ядро), импортируемый из UI/CLI
    pipeline/
      local_sort.py           # локальный конвейер: dedup -> faces -> split
                               # Поддерживает флаг --include-excluded-dirs для обработки файлов в _faces, _no_faces и т.д.
  app/
    main.py                  # FastAPI-приложение: роуты страниц и API
    templates/               # Jinja2-шаблоны страниц (CSS/JS встроены в HTML)
      index.html
      folders.html
      browse.html
      duplicates.html
  DB/
    db.py                    # SQLite-схема + доступ к данным (folders, dedup, faces)
  data/
    photosorter.db           # Локальная SQLite БД (состояние/кэш)
    backups/                 # Бекапы БД: python backend/scripts/tools/backup_database.py → photosorter_backup_YYYYMMDD_HHMMSS.db; проверка: backend/scripts/debug/verify_backup_integrity.py <путь>
    models/                  # Кэш моделей (например YuNet onnx для face-scan) (НЕ коммитить)
  docs/
    diagrams/                # Диаграммы в PlantUML + PNG: сущности (AS-IS / TO-BE), ключевые экраны Web UI
      entities_as_is.puml
      entities_as_is.png
      entities_to_be.puml
      entities_to_be.png
      screens.puml            # Ключевые экраны Web UI и навигация между ними
      screens.png             # (генерируется: python backend/scripts/render_diagrams.py --in-dir docs/diagrams)
      screens.html            # Документация: три вкладки README (встроенный base64 + UTF-8), Экраны (screens.png + ссылки), Схема сущностей (entities_as_is.png, entities_to_be.png); открывать без сервера (file://). Встраивание: python backend/scripts/render_diagrams.py --in-dir docs/diagrams
  scripts/
    tools/                   # Утилиты (скан/дамп/загрузка папок в БД)
      face_scan.py           # MVP: скан лиц для YaDisk папки (пишет bbox/presence/thumbnail в SQLite)
      local_sort_by_faces.py # thin-wrapper: запускает photosorter.pipeline.local_sort (backward compat)
    debug/                   # Отладочные скрипты для YaDisk/папок
    regression/              # экспорт/проверки регресса
    run_server.ps1           # “одной кнопкой” запустить uvicorn --reload
    run_face.ps1             # “одной кнопкой” запускать face-задачи через .venv-face (без activate)
    render_diagrams.py       # Генерация PNG из PlantUML через локальный plantuml.jar (путь PLANTUML_JAR в secrets.env или backend/scripts/plantuml.jar)
    render_diagrams.ps1      # Обёртка для render_diagrams.py
  regression/
    cases/                   # регрессионные списки путей (append-only)
  yadisk_client.py           # Создание клиента YaDisk + загрузка токена из env
  requirements.txt           # Python-зависимости (фиксированные версии)
  requirements-face.txt      # Отдельные зависимости для .venv-face (Python 3.12) под распознавание лиц
  README.md
  TODO.md
  secrets.env                # Локальные секреты (НЕ коммитить)
```

**Ключевые модули**

- **`photosorter/`**: основной код сортера. `scripts/` остаётся для запускалок/дебага/экспорта.
- **`app/main.py`**: FastAPI `app`, HTML-страницы (`/`, `/folders`, `/browse`, `/duplicates`) и JSON API (`/api/...`), плюс вспомогательная логика (ретраи/таймауты YaDisk, превью-redirect, дедуп-сканы).
- **`app/templates/*.html`**: UI-страницы на Jinja2; стили и JS (fetch/рендер/прогресс) — инлайном.
- **Документация (страница)**: `docs/diagrams/screens.html` — автономная страница «Документация» с тремя вкладками: **README** (встроенный base64 из `docs/README.md`, UTF-8 декодирование для кириллицы), **Экраны** (схема переходов screens.png + ссылки на экраны), **Схема сущностей** (диаграммы entities_as_is.png, entities_to_be.png). Открывается в браузере без Uvicorn (file://). Для встраивания README: `python backend/scripts/render_diagrams.py --in-dir docs/diagrams`. Восстановление при повреждении: `python backend/scripts/debug/fix_screens_readme_block.py`.
- **`DB/db.py`**: доступ к данным SQLite (чтение справочника папок `list_folders`, слой для дедупа `DedupStore`: прогоны, инвентарь файлов, хэши, пометки deleted/ignore, reconcile). **Важно:** при старте приложения вызывается `init_db()` — создаёт таблицы, если их нет (подъём с нуля). Для уже существующей БД (есть таблица `files`) только проверка и выход; **новые колонки и изменения схемы — только через миграции** (скрипты в `backend/scripts/migration/`), не в runtime.
- **`yadisk_client.py`**: загрузка `YADISK_ACCESS_TOKEN` из `secrets.env/.env` и создание `yadisk.YaDisk`.
- **`scripts/tools/*`**: разовые утилиты, например скан первых уровней `/Фото` в таблицу `folders`.
- **`scripts/debug/*`**: отладка проблемных путей/метаданных на Я.Диске.
- **`regression/cases/*`**: регресс в виде списков путей (append-only). Экспорт из БД — `scripts/regression/export_cases_from_db.py`.

## Правила сортировки

Правила хранятся в **`folders.content_rule`**, порядок применения — в **`folders.sort_order`**. Редактирование — на странице **`/folders`** (конструктор правил в колонке «Правило»). Логика: `backend/common/sort_rules.py` (`resolve_target_folder_for_faces`, `determine_target_folder`).

**Как выбирается папка:**
- Для файлов **с лицами** перебираются папки по `sort_order`; для каждой проверяется `content_rule` против списка персон на файле (из `file_persons` и привязок по лицам/кластерам). Используются группы из `person_groups` (приоритет у правил с `*_id`).
- Для **животных** — папка с правилом `animals` (path из `folders`).
- Для **нет лиц** — по `file_groups.group_path`: поездки (Путешествия/Поездки, год в названии) → путь из `folders` (например `disk:/Фото/Путешествия/...`); остальные группы (Технологии, Чеки и т.д.) → только локальная раскладка `local:root/группа`, на ЯД не заливаются.
- Fallback для лиц — папка с правилом `any_people` или «Другие люди».

**Форматы `content_rule`:**
- `animals`, `any_people` — папка для животных / общая для лиц.
- `only_one_from_group_id:N` или `N:M`, `multiple_from_group_id:N`, `contains_group_id:N` — по группам из `person_groups` (id группы, опционально id персоны).
- Legacy по имени группы: `only_one_from_group:Имя`, `multiple_from_group:Имя`, `contains_group:Имя`.
- Legacy «Свой текст»: `только:[X]`, `вместе:[A,B]`, `содержит:[A,B]` (парсинг в `parse_content_rule`, совпадение в `folder_rules_match`).

**Целевой путь** для папки берётся из `folders.path` (может быть `disk:/Фото/...` или локальный); для служебных категорий (_quarantine, _no_faces и т.д.) строится под корнем прогона.

## Что уже сделано

- Web UI (FastAPI): страницы `/`, `/folders`, `/browse`, `/duplicates`.
- SQLite-справочник папок (`folders`) + отображение в UI.
- Асинхронный рекурсивный подсчёт количества файлов по папкам в UI.
- API для подсчёта/отладки: `/api/folder-count/{code}`, `/api/path-count`, `/api/path-listing`, `/api/debug/build-info`.
- Стабилизация работы с Я.Диском: ретраи/таймауты, защита от циклов; увеличен таймаут YaDisk-вызовов до 60 секунд; исправлена нормализация путей (без `.strip()`).
- Дедупликация архива `disk:/Фото` (инвентаризация + хэши в SQLite) и страница `/duplicates` для просмотра групп дублей.
- Действия на `/duplicates`:
  - удаление “неотмеченных” копий в корзину,
  - “переместить в «Дети вместе» + удалить остальные” (с обработкой конфликтов имён),
  - открытие файла в веб-интерфейсе Я.Диска в режиме просмотра (slider).
- Превью дублей: `/api/yadisk/preview-image` отдаёт 307 redirect на YaDisk preview URL (без проксирования байтов через сервер).
- Исправление 403 на превью: `no-referrer` для картинок.
- Длительность видео: асинхронный `ffprobe` + кеш в SQLite (`files.duration_sec`).
- Сверка архива (Reconcile Archive): кнопка на `/folders` и API, чтобы догонять ручные изменения на Я.Диске (перемещения/удаления/изменения).
- Основная “рабочая форма сортировки” на `/` (one-page):
  - выбор источника: Я.Диск (`disk:/...`, любая папка) или локальная папка (`C:\...`),
  - запуск скана источника и прогресс,
  - Шаг 1: дубли источника, которые уже есть в архиве `disk:/Фото` (удалить / “не дубль” до следующего перескана),
  - Шаг 2: дубли внутри источника (автовыбор “оставить 1”, кнопки “удалить копии” и “удалить всё (мусор)”),
  - превью для фото/видео (локальные видео — inline, видео на Я.Диске — открыть в slider), длительность локальных видео.

## Распознавание лиц из фотобанка

Реализована система распознавания лиц из фотобанка (Я.Диск `disk:/Фото`) и локальных папок с определением персон:

- **Сканирование лиц**:
  - **Архив (Я.Диск)**: скрипт `backend/scripts/tools/face_scan.py` сканирует папки на Я.Диске, находит лица (YuNet), извлекает embeddings (ArcFace) и сохраняет в БД.
  - **Локальные папки**: конвейер `local_sort.py` включает детекцию лиц для локальных источников (например `C:\tmp\Photo`). Поддерживается обработка файлов в исключаемых папках через флаг `--include-excluded-dirs`.
- **Кластеризация**: похожие лица группируются в кластеры (DBSCAN) для массовой разметки. Запускается автоматически после детекции или вручную. Приоритет поиска существующих кластеров перед созданием новых - новые лица автоматически добавляются в существующие кластеры из фотоархива и наследуют привязку к персоне через JOIN.
- **Справочник персон**: редактируемый справочник людей (`persons`) с аватарами, режимами разметки (active/deferred/never) и статистикой.
- **Назначение персон**: лица можно назначать персонам вручную или массово по кластерам; система использует контекст папок для предложений.
- **Web UI**:
  - `/face-clusters` — просмотр и управление кластерами лиц, массовое назначение персон
  - `/persons` — список персон с статистикой. Кнопка **«Создать персону»** открывает модальное окно: имя, выбор группы (из существующих или «+ Создать новую группу» с названием и приоритетом). API: `GET /api/persons/groups` (список групп с приоритетами), `POST /api/persons/create` (опционально `group`, `group_order` для новой группы). Редактирование персоны (в т.ч. группа) — на странице `/persons/{person_id}` и через `PUT /api/persons/{person_id}` (поддерживается `group_order`).
  - `/persons/{person_id}` — детали персоны: все файлы с этим человеком, похожие лица, управление аватаром и группой

**Технологии**:
- Face Detection: YuNet (OpenCV)
- Face Recognition: ArcFace ONNX (w600k_r50.onnx) через onnxruntime
- Кластеризация: DBSCAN (scikit-learn) с параметрами `eps` (по умолчанию 0.5) и `min_samples` (по умолчанию 2), настраиваются через `--cluster-eps` и `--cluster-min-samples` в pipeline
- Приоритет существующих кластеров: при кластеризации сначала ищутся существующие кластеры из фотоархива, новые лица добавляются в них по схожести embeddings, только для оставшихся создаются новые кластеры
- Автоматическая привязка к персонам: новые лица, добавленные в существующие кластеры, автоматически относятся к персоне через `face_clusters.person_id` (без создания избыточных записей)
- Хранение: embeddings в БД (таблица `face_rectangles.embedding`), кластеры в `face_clusters` с прямой привязкой к персоне через `person_id`, ручные привязки отдельных лиц в `face_person_manual_assignments`

**Утилиты для работы с лицами**:
- `backend/scripts/tools/diagnose_faces_issue.py` — диагностика проблем детекции лиц (расхождения между files.faces_count и face_rectangles)
- `backend/scripts/tools/reset_faces_scan.py` — очистка faces_scanned_at для перезапуска детекции
- `backend/scripts/tools/reset_pipeline_status.py` — сброс статуса прогона pipeline на 'running'
- `backend/scripts/tools/backfill_embeddings.py` — извлечение embeddings для уже обнаруженных лиц
- `backend/scripts/tools/analyze_persons_and_video.py` — анализ привязки лиц к персонам и статистика по видео
- `backend/scripts/tools/check_clusters_and_video.py` — проверка кластеров, embeddings и видео
- `backend/scripts/tools/analyze_person_distribution.py` — анализ распределения файлов по персонам
- `backend/scripts/tools/benchmark_persons_query.py` — бенчмарк производительности SQL-запросов для получения списка персон с файлами

**Оптимизация производительности UI**:
- **Кэширование API запросов**: клиентское кэширование для `/api/faces/persons-with-files` (TTL 10 секунд) и `/api/faces/file-persons`/`/api/faces/rectangles` (TTL 30 секунд)
- **Оптимизация SQL-запросов**: запросы через кластеры оптимизированы с использованием подзапросов (ускорение в 62 раза: с 3.3с до 0.05с)
- **Батчинг загрузки**: загрузка персон для карточек выполняется батчами по 10 файлов параллельно
- **Предотвращение лишних вызовов**: добавлен флаг `personsSubtabsLoaded` для предотвращения повторной загрузки списка подзакладок персон, если он уже загружен и кэш актуален

**Архитектура данных для архива vs прогонов**:
- **Архивные данные** (`archive_scope='archive'`): лица и кластеры в архиве `disk:/Фото` хранятся **без привязки к прогонам** (`run_id=NULL`). Это позволяет накапливать данные независимо от конкретных сканов и использовать "append без дублирования" — новые лица добавляются только если их ещё нет (проверка по `file_path` + `bbox`).
- **Данные прогонов** (`run_id` задан, `archive_scope=NULL`): для временных сортируемых папок (например `C:\tmp\photo`) лица привязаны к конкретному прогону конвейера, что позволяет отслеживать результаты обработки источника.
- **Миграция**: существующие архивные данные из прогонов (`scope='yadisk'`, `root_path` начинается с `disk:/Фото`) были мигрированы в `archive_scope='archive'` с `run_id=NULL` через скрипт `backend/scripts/tools/migrate_archive_faces.py`. Таблицы `face_rectangles` и `face_clusters` были обновлены: `run_id` стал опциональным (NULL разрешён) для поддержки архивных данных.

Подробнее см. `docs/FACE_RECOGNITION.md`.

## Что планируется

- Модуль "источник → список объектов Photo" (фото+видео) с метаданными (дата/гео/тип).
- Надёжная дедупликация по содержимому по всему Диску.
- Применение правил сортировки с учётом распознанных персон.
- Улучшение качества распознавания через самообучение от ручных правок.

### Ближайшие шаги (план)

- Уточнить и стабилизировать UX "source → archive": сообщения "архив не сканирован" vs "совпадений нет", массовые действия и подтверждения.
- Интеграция распознавания персон в правила сортировки (автоматическая раскладка по папкам на основе распознанных лиц).

## Проектировочные решения (Design Decisions)

- **DD-001 — API-first, без массового скачивания**: основная работа идёт через YaDisk API (листинг/метаданные/перемещения), чтобы не хранить всё локально; скачивание используется точечно (например, для хэша в DD-009).
- **DD-002 — Справочник папок и правил в SQLite**: конфигурация целевых папок/правил/приоритетов хранится в SQLite (`folders`) и используется Web UI.
- **DD-003 — Сортировка по правилам из БД**: порядок применения правил задаётся `sort_order` в таблице `folders`; сами правила — в `content_rule`. Имена папок и пути не захардкожены. Логика: `sort_rules.resolve_target_folder_for_faces`, `sort_rules.determine_target_folder`.
- **DD-004 — Устойчивость к проблемам API/путей**: используем ретраи/таймауты, защиту от циклов и диагностические эндпойнты. Таймаут YaDisk-вызовов увеличен до 60 секунд из‑за больших папок.
- **DD-005 — Web UI как инструмент контроля/отладки**: рекурсивные подсчёты загружаются асинхронно с прогрессом; есть drill-down просмотр папок (`/browse`) для поиска проблемных подпапок.
- **DD-006 — Секреты через `.env`/`secrets.env`**: токены/ключи не хардкодим, используем `secrets.env` (основной) и `.env` (fallback).
- **DD-007 — Минимум зависимостей и модульность**: ядро — Python + `yadisk`, `python-dotenv`, `sqlite3`; логика сортировки/доступ к Диску/БД разделяются по модулям.
- **DD-008 — Дедупликация по содержимому для фото и видео**: дедупликация применяется ко всем файлам (фото+видео), не только к изображениям.
- **DD-009 — Стратегия получения хэша (вариант B)**: если YaDisk не отдаёт `sha256/md5` в метаданных — скачиваем файл локально и считаем хэш сами; результат сохраняем в SQLite.
- **DD-010 — Сначала строим БД дублей, без действий на Диске**: первый шаг — только инвентаризация/группы дублей в БД; удаление/перемещения — позже через UI.
- **DD-011 — Разрешаем несколько KEEP**: в группе дублей можно оставить 1+ копий в разных папках, остальные помечаются на удаление.
- **DD-012 — Только “последний прогон”, без истории**: для каждого типа прогона храним только последнее состояние (можно запускать повторно — “resume по данным”, т.к. уже захешированные файлы не перехешируются).
- **DD-013 — Два scope для дедупликации**: `archive` (YaDisk `disk:/Фото`) и `source` (локальная папка-источник, например `C:\tmp\Photo`). Хэши складываем в одну общую таблицу, чтобы переиспользовать кэш.
- **DD-014 — Архивные лица без привязки к прогонам**: для архива `disk:/Фото` лица и кластеры хранятся с `archive_scope='archive'` и `run_id=NULL`, что позволяет накапливать данные независимо от конкретных сканов. Для временных сортируемых папок используется `run_id` (привязка к прогону конвейера). При добавлении новых архивных лиц применяется "append без дублирования" — проверка существования по `file_path` + `bbox` перед вставкой.
- **DD-015 — Удаление cluster_id из face_labels (устранение избыточности)**: колонка `cluster_id` удалена из таблицы `face_labels` для устранения избыточности и рассинхронизации с `face_cluster_members`. `face_cluster_members` является единственным источником истины о том, в каком кластере находится лицо (PRIMARY KEY гарантирует 1:1). `face_labels` хранит только связь лицо → персона. Кластер определяется через JOIN с `face_cluster_members` при необходимости. Это устраняет проблему рассинхронизации при объединении кластеров, когда в `face_labels` могли оставаться старые записи со старым `cluster_id`. Подробный план рефакторинга: `docs/REFACTORING_PLAN_remove_cluster_id_from_face_labels.md`.
- **DD-016 — Добавление person_id в face_clusters и переименование face_labels**: 
  - Добавлено поле `person_id` в таблицу `face_clusters` для прямой привязки кластера к персоне
  - Таблица `face_labels` переименована в `face_person_manual_assignments` для ясности назначения
  - Удалены все записи с `source='cluster'` из `face_labels` (они больше не нужны, т.к. кластеры привязаны через `face_clusters.person_id`)
  - `face_person_manual_assignments` используется **только** для ручных привязок отдельных лиц (не через кластеры)
  - Лица в кластере наследуют персону через JOIN: `face_rectangles → face_cluster_members → face_clusters.person_id`
  - Это устраняет дублирование персон в UI и упрощает запросы. Подробный план миграции: `docs/PLAN_add_person_id_to_face_clusters.md`
- **DD-017 — Синхронизация списка персоны после изменений в карточке фотографий**: 
  - **Проблема**: При открытии карточки фотографий из списка лиц персоны передается `list_context` с массивом элементов. Если в карточке изменить привязку лица к другой персоне, исходный список на странице персоны не обновляется автоматически, что приводит к рассинхронизации (элемент может уже не принадлежать персоне, но оставаться в списке).
  - **Решение**: При закрытии карточки фотографий всегда отправляется событие `photoCardClosed` с данными для позиционирования (`file_id` + `rectangle_id`). Страница персоны слушает это событие, обновляет список через `loadPerson()` и позиционируется на нужный элемент по `file_id` + `rectangle_id` (вместо индекса, что надежнее при изменении списка).
  - **Реализация**: 
    - В `photo_card.js` при закрытии карточки отправляется CustomEvent `photoCardClosed` с `file_id`, `face_rectangle_id`, `person_rectangle_id`
    - В `person_detail.html` добавлен слушатель события, который вызывает `loadPerson()` и затем позиционируется на элемент с соответствующими data-атрибутами (`data-file-id`, `data-face-id`, `data-person-rectangle-id`)
  - **Преимущества**: Простота (без проверки изменений, всегда обновляем), надежность (позиционирование по ID, а не по индексу), минимальная нагрузка (обновление только при закрытии карточки)
  - **Статус**: Планируется в ЭТАП 3.6 мастерплана. Подробный план: `.cursor/plans/рефакторинг_списка_и_карточки_персоны.plan.md` (задача D)

## Web интерфейс (просмотр папок)

Установка зависимостей:

```bash
pip install -r requirements.txt
```

Запуск сервера (локально, рекомендуемый — без `--reload`):

```bash
uvicorn --app-dir . app.main:app --port 8000
```

Рекомендуемый режим разработки (Windows / PowerShell) — с авто‑reload:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe -m uvicorn --reload --app-dir . app.main:app --host 127.0.0.1 --port 8000
```

Проверка, что сервер “свежий” (после reload/рестарта):

```powershell
curl.exe -i --connect-timeout 1 --max-time 5 http://127.0.0.1:8000/api/debug/build-info
```

Ожидаем **HTTP 200** и совпадение заголовка **`x-photosorter-build`** с полем JSON **`build_id`**.

Открыть в браузере:
- `http://127.0.0.1:8000/` — основная форма сортировки (one-page)
- `http://127.0.0.1:8000/folders` — список папок (из SQLite)
- `http://127.0.0.1:8000/browse?path=disk:/Фото` — просмотр дерева папок
- `http://127.0.0.1:8000/duplicates` — просмотр дублей архива (архив= `disk:/Фото`)
- `http://127.0.0.1:8000/dedup-results?pipeline_run_id=6` — результаты шага 1 (вкладки 1.1/1.2) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/faces?pipeline_run_id=6` — результаты шага 2 (вкладки “Есть лица/Нет лиц”) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/gold?pipeline_run_id=6` — отладочная страница gold-эталона (кейсы регресса) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/face-clusters` — кластеры лиц (распознавание лиц из фотобанка, группировка похожих лиц)
- `http://127.0.0.1:8000/persons` — справочник персон (люди, которых распознаёт система)
- `http://127.0.0.1:8000/persons/{person_id}` — детали персоны (файлы с этим человеком, статистика)
- `http://127.0.0.1:8000/docs` — список API

## Результаты шагов конвейера (Web UI)

### План шагов локального конвейера (roadmap)

Нумерация ниже — **план/целевое состояние** (в UI и логах сейчас местами используется “старая” нумерация).

1) **Предочистка**: вынести не‑медиа и битые медиа в `_non_media` / `_broken_media` (до дедупа)
2) **Дедупликация**: инвентаризация + поиск дублей внутри источника (и сверка с архивом — отдельно в UI дедуп‑результатов)
3) **Сортировка 1**: “Лица / Животные / Нет людей” (скан + разложение по служебным папкам)
4) **Сортировка 2**: “Нет людей → время и места” (UI‑сортировка/фильтры по периоду и гео; дальнейшая автоматизация — отдельно)
5) **Сортировка 3**: определение людей (персоны/группы, разметка, улучшение качества)
6) **Сортировка по правилам**: перенос в папки архива по правилам из таблицы `folders` (БД)

**Видео (опционально)**:
- включается через env `LOCAL_PIPELINE_VIDEO_SAMPLES=0..3` (например `3` = 3 кадра на видео),
- важно: после изменения `secrets.env/.env` **нужен перезапуск сервера**, чтобы worker унаследовал новое окружение.

### Шаг 1 — Дедупликация

- Страница результатов: `/dedup-results?pipeline_run_id=...`
- Вкладки:
  - **1.1 Внутри папки** (дубли внутри исходной папки)
  - **1.2 С архивом** (дубли с фотоархивом `disk:/Фото`)

### Шаг 3 — Лица / нет лиц

- Страница результатов: `/faces?pipeline_run_id=...`
- Вкладки:
  - **Есть лица**
  - **Карантин**
  - **Животные**
  - **Есть люди (без лиц)**
  - **Нет лиц**
- Кнопка **"Переместить файлы в папки"**: раскладывает файлы по категориям на основе результатов первых 3 шагов:
  - Шаг 1: `_non_media`, `_broken_media`
  - Шаг 3: `_faces`, `_quarantine`, `_animals`, `_people_no_face`, `_no_faces`
  - **Нет лиц**
- Дополнительно (отладка/регресс):
  - `/gold?pipeline_run_id=...` — просмотр gold-эталона (списки путей) + действия: обновить gold из БД и “append-only” перенести разметку из gold в БД
- UX:
  - **double click** по превью — открыть просмотр bbox (авто + ручные)
  - бесконечная подгрузка (infinite scroll)
  - разметка “потоком”: кнопки-метки не делают reload и не “прыгают” список

## Ручная корректировка “лица / нет лиц” (шаг 2)

- Во вкладке **“Нет лиц”**:
  - нажать на карточке **“Лица есть (разметить)”** или открыть превью (double click) и нажать **“Разметить”** в модалке
  - выделить прямоугольник мышью
  - нажать **“Сохранить”**
- Во вкладке **“Есть лица”**:
  - кнопка **“Лиц нет”** помечает файл как `no_faces`
  - кнопки **“Карантин”** / **“Кот”** ставят ручные метки (для регресса/разбора)
- Во вкладке **“Карантин”**:
  - кнопки **“Нормальные лица”** / **“Кот”** снимают карантин/переопределяют категорию

Данные сохраняются в SQLite:
- `files.faces_manual_label` / `files.faces_manual_at`
- `files.faces_auto_quarantine` / `files.faces_quarantine_reason` (в т.ч. `manual`)
- `files.animals_auto` / `files.animals_kind` (в т.ч. `cat`)
- `files.people_no_face_manual` / `files.people_no_face_person`
- `face_rectangles.is_manual` / `face_rectangles.manual_created_at`

### Логика вкладки «К разбору» (Люди)

Файл **не попадает** в «К разбору» (и уходит на подзакладку персоны), если есть привязка к персоне хотя бы одним способом:

- **Прямоугольники**: в `photo_rectangles` есть запись с `manual_person_id` (и `run_id` текущего прогона или `archive_scope='archive'`, либо файл принадлежит текущему прогону по `files.faces_run_id`).
- **Кластеры**: прямоугольник входит в кластер с назначенной персоной (`face_clusters.person_id`).
- **Прямая привязка файла**: в `file_persons` есть запись для этого `file_id` и `pipeline_run_id` (кнопка «Персона» → «привязать ко всему фото»).

Для файлов с меткой «люди без лиц» (`people_no_face_manual=1`) в «К разбору» попадают только те, у кого **нет** ни привязки по прямоугольникам, ни записи в `file_persons`; после назначения персоны (в т.ч. через file_persons) файл исчезает из «К разбору». Диагностика по конкретному файлу: `python backend/scripts/debug/debug_photo_assignments.py --path <подстрока пути> --pipeline-run-id <id>`.

## Регресс: списки путей + экспорт из БД

Регресс хранится в `regression/cases/*_gold.txt` (append-only, ничего не затираем).

Экспорт из БД по конкретному прогону:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe scripts/regression/export_cases_from_db.py --pipeline-run-id 10 --out-dir regression/cases
```

Проверка регресса:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe scripts/regression/run_regression_checks.py --cases-dir regression/cases --mode effective
```

### Gold: обновление из БД и перенос разметки в БД (append-only)

- Обновить gold-файлы из БД: `POST /api/gold/update-from-db`
- Заполнить ручную разметку в БД из gold (append-only: не перетирает уже размеченные записи): `POST /api/gold/apply-to-db`
- UI-страница для этого: `/gold?pipeline_run_id=...`

## Важно про DRY_RUN vs apply

- В режиме **DRY_RUN** файлы **не перемещаются** на диске, папки `_faces/_no_faces/_duplicates` могут не появиться.
- Для реального разложения/перемещения файлов нужен режим **apply** (не dry-run).

## Быстрый старт после перезагрузки

1) Перейти в папку проекта.

2) Убедиться, что порт свободен:

```bash
netstat -ano | findstr :8000
```

3) Запустить сервер:

```bash
# Перейти в корень проекта (замените на актуальный путь)
cd /path/to/PhotoSorter
C:\\Users\\mzaborov\\AppData\\Local\\Python\\pythoncore-3.14-64\\python.exe -m uvicorn --app-dir . app.main:app --port 8000
```

4) Открыть:
- `/folders` — таблица папок с **конструктором правил** (см. ниже)
- В колонке "Путь" есть ссылка **↗** на просмотр вложенных папок (`/browse?path=...`)

## Страница /folders — редактирование правил (content_rule)

На странице `/folders` задаётся **список папок**, их **пути** (`path`) и **правила** (`content_rule`). Порядок папок (приоритет применения правил) задаётся полем **sort_order**. В колонке «Правило» — **конструктор правил** для задания `content_rule` без ручного ввода синтаксиса.

**Типы правил (соответствуют `sort_rules.py`):**
| Тип в UI | Формат в БД | Описание |
|----------|-------------|----------|
| Животные | `animals` | Папка для фото с животными |
| Любые люди | `any_people` | Общая папка для лиц (fallback) |
| По группе | `group_path:Поездки` | Для файлов без лиц (no_faces) — по `file_groups.group_path` |
| ≥1 из группы | `contains_group_id:N` | Хотя бы один человек из группы N (`person_groups`) |
| 1 из группы | `only_one_from_group_id:N` или `...:N:M` | Ровно один из группы N; опционально персона (id M) |
| ≥2 из группы | `multiple_from_group_id:N` | Два и более человека из группы N |
| Свой текст | произвольная строка | Legacy: `только:[X]; вместе:[A,B]; содержит:[A,B]` |

**Особенности:** правила рендерятся при загрузке; для правил с группой — выпадающий список групп из БД; кнопка ✓ сохраняет правило. Таблица расширена (max-width 1600px).

## Известные проблемы и решения

### Проблема с терминалом Cursor при выполнении Python

**Симптомы:**
- Выполнение команд Python в терминале Cursor может вызывать Connection Error
- Ломается текущий чат и все новые чаты (старые чаты продолжают работать)
- Проблема возникает в произвольный момент, воспроизведения нет

**Причина:**
- Конфликт Shell Integration Cursor с выводом Python команд
- Точная причина не выяснена, проблема нестабильна

**Решение:**
- Shell Integration отключена в `.vscode/settings.json` (`terminal.integrated.shellIntegration.enabled: false`)
- Это уменьшает частоту проблем, но не устраняет полностью

**Workaround при поломке терминала:**
1. Закрыть Cursor полностью
2. Удалить `%APPDATA%\Cursor\User\workspaceStorage\` (очистка битых настроек)
3. Запустить Cursor на чистую
4. Если работали над планом:
   - Стартовать нового агента
   - Попросить прочитать:
     - `.cursor/plans/` (все планы)
     - `docs/README.md`
     - Конкретный план (если был активен)
     - Правила из `.cursor/rules/`
   - Попросить продолжить план с отметкой прогресса

**Профилактика:**
- Все крупные изменения агентов выполняются только через планы (`.cursor/plans/`)
- Агент при выполнении отмечает прогресс в плане
- Python команды выполняются только из файлов (не inline), см. правило `.cursor/rules/python-run-only-from-files.mdc`

**Утилиты для диагностики:**
- `python backend/scripts/debug/diagnose_terminal_issue.py` — диагностика проблемы
- `python backend/scripts/debug/clean_terminal_settings.py --dry-run` — проверка битых настроек
- `python backend/scripts/debug/clean_terminal_settings.py` — очистка битых настроек терминала





