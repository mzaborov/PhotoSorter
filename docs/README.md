# PhotoSorter
Сортировщик фотографий на Яндекс Диске

## Цель проекта

**PhotoSorter** — автоматизировать разбор и наведение порядка в фото/видео на Яндекс.Диске: находить дубликаты по содержимому, определять категорию (люди/дети/семья/животные/без людей) и раскладывать по заранее заданным папкам в `disk:/Фото`, с управлением правилами через Web UI.

## Термины

- **Архив**: в рамках проекта под “архивом” понимается папка **`disk:/Фото`** на Яндекс.Диске.

## Целевые папки и порядок (disk:/Фото)

Порядок приоритета (сверху — раньше):

1) Без людей и животных (папка будет заведена отдельно, имя уточним)
2) Агата — `disk:/Фото/Агата`
3) Санек — `disk:/Фото/Санек`
4) Нюся — `disk:/Фото/Нюся`
5) Темка — `disk:/Фото/Темка`
6) Дети вместе — `disk:/Фото/Дети вместе`
7) Миша и Аня — `disk:/Фото/Миша и Аня`
8) Бабушки и Дедушки — `disk:/Фото/Бабушки и Дедушки`
9) Семья — `disk:/Фото/Семья`
10) Котэ и сцобако — `disk:/Фото/Котэ и сцобако`
11) Другие люди — `disk:/Фото/Другие люди`

Дополнительно в учёте/справочнике есть крупные папки: `disk:/Фото/Путешествия`, `disk:/Фото/Технологии`.

## Распознавание лиц

**Цель**

Сделать распознавание лиц (фото + видео) как основу для автоматизации сортировки “source → archive” и удобной ручной разметки. По UX близко к Tonfotos, но:
- с большим упором на **автоматизацию** (массовые действия, предложения, якорение),
- с поддержкой **видео**,
- с возможностью **быстро уточнять** результаты вручную.

**Термины**

- **Персона**: человек в справочнике (например “Агата”, “Санек”, “Михаил Заборов”).
- **Группа персон**: логическая группа (например “Семья”, “Дети”, “Синяя диагональ”). Персона может входить в несколько групп.
- **Лицо (face)**: найденная область на фото (bbox/прямоугольник).
- **Трек лица (face track)**: лицо на видео как последовательность bbox во времени + ключевой кадр для разметки.
- **presence_score / доля присутствия**: насколько “сильно” персона представлена в файле:
  - для **фото** — доля площади лица среди всех лиц в кадре: `area(face_bbox) / sum(area(all_face_bbox))` (если лицо одно — 100%),
  - для **видео** — доля времени/кадров, когда виден трек лица.

**Данные в БД (концептуально)**

Для каждого медиа-файла (фото/видео) хранится список найденных лиц/треков и атрибуты:
- **bbox / расположение** лица на фото (прямоугольник; для видео — на ключевом кадре и/или по треку),
- **presence_score** (см. выше),
- **AI предположение**: список кандидатов `[{персона, вероятность/score}]`,
- **ручное подтверждение**: кто это (персона), установленное пользователем,
- **ignore-флаги**:
  - игнорировать конкретное лицо/трек (ошибка детектора / не нужно),
  - режим персоны по приоритету разметки (см. ниже).

**Архитектура привязки лиц к персонам:**

- **Кластеры**: кластеры лиц привязаны к персонам напрямую через `face_clusters.person_id`. Все лица в кластере наследуют персону через JOIN: `face_rectangles → face_cluster_members → face_clusters.person_id`
- **Ручные привязки**: отдельные лица (не через кластеры) привязываются к персонам через таблицу `face_person_manual_assignments` (бывший `face_labels`)
- **Приоритет**: при определении персоны для лица сначала проверяются ручные привязки (`face_person_manual_assignments`), затем привязка через кластер (`face_clusters.person_id`)

**Справочник персон**

Нужен редактируемый справочник людей, распознаваемых системой:
- аватар персоны (типично — лицо-кроп),
- принадлежность к группам (группы редактируемы, персона может быть в нескольких),
- отметка “это я” (Михаил Заборов),
- степень родства/близости по отношению ко мне (как атрибут персоны),
- агрегированные счётчики по статусам (минимум):
  - сколько лиц/файлов **подтверждено вручную**,
  - сколько **определено AI** (без ручного подтверждения),
  - сколько **требует решения** (inbox/unassigned),
  - сколько **игнорировано**.

**Особенности архива (реальность данных)**

Архивные папки не идеальны: внутри могут быть файлы без лиц или с нераспознаваемыми лицами, но смыслово относящиеся к персоне/папке:
- человек снят со спины/в профиль (узнаваем по контексту),
- фото документов/грамот/подарков/вещей, связанных с человеком.

Требование: такие файлы должны поддерживать **якорение (anchoring)**:
- закрепить файл за папкой (и/или персоной), чтобы автосортировка его не переносила.

**Паттерн интерфейса для разметки**

**Основной принцип**: действия разметки выполняются **без подтверждений**, но с возможностью **отмены (undo)**.

- **Без confirm()**: кнопки разметки (назначить персону, пометить как "не лицо", перенести в другой кластер и т.п.) выполняются сразу при клике, без диалога подтверждения.
- **Undo система**: после каждого действия разметки показывается toast-уведомление с кнопкой "Отменить" на 5 секунд. Пользователь может отменить последнее действие.
- **История действий**: система сохраняет последнее действие в стеке undo. При отмене действие полностью откатывается (возвращается исходное состояние).
- **Применение**: этот паттерн применяется ко всем интерфейсам разметки (кластеры лиц, назначение персон, игнорирование, перенос между кластерами и т.п.).

**Исключения**: подтверждения остаются только для **деструктивных операций** (удаление файлов, массовые удаления, операции с gold-данными).

**Требования к интерфейсу (UI)**

1) **Страница "Люди/Персоны"**
- клик по персоне → просмотр подтверждённых лиц/файлов, сгруппированных по папкам,
- быстрые действия: “нет, это другой человек”, “назначить другого”,
- назначение персоны для лица:
  - **Plan A (основной)**: выбрать из **AI‑предложений (top‑K)** прямо в карточке лица,
  - **Plan B (fallback)**: ручной выбор через справочник **группа → персона**.

2) **Отдельный режим “Лица без персоны” (Inbox / Unassigned)**

Цель: быстрый поток разметки “из неопределённого → в конкретных людей”, с упором на кластеризацию и массовые решения.

- **Что попадает в Inbox**:
  - лица/треки, у которых **нет `manual_person`**,
  - и они **не помечены ignore**,
  - (дополнительно) лица/треки с низкой уверенностью или конфликтующими кандидатами — как фильтры.
- **Кластеризация (основной режим)**:
  - группировка похожих лиц в кластеры,
  - массовые действия по кластеру: “это Артём”, “ignore”, “другой человек”, с возможностью исключить отдельные элементы (“всё Артём, кроме этой фотки”).
- **Карточка элемента**:
  - кроп лица/ключевой кадр, ссылка на исходный файл/папку, дата,
  - **AI top‑K кандидатов** (кнопками “это он”),
  - действия: назначить другого (fallback), ignore/не лицо.
- **Фильтры**:
  - по папке архива/источника,
  - по периоду (год/месяц),
  - отдельный фильтр/режим для “много лиц в файле”.

3) **Редактирование лиц на медиа** ✅ РЕАЛИЗОВАНО
- на фото: изменить bbox (через якоря в углах и на сторонах), нарисовать новый bbox, удалить ложный bbox,
- на видео: разметка через **ключевой кадр** трека (минимум на MVP).
- **Единая карточка фотографий** (`photo_card.js`): используется на всех страницах (faces.html, person_detail.html, face_cluster_detail.html) для просмотра и редактирования фото с rectangles. Поддерживает навигацию по списку, UNDO систему, создание новых rectangles (лицо/без лица), изменение типа привязки (кластер ↔ ручная), назначение персон через иерархическое меню.

4) **Страница папок архива**
- показывать аватары распознанных персон для папки,
- клик по аватару → файлы “папка + персона”,
- ручной перенос файла в другую папку с **якорением** в новой папке.

5) **Режим “предложи персону”**

Если система видит много похожих лиц:
- можно завести новую персону (“это …”),
- или назначить режим персоны по приоритету разметки:
  - **Активная**: важна, предлагать и просить разметку,
  - **Отложенная**: узнавать, но предлагать на разметку редко/в конце очереди,
  - **Никогда**: узнавать, но **не предлагать** на разметку (максимальная пессимизация).

**Логика для сортировки с учётом лиц**
- правила сортировки могут использовать **персоны и группы** (пример: “дети вместе”),
- `presence_score` может влиять на выбор папки (пример: если Нюся “мелькнула”, а основное лицо — Темка, не отправлять в “Дети вместе”).
- Семантика `только:[X]`: unknown-лица не мешают. `только:[X] = true`, если среди распознанных персон в кадре нет ни одного `Y != X` (даже если X встречается в кадре больше одного раза — зеркала/фото-на-фото).

**Самообучение от ручных правок**
- ручные назначения/исправления bbox должны улучшать качество последующих предложений (механизм уточним отдельно).

## Технологический стек (текущая реализация)

- **Сервер**: Python + **FastAPI** (ASGI)
- **ASGI-сервер**: **Uvicorn**
- **Шаблоны (SSR)**: **Jinja2** (`Jinja2Templates`)
- **Фронт**: серверный HTML (Jinja2) + **ванильный JS** (Fetch к `/api/...`) + встроенный CSS в шаблонах  
  (отдельной сборки/`package.json`/React/Vue сейчас нет)
- **БД**: **SQLite** (`data/photosorter.db`)
- **Интеграция с Я.Диском**: **yadisk** (API-клиент)
- **Конфиги/секреты**: `secrets.env` (основной) или `.env` (fallback) через **python-dotenv**  
  ⚠️ `secrets.env` и `data/photosorter.db` — локальные файлы, в git не коммитим.

## Структура репозитория и модули

```text
PhotoSorter/
  photosorter/                # основной код (ядро), импортируемый из UI/CLI
    pipeline/
      local_sort.py           # локальный конвейер: dedup -> faces -> split
                               # Поддерживает флаг --include-excluded-dirs для обработки файлов в _faces, _no_faces и т.д.
  app/
    main.py                  # FastAPI-приложение: роуты страниц и API
    templates/               # Jinja2-шаблоны страниц (CSS/JS встроены в HTML)
      index.html
      folders.html
      browse.html
      duplicates.html
  DB/
    db.py                    # SQLite-схема + доступ к данным (folders, dedup, faces)
  data/
    photosorter.db           # Локальная SQLite БД (состояние/кэш)
    models/                  # Кэш моделей (например YuNet onnx для face-scan) (НЕ коммитить)
  docs/
    diagrams/                # Диаграммы сущностей (AS-IS / TO-BE) в PlantUML + PNG
      entities_as_is.puml
      entities_as_is.png
      entities_to_be.puml
      entities_to_be.png
  scripts/
    tools/                   # Утилиты (скан/дамп/загрузка папок в БД)
      face_scan.py           # MVP: скан лиц для YaDisk папки (пишет bbox/presence/thumbnail в SQLite)
      local_sort_by_faces.py # thin-wrapper: запускает photosorter.pipeline.local_sort (backward compat)
    debug/                   # Отладочные скрипты для YaDisk/папок
    regression/              # экспорт/проверки регресса
    run_server.ps1           # “одной кнопкой” запустить uvicorn --reload
    run_face.ps1             # “одной кнопкой” запускать face-задачи через .venv-face (без activate)
    render_diagrams.py       # Генерация PNG из PlantUML через PlantUML server (для автодокументирования)
    render_diagrams.ps1      # Обёртка для render_diagrams.py
  regression/
    cases/                   # регрессионные списки путей (append-only)
  yadisk_client.py           # Создание клиента YaDisk + загрузка токена из env
  requirements.txt           # Python-зависимости (фиксированные версии)
  requirements-face.txt      # Отдельные зависимости для .venv-face (Python 3.12) под распознавание лиц
  README.md
  TODO.md
  secrets.env                # Локальные секреты (НЕ коммитить)
```

**Ключевые модули**

- **`photosorter/`**: основной код сортера. `scripts/` остаётся для запускалок/дебага/экспорта.
- **`app/main.py`**: FastAPI `app`, HTML-страницы (`/`, `/folders`, `/browse`, `/duplicates`) и JSON API (`/api/...`), плюс вспомогательная логика (ретраи/таймауты YaDisk, превью-redirect, дедуп-сканы).
- **`app/templates/*.html`**: UI-страницы на Jinja2; стили и JS (fetch/рендер/прогресс) — инлайном.
- **`DB/db.py`**: доступ к данным SQLite (чтение справочника папок `list_folders`, слой для дедупа `DedupStore`: прогоны, инвентарь файлов, хэши, пометки deleted/ignore, reconcile). **Важно:** DDL операции (создание/изменение схемы) выполняются только явно через скрипты, не в runtime, чтобы исключить риск порчи данных.
- **`yadisk_client.py`**: загрузка `YADISK_ACCESS_TOKEN` из `secrets.env/.env` и создание `yadisk.YaDisk`.
- **`scripts/tools/*`**: разовые утилиты, например скан первых уровней `/Фото` в таблицу `folders`.
- **`scripts/debug/*`**: отладка проблемных путей/метаданных на Я.Диске.
- **`regression/cases/*`**: регресс в виде списков путей (append-only). Экспорт из БД — `scripts/regression/export_cases_from_db.py`.

## Точные правила сортировки

Обозначения:
- `только:[X]` — в кадре только X (и никаких других людей)
- `вместе:[A,B,C...]` — в кадре минимум двое из списка
- `содержит:[X,Y...]` — в кадре есть хотя бы один из списка

Правила применяются по порядку приоритета:

- Без людей и животных: если нет людей и нет кошек/собак → (отдельная ветка “без людей”)
- Агата: `только:[Агата]` → `disk:/Фото/Агата`
- Санек: `только:[Санек]` → `disk:/Фото/Санек`
- Нюся: `только:[Нюся]` → `disk:/Фото/Нюся`
- Темка: `только:[Темка]` → `disk:/Фото/Темка`
- Дети вместе: `вместе:[Агата, Санек, Нюся, Темка]` → `disk:/Фото/Дети вместе`
- Миша и Аня (широкое правило): `содержит:[Миша, Аня]` → `disk:/Фото/Миша и Аня`
- Бабушки и Дедушки: `содержит:[...список персон...]` → `disk:/Фото/Бабушки и Дедушки`
- Семья: `содержит:[...список персон...]` → `disk:/Фото/Семья`
- Котэ и сцобако: если есть кошка/собака → `disk:/Фото/Котэ и сцобако`
- Другие люди: если есть люди, но не сработало ничего выше → `disk:/Фото/Другие люди`

Правило “предыдущая папка по приоритету”: следующий этап выполняем только после завершения предыдущего (настраивается в правилах/БД).

## Что уже сделано

- Web UI (FastAPI): страницы `/`, `/folders`, `/browse`, `/duplicates`.
- SQLite-справочник папок (`folders`) + отображение в UI.
- Асинхронный рекурсивный подсчёт количества файлов по папкам в UI.
- API для подсчёта/отладки: `/api/folder-count/{code}`, `/api/path-count`, `/api/path-listing`, `/api/debug/build-info`.
- Стабилизация работы с Я.Диском: ретраи/таймауты, защита от циклов; увеличен таймаут YaDisk-вызовов до 60 секунд; исправлена нормализация путей (без `.strip()`).
- Дедупликация архива `disk:/Фото` (инвентаризация + хэши в SQLite) и страница `/duplicates` для просмотра групп дублей.
- Действия на `/duplicates`:
  - удаление “неотмеченных” копий в корзину,
  - “переместить в «Дети вместе» + удалить остальные” (с обработкой конфликтов имён),
  - открытие файла в веб-интерфейсе Я.Диска в режиме просмотра (slider).
- Превью дублей: `/api/yadisk/preview-image` отдаёт 307 redirect на YaDisk preview URL (без проксирования байтов через сервер).
- Исправление 403 на превью: `no-referrer` для картинок.
- Длительность видео: асинхронный `ffprobe` + кеш в SQLite (`files.duration_sec`).
- Сверка архива (Reconcile Archive): кнопка на `/folders` и API, чтобы догонять ручные изменения на Я.Диске (перемещения/удаления/изменения).
- Основная “рабочая форма сортировки” на `/` (one-page):
  - выбор источника: Я.Диск (`disk:/...`, любая папка) или локальная папка (`C:\...`),
  - запуск скана источника и прогресс,
  - Шаг 1: дубли источника, которые уже есть в архиве `disk:/Фото` (удалить / “не дубль” до следующего перескана),
  - Шаг 2: дубли внутри источника (автовыбор “оставить 1”, кнопки “удалить копии” и “удалить всё (мусор)”),
  - превью для фото/видео (локальные видео — inline, видео на Я.Диске — открыть в slider), длительность локальных видео.

## Распознавание лиц из фотобанка

Реализована система распознавания лиц из фотобанка (Я.Диск `disk:/Фото`) и локальных папок с определением персон:

- **Сканирование лиц**:
  - **Архив (Я.Диск)**: скрипт `backend/scripts/tools/face_scan.py` сканирует папки на Я.Диске, находит лица (YuNet), извлекает embeddings (ArcFace) и сохраняет в БД.
  - **Локальные папки**: конвейер `local_sort.py` включает детекцию лиц для локальных источников (например `C:\tmp\Photo`). Поддерживается обработка файлов в исключаемых папках через флаг `--include-excluded-dirs`.
- **Кластеризация**: похожие лица группируются в кластеры (DBSCAN) для массовой разметки. Запускается автоматически после детекции или вручную. Приоритет поиска существующих кластеров перед созданием новых - новые лица автоматически добавляются в существующие кластеры из фотоархива и наследуют привязку к персоне через JOIN.
- **Справочник персон**: редактируемый справочник людей (`persons`) с аватарами, режимами разметки (active/deferred/never) и статистикой.
- **Назначение персон**: лица можно назначать персонам вручную или массово по кластерам; система использует контекст папок для предложений.
- **Web UI**:
  - `/face-clusters` — просмотр и управление кластерами лиц, массовое назначение персон
  - `/persons` — список персон с статистикой. Кнопка **«Создать персону»** открывает модальное окно: имя, выбор группы (из существующих или «+ Создать новую группу» с названием и приоритетом). API: `GET /api/persons/groups` (список групп с приоритетами), `POST /api/persons/create` (опционально `group`, `group_order` для новой группы). Редактирование персоны (в т.ч. группа) — на странице `/persons/{person_id}` и через `PUT /api/persons/{person_id}` (поддерживается `group_order`).
  - `/persons/{person_id}` — детали персоны: все файлы с этим человеком, похожие лица, управление аватаром и группой

**Технологии**:
- Face Detection: YuNet (OpenCV)
- Face Recognition: ArcFace ONNX (w600k_r50.onnx) через onnxruntime
- Кластеризация: DBSCAN (scikit-learn) с параметрами `eps` (по умолчанию 0.5) и `min_samples` (по умолчанию 2), настраиваются через `--cluster-eps` и `--cluster-min-samples` в pipeline
- Приоритет существующих кластеров: при кластеризации сначала ищутся существующие кластеры из фотоархива, новые лица добавляются в них по схожести embeddings, только для оставшихся создаются новые кластеры
- Автоматическая привязка к персонам: новые лица, добавленные в существующие кластеры, автоматически относятся к персоне через `face_clusters.person_id` (без создания избыточных записей)
- Хранение: embeddings в БД (таблица `face_rectangles.embedding`), кластеры в `face_clusters` с прямой привязкой к персоне через `person_id`, ручные привязки отдельных лиц в `face_person_manual_assignments`

**Утилиты для работы с лицами**:
- `backend/scripts/tools/diagnose_faces_issue.py` — диагностика проблем детекции лиц (расхождения между files.faces_count и face_rectangles)
- `backend/scripts/tools/reset_faces_scan.py` — очистка faces_scanned_at для перезапуска детекции
- `backend/scripts/tools/reset_pipeline_status.py` — сброс статуса прогона pipeline на 'running'
- `backend/scripts/tools/backfill_embeddings.py` — извлечение embeddings для уже обнаруженных лиц
- `backend/scripts/tools/analyze_persons_and_video.py` — анализ привязки лиц к персонам и статистика по видео
- `backend/scripts/tools/check_clusters_and_video.py` — проверка кластеров, embeddings и видео
- `backend/scripts/tools/analyze_person_distribution.py` — анализ распределения файлов по персонам
- `backend/scripts/tools/benchmark_persons_query.py` — бенчмарк производительности SQL-запросов для получения списка персон с файлами

**Оптимизация производительности UI**:
- **Кэширование API запросов**: клиентское кэширование для `/api/faces/persons-with-files` (TTL 10 секунд) и `/api/faces/file-persons`/`/api/faces/rectangles` (TTL 30 секунд)
- **Оптимизация SQL-запросов**: запросы через кластеры оптимизированы с использованием подзапросов (ускорение в 62 раза: с 3.3с до 0.05с)
- **Батчинг загрузки**: загрузка персон для карточек выполняется батчами по 10 файлов параллельно
- **Предотвращение лишних вызовов**: добавлен флаг `personsSubtabsLoaded` для предотвращения повторной загрузки списка подзакладок персон, если он уже загружен и кэш актуален

**Архитектура данных для архива vs прогонов**:
- **Архивные данные** (`archive_scope='archive'`): лица и кластеры в архиве `disk:/Фото` хранятся **без привязки к прогонам** (`run_id=NULL`). Это позволяет накапливать данные независимо от конкретных сканов и использовать "append без дублирования" — новые лица добавляются только если их ещё нет (проверка по `file_path` + `bbox`).
- **Данные прогонов** (`run_id` задан, `archive_scope=NULL`): для временных сортируемых папок (например `C:\tmp\photo`) лица привязаны к конкретному прогону конвейера, что позволяет отслеживать результаты обработки источника.
- **Миграция**: существующие архивные данные из прогонов (`scope='yadisk'`, `root_path` начинается с `disk:/Фото`) были мигрированы в `archive_scope='archive'` с `run_id=NULL` через скрипт `backend/scripts/tools/migrate_archive_faces.py`. Таблицы `face_rectangles` и `face_clusters` были обновлены: `run_id` стал опциональным (NULL разрешён) для поддержки архивных данных.

Подробнее см. `docs/FACE_RECOGNITION.md`.

## Что планируется

- Модуль "источник → список объектов Photo" (фото+видео) с метаданными (дата/гео/тип).
- Надёжная дедупликация по содержимому по всему Диску.
- Применение правил сортировки с учётом распознанных персон.
- Улучшение качества распознавания через самообучение от ручных правок.

### Ближайшие шаги (план)

- Уточнить и стабилизировать UX "source → archive": сообщения "архив не сканирован" vs "совпадений нет", массовые действия и подтверждения.
- Интеграция распознавания персон в правила сортировки (автоматическая раскладка по папкам на основе распознанных лиц).

## Проектировочные решения (Design Decisions)

- **DD-001 — API-first, без массового скачивания**: основная работа идёт через YaDisk API (листинг/метаданные/перемещения), чтобы не хранить всё локально; скачивание используется точечно (например, для хэша в DD-009).
- **DD-002 — Справочник папок и правил в SQLite**: конфигурация целевых папок/правил/приоритетов хранится в SQLite (`folders`) и используется Web UI.
- **DD-003 — Сортировка как цепочка приоритетов**: категории применяются строго по очереди (дети по одному → дети вместе → `содержит:[Миша, Аня]` → бабушки/дедушки → семья → животные → другие люди). Поддерживаем “следующий этап только после предыдущего”.
- **DD-004 — Устойчивость к проблемам API/путей**: используем ретраи/таймауты, защиту от циклов и диагностические эндпойнты. Таймаут YaDisk-вызовов увеличен до 60 секунд из‑за больших папок.
- **DD-005 — Web UI как инструмент контроля/отладки**: рекурсивные подсчёты загружаются асинхронно с прогрессом; есть drill-down просмотр папок (`/browse`) для поиска проблемных подпапок.
- **DD-006 — Секреты через `.env`/`secrets.env`**: токены/ключи не хардкодим, используем `secrets.env` (основной) и `.env` (fallback).
- **DD-007 — Минимум зависимостей и модульность**: ядро — Python + `yadisk`, `python-dotenv`, `sqlite3`; логика сортировки/доступ к Диску/БД разделяются по модулям.
- **DD-008 — Дедупликация по содержимому для фото и видео**: дедупликация применяется ко всем файлам (фото+видео), не только к изображениям.
- **DD-009 — Стратегия получения хэша (вариант B)**: если YaDisk не отдаёт `sha256/md5` в метаданных — скачиваем файл локально и считаем хэш сами; результат сохраняем в SQLite.
- **DD-010 — Сначала строим БД дублей, без действий на Диске**: первый шаг — только инвентаризация/группы дублей в БД; удаление/перемещения — позже через UI.
- **DD-011 — Разрешаем несколько KEEP**: в группе дублей можно оставить 1+ копий в разных папках, остальные помечаются на удаление.
- **DD-012 — Только “последний прогон”, без истории**: для каждого типа прогона храним только последнее состояние (можно запускать повторно — “resume по данным”, т.к. уже захешированные файлы не перехешируются).
- **DD-013 — Два scope для дедупликации**: `archive` (YaDisk `disk:/Фото`) и `source` (локальная папка-источник, например `C:\tmp\Photo`). Хэши складываем в одну общую таблицу, чтобы переиспользовать кэш.
- **DD-014 — Архивные лица без привязки к прогонам**: для архива `disk:/Фото` лица и кластеры хранятся с `archive_scope='archive'` и `run_id=NULL`, что позволяет накапливать данные независимо от конкретных сканов. Для временных сортируемых папок используется `run_id` (привязка к прогону конвейера). При добавлении новых архивных лиц применяется "append без дублирования" — проверка существования по `file_path` + `bbox` перед вставкой.
- **DD-015 — Удаление cluster_id из face_labels (устранение избыточности)**: колонка `cluster_id` удалена из таблицы `face_labels` для устранения избыточности и рассинхронизации с `face_cluster_members`. `face_cluster_members` является единственным источником истины о том, в каком кластере находится лицо (PRIMARY KEY гарантирует 1:1). `face_labels` хранит только связь лицо → персона. Кластер определяется через JOIN с `face_cluster_members` при необходимости. Это устраняет проблему рассинхронизации при объединении кластеров, когда в `face_labels` могли оставаться старые записи со старым `cluster_id`. Подробный план рефакторинга: `docs/REFACTORING_PLAN_remove_cluster_id_from_face_labels.md`.
- **DD-016 — Добавление person_id в face_clusters и переименование face_labels**: 
  - Добавлено поле `person_id` в таблицу `face_clusters` для прямой привязки кластера к персоне
  - Таблица `face_labels` переименована в `face_person_manual_assignments` для ясности назначения
  - Удалены все записи с `source='cluster'` из `face_labels` (они больше не нужны, т.к. кластеры привязаны через `face_clusters.person_id`)
  - `face_person_manual_assignments` используется **только** для ручных привязок отдельных лиц (не через кластеры)
  - Лица в кластере наследуют персону через JOIN: `face_rectangles → face_cluster_members → face_clusters.person_id`
  - Это устраняет дублирование персон в UI и упрощает запросы. Подробный план миграции: `docs/PLAN_add_person_id_to_face_clusters.md`
- **DD-017 — Синхронизация списка персоны после изменений в карточке фотографий**: 
  - **Проблема**: При открытии карточки фотографий из списка лиц персоны передается `list_context` с массивом элементов. Если в карточке изменить привязку лица к другой персоне, исходный список на странице персоны не обновляется автоматически, что приводит к рассинхронизации (элемент может уже не принадлежать персоне, но оставаться в списке).
  - **Решение**: При закрытии карточки фотографий всегда отправляется событие `photoCardClosed` с данными для позиционирования (`file_id` + `rectangle_id`). Страница персоны слушает это событие, обновляет список через `loadPerson()` и позиционируется на нужный элемент по `file_id` + `rectangle_id` (вместо индекса, что надежнее при изменении списка).
  - **Реализация**: 
    - В `photo_card.js` при закрытии карточки отправляется CustomEvent `photoCardClosed` с `file_id`, `face_rectangle_id`, `person_rectangle_id`
    - В `person_detail.html` добавлен слушатель события, который вызывает `loadPerson()` и затем позиционируется на элемент с соответствующими data-атрибутами (`data-file-id`, `data-face-id`, `data-person-rectangle-id`)
  - **Преимущества**: Простота (без проверки изменений, всегда обновляем), надежность (позиционирование по ID, а не по индексу), минимальная нагрузка (обновление только при закрытии карточки)
  - **Статус**: Планируется в ЭТАП 3.6 мастерплана. Подробный план: `.cursor/plans/рефакторинг_списка_и_карточки_персоны.plan.md` (задача D)

## Web интерфейс (просмотр папок)

Установка зависимостей:

```bash
pip install -r requirements.txt
```

Запуск сервера (локально, рекомендуемый — без `--reload`):

```bash
uvicorn --app-dir . app.main:app --port 8000
```

Рекомендуемый режим разработки (Windows / PowerShell) — с авто‑reload:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe -m uvicorn --reload --app-dir . app.main:app --host 127.0.0.1 --port 8000
```

Проверка, что сервер “свежий” (после reload/рестарта):

```powershell
curl.exe -i --connect-timeout 1 --max-time 5 http://127.0.0.1:8000/api/debug/build-info
```

Ожидаем **HTTP 200** и совпадение заголовка **`x-photosorter-build`** с полем JSON **`build_id`**.

Открыть в браузере:
- `http://127.0.0.1:8000/` — основная форма сортировки (one-page)
- `http://127.0.0.1:8000/folders` — список папок (из SQLite)
- `http://127.0.0.1:8000/browse?path=disk:/Фото` — просмотр дерева папок
- `http://127.0.0.1:8000/duplicates` — просмотр дублей архива (архив= `disk:/Фото`)
- `http://127.0.0.1:8000/dedup-results?pipeline_run_id=6` — результаты шага 1 (вкладки 1.1/1.2) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/faces?pipeline_run_id=6` — результаты шага 2 (вкладки “Есть лица/Нет лиц”) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/gold?pipeline_run_id=6` — отладочная страница gold-эталона (кейсы регресса) для конкретного `pipeline_run_id`
- `http://127.0.0.1:8000/face-clusters` — кластеры лиц (распознавание лиц из фотобанка, группировка похожих лиц)
- `http://127.0.0.1:8000/persons` — справочник персон (люди, которых распознаёт система)
- `http://127.0.0.1:8000/persons/{person_id}` — детали персоны (файлы с этим человеком, статистика)
- `http://127.0.0.1:8000/docs` — список API

## Результаты шагов конвейера (Web UI)

### План шагов локального конвейера (roadmap)

Нумерация ниже — **план/целевое состояние** (в UI и логах сейчас местами используется “старая” нумерация).

1) **Предочистка**: вынести не‑медиа и битые медиа в `_non_media` / `_broken_media` (до дедупа)
2) **Дедупликация**: инвентаризация + поиск дублей внутри источника (и сверка с архивом — отдельно в UI дедуп‑результатов)
3) **Сортировка 1**: “Лица / Животные / Нет людей” (скан + разложение по служебным папкам)
4) **Сортировка 2**: “Нет людей → время и места” (UI‑сортировка/фильтры по периоду и гео; дальнейшая автоматизация — отдельно)
5) **Сортировка 3**: определение людей (персоны/группы, разметка, улучшение качества)
6) **Сортировка по правилам**: перенос в папки архива по правилам из README/БД

**Видео (опционально)**:
- включается через env `LOCAL_PIPELINE_VIDEO_SAMPLES=0..3` (например `3` = 3 кадра на видео),
- важно: после изменения `secrets.env/.env` **нужен перезапуск сервера**, чтобы worker унаследовал новое окружение.

### Шаг 1 — Дедупликация

- Страница результатов: `/dedup-results?pipeline_run_id=...`
- Вкладки:
  - **1.1 Внутри папки** (дубли внутри исходной папки)
  - **1.2 С архивом** (дубли с фотоархивом `disk:/Фото`)

### Шаг 3 — Лица / нет лиц

- Страница результатов: `/faces?pipeline_run_id=...`
- Вкладки:
  - **Есть лица**
  - **Карантин**
  - **Животные**
  - **Есть люди (без лиц)**
  - **Нет лиц**
- Кнопка **"Переместить файлы в папки"**: раскладывает файлы по категориям на основе результатов первых 3 шагов:
  - Шаг 1: `_non_media`, `_broken_media`
  - Шаг 3: `_faces`, `_quarantine`, `_animals`, `_people_no_face`, `_no_faces`
  - **Нет лиц**
- Дополнительно (отладка/регресс):
  - `/gold?pipeline_run_id=...` — просмотр gold-эталона (списки путей) + действия: обновить gold из БД и “append-only” перенести разметку из gold в БД
- UX:
  - **double click** по превью — открыть просмотр bbox (авто + ручные)
  - бесконечная подгрузка (infinite scroll)
  - разметка “потоком”: кнопки-метки не делают reload и не “прыгают” список

## Ручная корректировка “лица / нет лиц” (шаг 2)

- Во вкладке **“Нет лиц”**:
  - нажать на карточке **“Лица есть (разметить)”** или открыть превью (double click) и нажать **“Разметить”** в модалке
  - выделить прямоугольник мышью
  - нажать **“Сохранить”**
- Во вкладке **“Есть лица”**:
  - кнопка **“Лиц нет”** помечает файл как `no_faces`
  - кнопки **“Карантин”** / **“Кот”** ставят ручные метки (для регресса/разбора)
- Во вкладке **“Карантин”**:
  - кнопки **“Нормальные лица”** / **“Кот”** снимают карантин/переопределяют категорию

Данные сохраняются в SQLite:
- `files.faces_manual_label` / `files.faces_manual_at`
- `files.faces_auto_quarantine` / `files.faces_quarantine_reason` (в т.ч. `manual`)
- `files.animals_auto` / `files.animals_kind` (в т.ч. `cat`)
- `files.people_no_face_manual` / `files.people_no_face_person`
- `face_rectangles.is_manual` / `face_rectangles.manual_created_at`

### Логика вкладки «К разбору» (Люди)

Файл **не попадает** в «К разбору» (и уходит на подзакладку персоны), если есть привязка к персоне хотя бы одним способом:

- **Прямоугольники**: в `photo_rectangles` есть запись с `manual_person_id` (и `run_id` текущего прогона или `archive_scope='archive'`, либо файл принадлежит текущему прогону по `files.faces_run_id`).
- **Кластеры**: прямоугольник входит в кластер с назначенной персоной (`face_clusters.person_id`).
- **Прямая привязка файла**: в `file_persons` есть запись для этого `file_id` и `pipeline_run_id` (кнопка «Персона» → «привязать ко всему фото»).

Для файлов с меткой «люди без лиц» (`people_no_face_manual=1`) в «К разбору» попадают только те, у кого **нет** ни привязки по прямоугольникам, ни записи в `file_persons`; после назначения персоны (в т.ч. через file_persons) файл исчезает из «К разбору». Диагностика по конкретному файлу: `python backend/scripts/debug/debug_photo_assignments.py --path <подстрока пути> --pipeline-run-id <id>`.

## Регресс: списки путей + экспорт из БД

Регресс хранится в `regression/cases/*_gold.txt` (append-only, ничего не затираем).

Экспорт из БД по конкретному прогону:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe scripts/regression/export_cases_from_db.py --pipeline-run-id 10 --out-dir regression/cases
```

Проверка регресса:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe scripts/regression/run_regression_checks.py --cases-dir regression/cases --mode effective
```

### Gold: обновление из БД и перенос разметки в БД (append-only)

- Обновить gold-файлы из БД: `POST /api/gold/update-from-db`
- Заполнить ручную разметку в БД из gold (append-only: не перетирает уже размеченные записи): `POST /api/gold/apply-to-db`
- UI-страница для этого: `/gold?pipeline_run_id=...`

## Важно про DRY_RUN vs apply

- В режиме **DRY_RUN** файлы **не перемещаются** на диске, папки `_faces/_no_faces/_duplicates` могут не появиться.
- Для реального разложения/перемещения файлов нужен режим **apply** (не dry-run).

## Быстрый старт после перезагрузки

1) Перейти в папку проекта.

2) Убедиться, что порт свободен:

```bash
netstat -ano | findstr :8000
```

3) Запустить сервер:

```bash
# Перейти в корень проекта (замените на актуальный путь)
cd /path/to/PhotoSorter
C:\\Users\\mzaborov\\AppData\\Local\\Python\\pythoncore-3.14-64\\python.exe -m uvicorn --app-dir . app.main:app --port 8000
```

4) Открыть:
- `/folders` — таблица папок
- В колонке "Путь" есть ссылка **↗** на просмотр вложенных папок (`/browse?path=...`)

## Известные проблемы и решения

### Проблема с терминалом Cursor при выполнении Python

**Симптомы:**
- Выполнение команд Python в терминале Cursor может вызывать Connection Error
- Ломается текущий чат и все новые чаты (старые чаты продолжают работать)
- Проблема возникает в произвольный момент, воспроизведения нет

**Причина:**
- Конфликт Shell Integration Cursor с выводом Python команд
- Точная причина не выяснена, проблема нестабильна

**Решение:**
- Shell Integration отключена в `.vscode/settings.json` (`terminal.integrated.shellIntegration.enabled: false`)
- Это уменьшает частоту проблем, но не устраняет полностью

**Workaround при поломке терминала:**
1. Закрыть Cursor полностью
2. Удалить `%APPDATA%\Cursor\User\workspaceStorage\` (очистка битых настроек)
3. Запустить Cursor на чистую
4. Если работали над планом:
   - Стартовать нового агента
   - Попросить прочитать:
     - `.cursor/plans/` (все планы)
     - `docs/README.md`
     - Конкретный план (если был активен)
     - Правила из `.cursor/rules/`
   - Попросить продолжить план с отметкой прогресса

**Профилактика:**
- Все крупные изменения агентов выполняются только через планы (`.cursor/plans/`)
- Агент при выполнении отмечает прогресс в плане
- Python команды выполняются только из файлов (не inline), см. правило `.cursor/rules/python-run-only-from-files.mdc`

**Утилиты для диагностики:**
- `python backend/scripts/debug/diagnose_terminal_issue.py` — диагностика проблемы
- `python backend/scripts/debug/clean_terminal_settings.py --dry-run` — проверка битых настроек
- `python backend/scripts/debug/clean_terminal_settings.py` — очистка битых настроек терминала





