# PhotoSorter
Сортировщик фотографий на Яндекс Диске

## Цель проекта

**PhotoSorter** — автоматизировать разбор и наведение порядка в фото/видео на Яндекс.Диске: находить дубликаты по содержимому, определять категорию (люди/дети/семья/животные/без людей) и раскладывать по заранее заданным папкам в `disk:/Фото`, с управлением правилами через Web UI.

## Термины

- **Архив**: в рамках проекта под “архивом” понимается папка **`disk:/Фото`** на Яндекс.Диске.

## Целевые папки и порядок (disk:/Фото)

Порядок приоритета (сверху — раньше):

1) Без людей и животных (папка будет заведена отдельно, имя уточним)
2) Агата — `disk:/Фото/Агата`
3) Санек — `disk:/Фото/Санек`
4) Нюся — `disk:/Фото/Нюся`
5) Темка — `disk:/Фото/Темка`
6) Дети вместе — `disk:/Фото/Дети вместе`
7) Миша и Аня — `disk:/Фото/Миша и Аня`
8) Бабушки и Дедушки — `disk:/Фото/Бабушки и Дедушки`
9) Семья — `disk:/Фото/Семья`
10) Котэ и сцобако — `disk:/Фото/Котэ и сцобако`
11) Другие люди — `disk:/Фото/Другие люди`

Дополнительно в учёте/справочнике есть крупные папки: `disk:/Фото/Путешествия`, `disk:/Фото/Технологии`.

## Распознавание лиц

**Цель**

Сделать распознавание лиц (фото + видео) как основу для автоматизации сортировки “source → archive” и удобной ручной разметки. По UX близко к Tonfotos, но:
- с большим упором на **автоматизацию** (массовые действия, предложения, якорение),
- с поддержкой **видео**,
- с возможностью **быстро уточнять** результаты вручную.

**Термины**

- **Персона**: человек в справочнике (например “Агата”, “Санек”, “Михаил Заборов”).
- **Группа персон**: логическая группа (например “Семья”, “Дети”, “Синяя диагональ”). Персона может входить в несколько групп.
- **Лицо (face)**: найденная область на фото (bbox/прямоугольник).
- **Трек лица (face track)**: лицо на видео как последовательность bbox во времени + ключевой кадр для разметки.
- **presence_score / доля присутствия**: насколько “сильно” персона представлена в файле:
  - для **фото** — доля площади лица среди всех лиц в кадре: `area(face_bbox) / sum(area(all_face_bbox))` (если лицо одно — 100%),
  - для **видео** — доля времени/кадров, когда виден трек лица.

**Данные в БД (концептуально)**

Для каждого медиа-файла (фото/видео) хранится список найденных лиц/треков и атрибуты:
- **bbox / расположение** лица на фото (прямоугольник; для видео — на ключевом кадре и/или по треку),
- **presence_score** (см. выше),
- **AI предположение**: список кандидатов `[{персона, вероятность/score}]`,
- **ручное подтверждение**: кто это (персона), установленное пользователем,
- **ignore-флаги**:
  - игнорировать конкретное лицо/трек (ошибка детектора / не нужно),
  - режим персоны по приоритету разметки (см. ниже).

**Справочник персон**

Нужен редактируемый справочник людей, распознаваемых системой:
- аватар персоны (типично — лицо-кроп),
- принадлежность к группам (группы редактируемы, персона может быть в нескольких),
- отметка “это я” (Михаил Заборов),
- степень родства/близости по отношению ко мне (как атрибут персоны),
- агрегированные счётчики по статусам (минимум):
  - сколько лиц/файлов **подтверждено вручную**,
  - сколько **определено AI** (без ручного подтверждения),
  - сколько **требует решения** (inbox/unassigned),
  - сколько **игнорировано**.

**Особенности архива (реальность данных)**

Архивные папки не идеальны: внутри могут быть файлы без лиц или с нераспознаваемыми лицами, но смыслово относящиеся к персоне/папке:
- человек снят со спины/в профиль (узнаваем по контексту),
- фото документов/грамот/подарков/вещей, связанных с человеком.

Требование: такие файлы должны поддерживать **якорение (anchoring)**:
- закрепить файл за папкой (и/или персоной), чтобы автосортировка его не переносила.

**Требования к интерфейсу (UI)**

1) **Страница “Люди/Персоны”**
- клик по персоне → просмотр подтверждённых лиц/файлов, сгруппированных по папкам,
- быстрые действия: “нет, это другой человек”, “назначить другого”,
- назначение персоны для лица:
  - **Plan A (основной)**: выбрать из **AI‑предложений (top‑K)** прямо в карточке лица,
  - **Plan B (fallback)**: ручной выбор через справочник **группа → персона**.

2) **Отдельный режим “Лица без персоны” (Inbox / Unassigned)**

Цель: быстрый поток разметки “из неопределённого → в конкретных людей”, с упором на кластеризацию и массовые решения.

- **Что попадает в Inbox**:
  - лица/треки, у которых **нет `manual_person`**,
  - и они **не помечены ignore**,
  - (дополнительно) лица/треки с низкой уверенностью или конфликтующими кандидатами — как фильтры.
- **Кластеризация (основной режим)**:
  - группировка похожих лиц в кластеры,
  - массовые действия по кластеру: “это Артём”, “ignore”, “другой человек”, с возможностью исключить отдельные элементы (“всё Артём, кроме этой фотки”).
- **Карточка элемента**:
  - кроп лица/ключевой кадр, ссылка на исходный файл/папку, дата,
  - **AI top‑K кандидатов** (кнопками “это он”),
  - действия: назначить другого (fallback), ignore/не лицо.
- **Фильтры**:
  - по папке архива/источника,
  - по периоду (год/месяц),
  - отдельный фильтр/режим для “много лиц в файле”.

3) **Редактирование лиц на медиа**
- на фото: изменить bbox, нарисовать новый bbox, удалить ложный bbox,
- на видео: разметка через **ключевой кадр** трека (минимум на MVP).

4) **Страница папок архива**
- показывать аватары распознанных персон для папки,
- клик по аватару → файлы “папка + персона”,
- ручной перенос файла в другую папку с **якорением** в новой папке.

5) **Режим “предложи персону”**

Если система видит много похожих лиц:
- можно завести новую персону (“это …”),
- или назначить режим персоны по приоритету разметки:
  - **Активная**: важна, предлагать и просить разметку,
  - **Отложенная**: узнавать, но предлагать на разметку редко/в конце очереди,
  - **Никогда**: узнавать, но **не предлагать** на разметку (максимальная пессимизация).

**Логика для сортировки с учётом лиц**
- правила сортировки могут использовать **персоны и группы** (пример: “дети вместе”),
- `presence_score` может влиять на выбор папки (пример: если Нюся “мелькнула”, а основное лицо — Темка, не отправлять в “Дети вместе”).
- Семантика `только:[X]`: unknown-лица не мешают. `только:[X] = true`, если среди распознанных персон в кадре нет ни одного `Y != X` (даже если X встречается в кадре больше одного раза — зеркала/фото-на-фото).

**Самообучение от ручных правок**
- ручные назначения/исправления bbox должны улучшать качество последующих предложений (механизм уточним отдельно).

## Технологический стек (текущая реализация)

- **Сервер**: Python + **FastAPI** (ASGI)
- **ASGI-сервер**: **Uvicorn**
- **Шаблоны (SSR)**: **Jinja2** (`Jinja2Templates`)
- **Фронт**: серверный HTML (Jinja2) + **ванильный JS** (Fetch к `/api/...`) + встроенный CSS в шаблонах  
  (отдельной сборки/`package.json`/React/Vue сейчас нет)
- **БД**: **SQLite** (`data/photosorter.db`)
- **Интеграция с Я.Диском**: **yadisk** (API-клиент)
- **Конфиги/секреты**: `secrets.env` (основной) или `.env` (fallback) через **python-dotenv**  
  ⚠️ `secrets.env` и `data/photosorter.db` — локальные файлы, в git не коммитим.

## Структура репозитория и модули

```text
PhotoSorter/
  app/
    main.py                  # FastAPI-приложение: роуты страниц и API
    templates/               # Jinja2-шаблоны страниц (CSS/JS встроены в HTML)
      index.html
      folders.html
      browse.html
      duplicates.html
  DB/
    db.py                    # SQLite-схема + доступ к данным (folders, dedup, faces)
  data/
    photosorter.db           # Локальная SQLite БД (состояние/кэш)
    models/                  # Кэш моделей (например YuNet onnx для face-scan) (НЕ коммитить)
  docs/
    diagrams/                # Диаграммы сущностей (AS-IS / TO-BE) в PlantUML + PNG
      entities_as_is.puml
      entities_as_is.png
      entities_to_be.puml
      entities_to_be.png
  scripts/
    tools/                   # Утилиты (скан/дамп/загрузка папок в БД)
      face_scan.py           # MVP: скан лиц для YaDisk папки (пишет bbox/presence/thumbnail в SQLite)
    debug/                   # Отладочные скрипты для YaDisk/папок
    run_server.ps1           # “одной кнопкой” запустить uvicorn --reload
    run_face.ps1             # “одной кнопкой” запускать face-задачи через .venv-face (без activate)
    render_diagrams.py       # Генерация PNG из PlantUML через PlantUML server (для автодокументирования)
    render_diagrams.ps1      # Обёртка для render_diagrams.py
  yadisk_client.py           # Создание клиента YaDisk + загрузка токена из env
  requirements.txt           # Python-зависимости (фиксированные версии)
  requirements-face.txt      # Отдельные зависимости для .venv-face (Python 3.12) под распознавание лиц
  README.md
  TODO.md
  secrets.env                # Локальные секреты (НЕ коммитить)
```

**Ключевые модули**

- **`app/main.py`**: FastAPI `app`, HTML-страницы (`/`, `/folders`, `/browse`, `/duplicates`) и JSON API (`/api/...`), плюс вспомогательная логика (ретраи/таймауты YaDisk, превью-redirect, дедуп-сканы).
- **`app/templates/*.html`**: UI-страницы на Jinja2; стили и JS (fetch/рендер/прогресс) — инлайном.
- **`DB/db.py`**: инициализация схемы SQLite, чтение справочника папок (`list_folders`), и слой для дедупа (`DedupStore`: прогоны, инвентарь файлов, хэши, пометки deleted/ignore, reconcile).
- **`yadisk_client.py`**: загрузка `YADISK_ACCESS_TOKEN` из `secrets.env/.env` и создание `yadisk.YaDisk`.
- **`scripts/tools/*`**: разовые утилиты, например скан первых уровней `/Фото` в таблицу `folders`.
- **`scripts/debug/*`**: отладка проблемных путей/метаданных на Я.Диске.

## Точные правила сортировки

Обозначения:
- `только:[X]` — в кадре только X (и никаких других людей)
- `вместе:[A,B,C...]` — в кадре минимум двое из списка
- `содержит:[X,Y...]` — в кадре есть хотя бы один из списка

Правила применяются по порядку приоритета:

- Без людей и животных: если нет людей и нет кошек/собак → (отдельная ветка “без людей”)
- Агата: `только:[Агата]` → `disk:/Фото/Агата`
- Санек: `только:[Санек]` → `disk:/Фото/Санек`
- Нюся: `только:[Нюся]` → `disk:/Фото/Нюся`
- Темка: `только:[Темка]` → `disk:/Фото/Темка`
- Дети вместе: `вместе:[Агата, Санек, Нюся, Темка]` → `disk:/Фото/Дети вместе`
- Миша и Аня (широкое правило): `содержит:[Миша, Аня]` → `disk:/Фото/Миша и Аня`
- Бабушки и Дедушки: `содержит:[...список персон...]` → `disk:/Фото/Бабушки и Дедушки`
- Семья: `содержит:[...список персон...]` → `disk:/Фото/Семья`
- Котэ и сцобако: если есть кошка/собака → `disk:/Фото/Котэ и сцобако`
- Другие люди: если есть люди, но не сработало ничего выше → `disk:/Фото/Другие люди`

Правило “предыдущая папка по приоритету”: следующий этап выполняем только после завершения предыдущего (настраивается в правилах/БД).

## Что уже сделано

- Web UI (FastAPI): страницы `/`, `/folders`, `/browse`, `/duplicates`.
- SQLite-справочник папок (`folders`) + отображение в UI.
- Асинхронный рекурсивный подсчёт количества файлов по папкам в UI.
- API для подсчёта/отладки: `/api/folder-count/{code}`, `/api/path-count`, `/api/path-listing`, `/api/debug/build-info`.
- Стабилизация работы с Я.Диском: ретраи/таймауты, защита от циклов; увеличен таймаут YaDisk-вызовов до 60 секунд; исправлена нормализация путей (без `.strip()`).
- Дедупликация архива `disk:/Фото` (инвентаризация + хэши в SQLite) и страница `/duplicates` для просмотра групп дублей.
- Действия на `/duplicates`:
  - удаление “неотмеченных” копий в корзину,
  - “переместить в «Дети вместе» + удалить остальные” (с обработкой конфликтов имён),
  - открытие файла в веб-интерфейсе Я.Диска в режиме просмотра (slider).
- Превью дублей: `/api/yadisk/preview-image` отдаёт 307 redirect на YaDisk preview URL (без проксирования байтов через сервер).
- Исправление 403 на превью: `no-referrer` для картинок.
- Длительность видео: асинхронный `ffprobe` + кеш в SQLite (`yd_files.duration_sec`).
- Сверка архива (Reconcile Archive): кнопка на `/folders` и API, чтобы догонять ручные изменения на Я.Диске (перемещения/удаления/изменения).
- Основная “рабочая форма сортировки” на `/` (one-page):
  - выбор источника: Я.Диск (`disk:/...`, любая папка) или локальная папка (`C:\...`),
  - запуск скана источника и прогресс,
  - Шаг 1: дубли источника, которые уже есть в архиве `disk:/Фото` (удалить / “не дубль” до следующего перескана),
  - Шаг 2: дубли внутри источника (автовыбор “оставить 1”, кнопки “удалить копии” и “удалить всё (мусор)”),
  - превью для фото/видео (локальные видео — inline, видео на Я.Диске — открыть в slider), длительность локальных видео.

## Что планируется

- Модуль “источник → список объектов Photo” (фото+видео) с метаданными (дата/гео/тип).
- Схема БД для файлов, хэшей, статусов обработки, истории перемещений.
- Надёжная дедупликация по содержимому по всему Диску.
- Классификация людей/животных (Яндекс/локальная ML) и применение правил выше.
- Web UI для редактирования правил/приоритетов и контроля прогонов.

### Ближайшие шаги (план)

- Уточнить и стабилизировать UX “source → archive”: сообщения “архив не сканирован” vs “совпадений нет”, массовые действия и подтверждения.
- Распознавание лиц: хранение “персон”, эмбеддингов и результатов распознавания, страница для разметки/подтверждения и последующего применения правил раскладки.

## Проектировочные решения (Design Decisions)

- **DD-001 — API-first, без массового скачивания**: основная работа идёт через YaDisk API (листинг/метаданные/перемещения), чтобы не хранить всё локально; скачивание используется точечно (например, для хэша в DD-009).
- **DD-002 — Справочник папок и правил в SQLite**: конфигурация целевых папок/правил/приоритетов хранится в SQLite (`folders`) и используется Web UI.
- **DD-003 — Сортировка как цепочка приоритетов**: категории применяются строго по очереди (дети по одному → дети вместе → `содержит:[Миша, Аня]` → бабушки/дедушки → семья → животные → другие люди). Поддерживаем “следующий этап только после предыдущего”.
- **DD-004 — Устойчивость к проблемам API/путей**: используем ретраи/таймауты, защиту от циклов и диагностические эндпойнты. Таймаут YaDisk-вызовов увеличен до 60 секунд из‑за больших папок.
- **DD-005 — Web UI как инструмент контроля/отладки**: рекурсивные подсчёты загружаются асинхронно с прогрессом; есть drill-down просмотр папок (`/browse`) для поиска проблемных подпапок.
- **DD-006 — Секреты через `.env`/`secrets.env`**: токены/ключи не хардкодим, используем `secrets.env` (основной) и `.env` (fallback).
- **DD-007 — Минимум зависимостей и модульность**: ядро — Python + `yadisk`, `python-dotenv`, `sqlite3`; логика сортировки/доступ к Диску/БД разделяются по модулям.
- **DD-008 — Дедупликация по содержимому для фото и видео**: дедупликация применяется ко всем файлам (фото+видео), не только к изображениям.
- **DD-009 — Стратегия получения хэша (вариант B)**: если YaDisk не отдаёт `sha256/md5` в метаданных — скачиваем файл локально и считаем хэш сами; результат сохраняем в SQLite.
- **DD-010 — Сначала строим БД дублей, без действий на Диске**: первый шаг — только инвентаризация/группы дублей в БД; удаление/перемещения — позже через UI.
- **DD-011 — Разрешаем несколько KEEP**: в группе дублей можно оставить 1+ копий в разных папках, остальные помечаются на удаление.
- **DD-012 — Только “последний прогон”, без истории**: для каждого типа прогона храним только последнее состояние (можно запускать повторно — “resume по данным”, т.к. уже захешированные файлы не перехешируются).
- **DD-013 — Два scope для дедупликации**: `archive` (YaDisk `disk:/Фото`) и `source` (локальная папка-источник, например `C:\tmp\Photo`). Хэши складываем в одну общую таблицу, чтобы переиспользовать кэш.

## Web интерфейс (просмотр папок)

Установка зависимостей:

```bash
pip install -r requirements.txt
```

Запуск сервера (локально, рекомендуемый — без `--reload`):

```bash
uvicorn --app-dir . app.main:app --port 8000
```

Рекомендуемый режим разработки (Windows / PowerShell) — с авто‑reload:

```powershell
C:\Users\mzaborov\AppData\Local\Python\pythoncore-3.14-64\python.exe -m uvicorn --reload --app-dir . app.main:app --host 127.0.0.1 --port 8000
```

Проверка, что сервер “свежий” (после reload/рестарта):

```powershell
curl.exe -i --connect-timeout 1 --max-time 5 http://127.0.0.1:8000/api/debug/build-info
```

Ожидаем **HTTP 200** и совпадение заголовка **`x-photosorter-build`** с полем JSON **`build_id`**.

Открыть в браузере:
- `http://127.0.0.1:8000/` — основная форма сортировки (one-page)
- `http://127.0.0.1:8000/folders` — список папок (из SQLite)
- `http://127.0.0.1:8000/browse?path=disk:/Фото` — просмотр дерева папок
- `http://127.0.0.1:8000/duplicates` — просмотр дублей архива (архив= `disk:/Фото`)
- `http://127.0.0.1:8000/docs` — список API

## Быстрый старт после перезагрузки

1) Перейти в папку проекта.

2) Убедиться, что порт свободен:

```bash
netstat -ano | findstr :8000
```

3) Запустить сервер:

```bash
cd "C:\\Users\\mzaborov\\YandexDisk\\Работы, тексты, презентации\\PhotoSorter"
C:\\Users\\mzaborov\\AppData\\Local\\Python\\pythoncore-3.14-64\\python.exe -m uvicorn --app-dir . app.main:app --port 8000
```

4) Открыть:
- `/folders` — таблица папок
- В колонке "Путь" есть ссылка **↗** на просмотр вложенных папок (`/browse?path=...`)





