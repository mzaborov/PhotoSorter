---
name: backfill_taken_at_dates
overview: "Создание скрипта для заполнения пустых значений taken_at для всех фотографий и видео с использованием приоритетного порядка: EXIF → имя файла → системные атрибуты"
todos:
  - id: create_script
    content: Создать скрипт backend/scripts/tools/backfill_taken_at.py с базовой структурой и функциями main(), process_file()
    status: pending
  - id: parse_filename
    content: Реализовать функцию _parse_date_from_filename() для парсинга различных форматов дат из имен файлов
    status: pending
  - id: system_attrs
    content: Реализовать функцию _get_date_from_system_attrs() для получения даты из системных атрибутов (локальные и YaDisk)
    status: pending
  - id: exif_extraction
    content: Интегрировать извлечение даты из EXIF с поддержкой локальных и YaDisk файлов
    status: pending
  - id: main_logic
    content: "Реализовать основную логику обработки файлов с приоритетным порядком: EXIF → имя файла → системные атрибуты"
    status: pending
  - id: cli_args
    content: "Добавить аргументы командной строки: --dry-run, --limit, --scope"
    status: pending
  - id: error_handling
    content: Добавить обработку ошибок и статистику (обработано, обновлено, ошибки)
    status: pending
isProject: false
---

# План: Заполнение даты съемки (taken_at) для всех фотографий

## Цель

Создать скрипт `backend/scripts/tools/backfill_taken_at.py`, который заполнит пустые значения `taken_at` в таблице `files` для всех изображений и видео, используя приоритетный порядок определения даты.

## Приоритетный порядок определения даты

1. **EXIF** (только для изображений) - через `_try_exif_datetime_iso` из `local_sort.py`
2. **Имя файла** - парсинг различных форматов дат из имени файла
3. **Системные атрибуты** - `st_mtime` для локальных файлов, `modified` из метаданных для YaDisk

## Структура скрипта

### 1. Функция парсинга даты из имени файла

Создать функцию `_parse_date_from_filename(filename: str) -> str | None`, которая будет распознавать следующие форматы:

- `YYYYMMDD_HHMMSS` (например, `20231215_143022.jpg`)
- `YYYY-MM-DD_HH-MM-SS` (например, `2023-12-15_14-30-22.jpg`)
- `YYYYMMDD` (например, `20231215.jpg`)
- `IMG_YYYYMMDD_HHMMSS` (например, `IMG_20231215_143022.jpg`)
- `VID_YYYYMMDD_HHMMSS` (например, `VID_20231215_143022.mp4`)
- `YYYYMMDDHHMMSS` (например, `20231215143022.jpg`)
- Другие распространенные форматы

Возвращать дату в формате ISO: `YYYY-MM-DDTHH:MM:SSZ`

### 2. Функция получения даты из системных атрибутов

Создать функцию `_get_date_from_system_attrs(file_path: str, is_yadisk: bool, disk: yadisk.YaDisk | None = None) -> str | None`:

- Для локальных файлов (`local:`): использовать `os.stat().st_mtime`
- Для YaDisk файлов (`disk:`): использовать поле `modified` из метаданных БД или запросить через `disk.get_meta()`

### 3. Функция получения даты из EXIF

Использовать существующую `_try_exif_datetime_iso` из `backend/logic/pipeline/local_sort.py`:

- Для локальных файлов: открыть файл через PIL
- Для YaDisk файлов: скачать во временный файл, открыть через PIL, удалить временный файл

### 4. Основная функция обработки

Создать функцию `process_file(file_row: dict, dedup: DedupStore, disk: yadisk.YaDisk | None = None, dry_run: bool = False) -> tuple[bool, str | None]`:

- Принимает запись из БД с полями `path`, `name`, `media_type`, `modified`
- Определяет тип файла (локальный/YaDisk)
- Пытается получить дату в порядке приоритета: EXIF → имя файла → системные атрибуты
- Если `dry_run=False`, обновляет БД через `dedup.set_taken_at_and_gps()`
- Возвращает `(updated: bool, taken_at: str | None)`

### 5. Главная функция main()

- Получает все файлы с пустым `taken_at` из БД
- Фильтрует по `media_type IN ('image', 'video')`
- Обрабатывает файлы батчами (для прогресса)
- Выводит статистику: обработано, обновлено, ошибки
- Поддерживает аргументы командной строки:
- `--dry-run` - режим проверки без обновления БД
- `--limit N` - ограничение количества обрабатываемых файлов (для тестирования)
- `--scope local|yadisk|all` - фильтр по источнику файлов

## Файлы для изменения/создания

1. **Создать**: `backend/scripts/tools/backfill_taken_at.py`

- Импортировать необходимые модули: `DedupStore`, `get_disk`, `_try_exif_datetime_iso`
- Реализовать все функции выше
- Добавить обработку ошибок и логирование

2. **Использовать существующие функции**:

- `backend/common/db.py`: `DedupStore.set_taken_at_and_gps()`
- `backend/logic/pipeline/local_sort.py`: `_try_exif_datetime_iso()`
- `backend/common/yadisk_client.py`: `get_disk()`
- Утилиты для работы с путями: `_as_local_path`, `_normalize_yadisk_path`

## Особенности реализации

- Для YaDisk файлов: скачивать во временный файл только если нужно прочитать EXIF (изображения)
- Для видео: пропускать EXIF, сразу переходить к парсингу имени файла
- Обработка ошибок: продолжать обработку при ошибках отдельных файлов, собирать статистику ошибок
- Прогресс: выводить прогресс обработки (например, каждые 100 файлов)

## Тестирование

После создания скрипта:

1. Запустить с `--dry-run --limit 10` для проверки логики
2. Проверить корректность парсинга различных форматов дат из имен файлов
3. Проверить работу с локальными и YaDisk файлами
4. Запустить полный прогон с `--dry-run` для проверки всех файлов
5. Запустить без `--dry-run` для реального обновления БД