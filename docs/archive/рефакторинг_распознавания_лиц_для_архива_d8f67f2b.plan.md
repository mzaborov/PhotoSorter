---
name: Рефакторинг распознавания лиц для архива
overview: Разделяем логику для архива (текущий статус без истории прогонов) и сортируемых папок (с прогонами). Сохраняем существующие размеченные кластеры и привязки к персонам. Реализуем append-логику без дублирования для дополнения архива недостающими лицами.
todos: []
---

# Рефакторинг распознавания лиц для фотоархива

## Проблемы

1. **Все кластеры и лица привязаны к прогонам** — это правильно для сортируемых папок (`C:\tmp\photo`), но не для архива (`disk:/Фото`), где нужен текущий статус без истории
2. **Недостаточно лиц в архиве** — Артем отсутствует (папка Темка), Агата только 2 фото, Саня только детские фото, нет нескольких людей из семьи
3. **Ценные данные нужно сохранить** — размеченные кластеры (`face_labels`) и привязки к персонам (`face_cluster_members`)

## Решение

Используем подход, аналогичный `files.inventory_scope` ('archive'|'source'): для архива храним текущий статус без привязки к конкретным прогонам, для сортируемых папок оставляем логику прогонов.

### 1. Изменение схемы БД

**Файлы для изменения**: [`backend/common/db.py`](backend/common/db.py)

- Сделать `face_rectangles.run_id` опциональным (`INTEGER` вместо `INTEGER NOT NULL`)
- Добавить `face_rectangles.archive_scope` (`TEXT`) со значениями `NULL` (для прогонов) или `'archive'` (для архива)
- Для архивных лиц добавить UNIQUE constraint на `(file_path, bbox_x, bbox_y, bbox_w, bbox_h)` или использовать дедупликацию по `file_path` + `embedding` (если доступен)
- Сделать `face_clusters.run_id` опциональным, добавить `face_clusters.archive_scope` аналогично
- Для архивных кластеров использовать специальное значение или NULL вместо run_id

### 2. Миграция существующих данных

**Новый файл**: `backend/scripts/tools/migrate_archive_faces.py`

- Найти все `face_runs` с `scope='yadisk'` и `root_path` начинающимся с `disk:/Фото`
- Для каждого такого run_id:
- Переместить `face_rectangles` (установить `archive_scope='archive'`, `run_id=NULL` или специальное значение)
- Сохранить связи `face_cluster_members` → `face_rectangles`
- Мигрировать `face_clusters` (установить `archive_scope='archive'`, `run_id=NULL`)
- Сохранить `face_labels` (они привязаны к `face_rectangle_id`, останутся валидными)
- Дедупликация: если для одного `file_path` + `bbox` уже есть запись в архиве, не создавать дубликат

### 3. Обновление логики сканирования архива

**Файлы для изменения**:

- [`backend/scripts/tools/face_scan.py`](backend/scripts/tools/face_scan.py)
- [`backend/common/db.py`](backend/common/db.py) — метод `insert_detection`

- В `face_scan.py` для архивных путей (`disk:/Фото/...`):
- Не создавать `face_runs` для архива (или создавать только для статистики, без использования)
- Использовать `archive_scope='archive'` при вставке `face_rectangles`
- Перед вставкой проверять существование по `file_path` + `bbox` (или `embedding`), если есть — пропускать (append без дублирования)
- Обновить `FaceStore.insert_detection()` для поддержки `archive_scope` и опционального `run_id`
- Добавить метод `FaceStore.insert_archive_detection()` или параметр `archive_scope` в существующий метод

### 4. Обновление логики кластеризации

**Файл для изменения**: [`backend/logic/face_recognition.py`](backend/logic/face_recognition.py)

- Обновить `cluster_face_embeddings()` для работы с архивными лицами:
- Вместо `run_id` использовать фильтр `archive_scope='archive'` для архива
- Сохранить обратную совместимость с `run_id` для сортируемых папок
- При создании кластеров для архива устанавливать `archive_scope='archive'`, `run_id=NULL`

### 5. Обновление UI и API

**Файлы для изменения**:

- [`backend/web_api/routers/face_clusters.py`](backend/web_api/routers/face_clusters.py)
- [`backend/web_api/routers/faces.py`](backend/web_api/routers/faces.py)

- Обновить запросы к БД: фильтровать по `archive_scope='archive'` для архива вместо `run_id`
- Сохранить обратную совместимость: если `run_id` указан, использовать его (для сортируемых папок)

### 6. Дополнение архива недостающими лицами

**Файл для изменения**: [`backend/scripts/tools/face_scan_archive.py`](backend/scripts/tools/face_scan_archive.py)

- Обновить скрипт для использования новой логики архива (без создания `face_runs`)
- Запустить пересканирование папок:
- `disk:/Фото/Темка` (Артем)
- `disk:/Фото/Агата` (дополнить до полного покрытия)
- `disk:/Фото/Саня` (включая недетские фото, если есть)
- Другие папки с людьми из семьи

### 7. Обновление диаграмм

**Файлы для изменения**:

- [`docs/diagrams/entities_as_is.puml`](docs/diagrams/entities_as_is.puml)
- [`docs/diagrams/entities_to_be.puml`](docs/diagrams/entities_to_be.puml)

- Отразить опциональность `run_id` для архивных данных
- Добавить `archive_scope` в схему `face_rectangles` и `face_clusters`

## Порядок выполнения

1. **Изменение схемы БД** (добавить колонки, сделать run_id опциональным)
2. **Миграция данных** (перенести существующие лица/кластеры архива в новый формат)
3. **Обновление логики вставки** (append без дублирования для архива)
4. **Обновление логики кластеризации** (работа с архивом без run_id)
5. **Обновление UI/API** (фильтрация по archive_scope)
6. **Пересканирование архива** (дополнить недостающими лицами)
7. **Обновление диаграмм**

## Критические моменты

- **Сохранить все `face_labels`** — они привязаны к `face_rectangle_id`, останутся валидными после миграции
- **Сохранить `face_cluster_members`** — проверить целостность после миграции `face_rectangles`
- **Дедупликация** — избежать дублей при append (по `file_path` + `bbox` или `embedding`)
- **Обратная совместимость** — сортируемые папки продолжают работать с `run_id`