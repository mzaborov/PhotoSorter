<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <!-- YaDisk preview hotlink защита: просим браузер не слать Referer при загрузке картинок -->
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Результаты лиц</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1400px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .inp { border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-weight:700; width: 110px; }
      .inp:focus { outline: 2px solid rgba(59,130,246,0.35); outline-offset: 1px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.danger { border-color:#fecaca; background:#fff5f5; color:#991b1b; }
      .btn.danger:hover { background:#ffecec; }
      /* Compact buttons inside cards: 2 per row */
      .actions .btn {
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 12px;
        line-height: 1.1;
        flex: 1 1 calc(50% - 8px);
        min-width: 0;
      }
      .actions { display:flex; gap:8px; align-items:center; margin-top: 10px; flex-wrap: wrap; }
      .tabs { display:flex; gap:8px; margin-top: 14px; }
      .tab { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:999px; cursor:pointer; font-weight:700; }
      .tab.active { background:#111827; color:#fff; border-color:#111827; }
      .subtabs { display:flex; gap:8px; margin-top: 10px; }
      .subtab { appearance:none; border:1px solid #e5e7eb; background:#fff; padding:6px 10px; border-radius:999px; cursor:pointer; font-weight:700; font-size: 12px; color:#111827; }
      .subtab.active { background:#eef2ff; border-color:#c7d2fe; }
      .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 12px; }
      .grid { display:flex; gap:10px; flex-wrap:wrap; margin-top: 14px; }
      .card { width: 240px; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; background:#fff; }
      .thumb { height: 140px; background:#fff; display:flex; align-items:center; justify-content:center; position:relative; cursor: zoom-in; }
      .thumb img { width: 100%; height: 100%; object-fit: contain; display:block; background:#fff; }
      .thumb video { width: 100%; height: 100%; object-fit: contain; display:block; background:#111827; }
      .vfbtn {
        position: absolute;
        right: 8px;
        top: 8px;
        z-index: 5;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.55);
        background: rgba(17,24,39,0.72);
        color: #fff;
        font-size: 12px;
        font-weight: 800;
        cursor: pointer;
        user-select: none;
      }
      .vfbtn:hover { background: rgba(17,24,39,0.85); }
      .thumb .noimg { color:#6b7280; font-size:12px; padding:10px; text-align:center; }
      .card-body { padding: 10px 10px 12px 10px; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; font-size:12px; color:#374151; }
      .path { font-size: 12px; word-break: break-all; }
      /* .actions updated above */
      /* Вариант A: "мимо gold" — делаем заметно */
      .card.past-gold {
        background: #ffe4e6;         /* rose-200 */
        border-color: #fb7185;       /* rose-400 */
        box-shadow: 0 0 0 2px rgba(244, 63, 94, 0.35); /* rose-500 ring */
      }

      /* Modal viewer + drawing */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(1200px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-top code { font-size: 11px; }
      .lb-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .lb-tabs { display:flex; gap:8px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; background:#f9fafb; flex-wrap:wrap; }
      .lb-tab { appearance:none; border:1px solid #e5e7eb; background:#fff; padding:6px 10px; border-radius:999px; cursor:pointer; font-weight:800; font-size: 12px; color:#111827; }
      .lb-tab.active { background:#eef2ff; border-color:#c7d2fe; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; padding: 10px; }
      .imgwrap { position: relative; display: inline-block; }
      .imgwrap img { max-width: 92vw; max-height: calc(92vh - 130px); width: auto; height: auto; display: block; background: #111827; }
      .imgwrap video { max-width: 92vw; max-height: calc(92vh - 130px); width: auto; height: auto; display: block; background: #111827; }
      .imgwrap canvas { position: absolute; left: 0; top: 0; pointer-events: auto; }
      .lb-rectangle-label { 
        position: absolute; 
        background: rgba(250, 204, 21, 0.95); 
        color: #111827; 
        padding: 3px 8px; 
        font-size: 12px; 
        font-weight: 700; 
        border-radius: 4px; 
        white-space: nowrap; 
        z-index: 10001; 
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(250, 204, 21, 1);
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        pointer-events: none;
      }
      .lb-rectangle-label.manual {
        background: rgba(59, 130, 246, 0.95);
        color: #fff;
        border-color: rgba(59, 130, 246, 1);
      }
      .lb-bottom { padding: 10px 12px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
      .rectlist { display:flex; gap:8px; flex-wrap:wrap; }
      .rectpill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#1f2937; font-size:12px; }
      .draw-on { cursor: crosshair; }

      /* Sticky header (всё, что на верхнем блоке со вкладками/кнопками) */
      .sticky-top {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(255,255,255,0.98);
        backdrop-filter: blur(6px);
        border-bottom: 1px solid #e5e7eb;
        padding-bottom: 12px;
        margin-bottom: 14px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="sticky-top" id="stickyTop">
        <div class="header">
          <div>
            <h2 style="margin:0;">Результаты “лица / нет лиц” (шаг 2)</h2>
            <div class="muted" style="margin-top:6px;">Двойной клик по превью — показать прямоугольники лиц. В “Нет лиц” можно разметить лица вручную.</div>
          </div>
          <div class="muted"><a href="/">← на главную</a></div>
        </div>

        <div class="toolbar">
          <span class="pill">pipeline_run_id: <b id="prId">—</b></span>
          <span class="pill">face_run_id: <b id="frId">—</b></span>
          <span class="pill">root: <code id="rootPath">—</code></span>
          <span class="muted" id="toast"></span>
        </div>

        <div class="tabs">
          <button class="tab active" id="tabFaces" type="button">Люди</button>
          <button class="tab" id="tabQuarantine" type="button" style="display:none;">Карантин</button>
          <button class="tab" id="tabAnimals" type="button">Животные</button>
          <button class="tab" id="tabPeopleNoFace" type="button" style="display:none;">Есть люди (без лиц)</button>
          <button class="tab" id="tabNoFaces" type="button">Нет людей</button>
        </div>

        <!-- 2-й уровень: подзакладки для "Люди" -->
        <div class="subtabs" id="subtabsFaces" style="display:none;">
          <button class="subtab active" id="subFacesUnsorted" type="button">К разбору</button>
          <button class="subtab" id="subFacesMany" type="button">Много лиц</button>
          <!-- Динамические подзакладки по персонам будут добавлены через JS -->
        </div>
        
        <!-- 2-й уровень: подзакладки для "Нет людей" -->
        <div class="subtabs" id="subtabsNoFaces" style="display:none;">
          <button class="subtab active" id="subNoFacesUnsortedPhotos" type="button">Фото к разбору</button>
          <button class="subtab" id="subNoFacesUnsortedVideos" type="button">Видео к разбору</button>
          <!-- Динамические подзакладки по группам будут добавлены через JS -->
        </div>

        <div class="toolbar">
          <button class="btn" id="btnPrev" type="button">←</button>
          <span class="pill">страница: <b id="page">1</b></span>
          <button class="btn" id="btnNext" type="button">→</button>
          <span class="pill">всего: <b id="total">—</b></span>
          <button class="btn" id="btnReload" type="button">Обновить</button>
          <button class="btn" id="btnUndo" type="button" style="display:none;" title="Undo: отменить последнее действие (поддерживается несколько последних действий).">Undo</button>
          <button class="btn" id="btnSortIntoFolders" type="button" title="Переместить файлы в папки по категориям: _non_media, _broken_media, _faces, _quarantine, _animals, _people_no_face, _no_faces">Переместить файлы в папки</button>
        </div>

        <div class="toolbar">
          <span class="pill" id="posPill">позиция: —</span>
          <span class="muted">строка:</span>
          <input class="inp" id="jumpRow" type="number" inputmode="numeric" min="1" step="1" placeholder="№" />
          <button class="btn" id="btnJump" type="button">Перейти</button>
          <span class="muted" id="jumpHint"></span>
        </div>

      </div>

      <div class="grid" id="grid"></div>
    </div>

    <div class="lb" id="lightbox" aria-hidden="true">
      <div class="lb-panel" role="dialog" aria-modal="true">
        <div class="lb-top">
          <code id="lbPath">—</code>
          <div class="lb-actions">
            <span class="pill" id="lbMode">просмотр</span>
            <button class="btn" id="lbAnnotate" type="button" style="display:none;">Разметить</button>
            <button class="btn" id="lbClear" type="button" style="display:none;">Очистить</button>
            <button class="btn" id="lbSave" type="button" style="display:none;">Сохранить</button>
            <button class="btn" id="lbClose" type="button">Закрыть</button>
          </div>
        </div>
        <div class="lb-tabs" id="lbTabs" style="display:none;">
          <button class="lb-tab" id="lbTabVideo" type="button">Видео</button>
          <button class="lb-tab" id="lbTabF1" type="button">Кадр 1</button>
          <button class="lb-tab" id="lbTabF2" type="button">Кадр 2</button>
          <button class="lb-tab" id="lbTabF3" type="button">Кадр 3</button>
        </div>
        <div class="lb-body">
          <div class="imgwrap" id="imgWrap">
            <img id="lbImg" alt="preview" />
            <video id="lbVideo" controls preload="metadata" style="display:none;"></video>
            <canvas id="lbCanvas"></canvas>
          </div>
        </div>
        <div class="lb-bottom">
          <div class="muted">Прямоугольники:</div>
          <div class="rectlist" id="rectList"></div>
          <div style="margin-top:8px; font-size:11px; color:#6b7280;">
            Двойной клик по прямоугольнику — назначить персону
          </div>
        </div>
      </div>
    </div>

    <!-- Модальное окно для выбора персоны -->
    <div class="lb" id="modalPerson" style="display:none;" aria-hidden="true">
      <div class="lb-panel" role="dialog" aria-modal="true" style="max-width: 500px;">
        <div class="lb-top">
          <div style="font-weight:700;">Назначить персону</div>
          <button class="btn" type="button" onclick="closePersonModal()" style="padding:4px 8px;">✕</button>
        </div>
        <div style="padding: 16px;">
          <div style="margin-bottom:12px; display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="checkboxMultiplePersons" style="width:18px; height:18px; cursor:pointer;" />
            <label for="checkboxMultiplePersons" style="font-weight:700; cursor:pointer;">Персона не одна (выбрать несколько)</label>
          </div>
          
          <!-- Режим одной персоны -->
          <div id="singlePersonMode" style="margin-top:12px;">
            <div style="margin-bottom:12px; font-weight:700;">Выберите персону:</div>
            <select id="selectPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:16px;">
              <option value="">Выберите персону...</option>
            </select>
            <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
              <div style="margin-bottom:8px; font-weight:700;">Или создайте новую:</div>
              <input type="text" id="inputNewPersonName" placeholder="Имя персоны" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:8px;" />
            </div>
          </div>
          
          <!-- Режим нескольких персон -->
          <div id="multiplePersonsMode" style="margin-top:12px; display:none;">
            <div style="margin-bottom:12px; font-weight:700;">Выберите персон (можно несколько):</div>
            <div id="personsCheckboxList" style="max-height:300px; overflow-y:auto; border:1px solid #d1d5db; border-radius:10px; padding:8px; background:#f9fafb;">
              <!-- Список персон с чекбоксами будет добавлен через JS -->
            </div>
            <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
              <div style="margin-bottom:8px; font-weight:700;">Или создайте новую:</div>
              <input type="text" id="inputNewPersonNameMultiple" placeholder="Имя персоны" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:8px;" />
            </div>
          </div>
          
          <button class="btn" type="button" onclick="assignSelectedPerson()" style="width:100%; margin-top:16px;">Назначить</button>
        </div>
        <div class="lb-bottom" style="justify-content:flex-end;">
          <button class="btn" type="button" onclick="closePersonModal()">Отмена</button>
        </div>
      </div>
    </div>

    <!-- Модальное окно для выбора группы -->
    <div class="lb" id="modalGroup" style="display:none;" aria-hidden="true">
      <div class="lb-panel" role="dialog" aria-modal="true" style="max-width: 400px;">
        <div class="lb-top">
          <div style="font-weight:700;">Назначить группу</div>
          <button class="btn" type="button" onclick="closeGroupModal()" style="padding:4px 8px;">✕</button>
        </div>
        <div style="padding: 16px;">
          <div style="margin-bottom:12px; font-weight:700;">Выберите группу:</div>
          <select id="selectGroup" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:16px;">
            <option value="">Выберите группу...</option>
          </select>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <div style="margin-bottom:8px; font-weight:700;">Или создайте новую:</div>
            <input type="text" id="inputNewGroupPath" placeholder="Например: Поездки\\2025 Италия" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:8px;" />
            <button class="btn" type="button" onclick="assignSelectedGroup()" style="width:100%;">Назначить</button>
          </div>
        </div>
        <div class="lb-bottom" style="justify-content:flex-end;">
          <button class="btn" type="button" onclick="closeGroupModal()">Отмена</button>
        </div>
      </div>
    </div>

    <script>
      // Глобальная обработка ошибок для предотвращения перезагрузки страницы
      window.addEventListener("error", (event) => {
        console.error("[global-error]", event.error || event.message, event.filename, event.lineno);
        event.preventDefault(); // Предотвращаем стандартную обработку ошибки
        return true; // Сообщаем, что ошибка обработана
      });
      window.addEventListener("unhandledrejection", (event) => {
        console.error("[unhandled-rejection]", event.reason);
        event.preventDefault(); // Предотвращаем вывод в консоль по умолчанию
      });
      
      function qs(sel, el=document) { return el.querySelector(sel); }
      function qsa(sel, el=document) { return Array.from(el.querySelectorAll(sel)); }
      function escapeHtml(s) {
        return (s ?? "").toString()
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#039;");
      }
      async function fetchJson(url, opts={}) {
        const r = await fetch(url, { cache:"no-store", ...opts });
        const t = await r.text();
        let j = null;
        try { j = t ? JSON.parse(t) : null; } catch (e) { j = null; }
        if (!r.ok) throw new Error((j && (j.detail || j.error)) ? (j.detail || j.error) : (t || `HTTP ${r.status}`));
        return j;
      }
      async function postJson(url, payload) {
        return await fetchJson(url, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload ?? {}) });
      }
      function setToast(msg, isErr=false) {
        const el = qs("#toast");
        el.textContent = msg || "";
        el.style.color = isErr ? "#991b1b" : "#6b7280";
      }
      function getParam(name) {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      }

      let pipelineRunId = null;
      let tab = "faces";
      let subtab = "unsorted"; // 2-й уровень: "unsorted" (К разбору), "unsorted_photos" (Фото к разбору), "unsorted_videos" (Видео к разбору), "many_faces" (Много лиц), "person_<id>" (по персонам), "group_<path>" (по группам)
      let page = 1;
      const pageSize = 60;
      let loading = false;
      let hasMore = true;
      let totalCount = null;
      let loadedCount = 0;
      let jumpTargetRow = null; // 1-based

      // no_faces filters
      let nfFrom = null; // 'YYYY-MM-DD' or null
      let nfTo = null;
      const nfSort = "place_date";

      // visible-range tracking (for "где я?")
      const visibleRows = new Set();
      let _posRaf = 0;
      function _posScheduleUpdate() {
        if (_posRaf) return;
        _posRaf = requestAnimationFrame(() => {
          _posRaf = 0;
          updatePositionPill();
        });
      }
      function _asInt(v) {
        const n = Number(v);
        return Number.isFinite(n) ? Math.trunc(n) : null;
      }
      function _cards() { return qsa("#grid .card[data-row]"); }
      function updatePositionPill() {
        const el = qs("#posPill");
        if (!el) return;
        const tot = (typeof totalCount === "number") ? totalCount : null;
        if (!visibleRows.size) {
          el.textContent = "позиция: —";
          return;
        }
        const sorted = Array.from(visibleRows).sort((a,b) => a-b);
        const first = sorted[0];
        const last = sorted[sorted.length - 1];
        const top = Math.max(0, first - 1);
        const bottom = (tot != null) ? Math.max(0, tot - last) : null;
        el.textContent = `позиция: ${first}–${last}` + (tot != null ? ` из ${tot}; сверху ${top}; снизу ${bottom}` : `; сверху ${top}`);
      }
      const cardIo = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          const el = e.target;
          const row = _asInt(el?.getAttribute?.("data-row"));
          if (!row) return;
          if (e.isIntersecting) visibleRows.add(row);
          else visibleRows.delete(row);
        });
        _posScheduleUpdate();
      }, { root: null, threshold: 0.1 });

      function observeNewCards() {
        // Ограничиваем количество одновременно наблюдаемых элементов для производительности
        const maxObserved = 150; // максимум 150 элементов в IntersectionObserver (уменьшено)
        const cards = _cards();
        const unobserved = cards.filter(el => el.getAttribute("data-observed") !== "1");
        // Берем только последние элементы (те, что видимы или недавно добавлены)
        const toObserve = unobserved.slice(-maxObserved);
        toObserve.forEach(el => {
          el.setAttribute("data-observed", "1");
          try { cardIo.observe(el); } catch (e) {
            console.warn("[observeNewCards] Ошибка наблюдения за элементом:", e);
          }
        });
        // Если элементов слишком много, прекращаем наблюдение за старыми
        if (cards.length > maxObserved) {
          const oldCards = cards.slice(0, cards.length - maxObserved);
          oldCards.forEach(el => {
            try { cardIo.unobserve(el); } catch (e) {}
            el.removeAttribute("data-observed");
          });
        }
      }

      function removeCardByPath(path) {
        const p = (path || "").toString();
        if (!p) return false;
        const cards = qsa("#grid .card");
        const card = cards.find(c => (c.getAttribute("data-path") || "") === p);
        if (!card) return false;
        const row = _asInt(card.getAttribute("data-row"));
        try { cardIo.unobserve(card); } catch (e) {}
        if (row) visibleRows.delete(row);
        card.remove();
        _posScheduleUpdate();
        return true;
      }

      // init tab/subtab from query (до первого load)
      tab = (getParam("tab") || tab || "faces").toString().trim().toLowerCase() || "faces";
      // Карантин теперь показывается в "Нет людей"
      if (tab === "quarantine") tab = "no_faces";
      if (!["faces","animals","people_no_face","no_faces"].includes(tab)) tab = "faces";
      subtab = (getParam("subtab") || subtab || "unsorted").toString().trim().toLowerCase() || "unsorted";
      // Поддерживаем старый формат "all" для совместимости
      if (subtab === "all") subtab = "unsorted";
      if (tab === "no_faces" && (subtab === "unsorted" || subtab === "all")) {
        subtab = "unsorted_photos"; // По умолчанию "Фото к разбору" для "Нет людей"
      }
      if (tab === "faces") {
        if (!["unsorted","many_faces"].includes(subtab) && !subtab.startsWith("person_")) {
          subtab = "unsorted";
        }
      } else if (tab === "no_faces") {
        if (!["unsorted_photos", "unsorted_videos"].includes(subtab) && !subtab.startsWith("group_")) {
          subtab = "unsorted_photos";
        }
      } else {
        subtab = "unsorted";
      }

      // no_faces filters removed - сортировка по place_date работает автоматически

      function updateUrlParams() {
        const u = new URL(window.location.href);
        u.searchParams.set("tab", tab);
        if ((tab === "faces" || tab === "no_faces") && subtab && subtab !== "unsorted") {
          u.searchParams.set("subtab", subtab);
        } else {
          u.searchParams.delete("subtab");
        }
        if (tab === "no_faces") {
          u.searchParams.set("sort", nfSort);
        } else {
          u.searchParams.delete("sort");
        }
        window.history.replaceState({}, "", u.toString());
      }

      function updateSubtabsVisibility() {
        // Подзакладки для "Люди"
        const rowFaces = qs("#subtabsFaces");
        if (rowFaces) {
          rowFaces.style.display = (tab === "faces") ? "flex" : "none";
          const bUnsorted = qs("#subFacesUnsorted");
          const bMany = qs("#subFacesMany");
          if (bUnsorted) bUnsorted.classList.toggle("active", tab === "faces" && (subtab === "unsorted" || subtab === "all"));
          if (bMany) bMany.classList.toggle("active", tab === "faces" && subtab === "many_faces");
          
          // Обновляем активность подзакладок персон
          const personSubtabs = rowFaces.querySelectorAll('[data-person-id]');
          personSubtabs.forEach(btn => {
            const pid = btn.getAttribute('data-person-id');
            const isActive = tab === "faces" && subtab === `person_${pid}`;
            btn.classList.toggle("active", isActive);
          });
        }
        
        // Подзакладки для "Нет людей"
        const rowNoFaces = qs("#subtabsNoFaces");
        if (rowNoFaces) {
          rowNoFaces.style.display = (tab === "no_faces") ? "flex" : "none";
          const bUnsortedNoFacesPhotos = qs("#subNoFacesUnsortedPhotos");
          if (bUnsortedNoFacesPhotos) bUnsortedNoFacesPhotos.classList.toggle("active", tab === "no_faces" && subtab === "unsorted_photos");
          const bUnsortedNoFacesVideos = qs("#subNoFacesUnsortedVideos");
          if (bUnsortedNoFacesVideos) bUnsortedNoFacesVideos.classList.toggle("active", tab === "no_faces" && subtab === "unsorted_videos");
          
          // Обновляем активность подзакладок групп
          const groupSubtabs = rowNoFaces.querySelectorAll('[data-group-path]');
          groupSubtabs.forEach(btn => {
            const gpath = btn.getAttribute('data-group-path');
            const isActive = tab === "no_faces" && subtab === `group_${encodeURIComponent(gpath)}`;
            btn.classList.toggle("active", isActive);
          });
        }
      }
      
      // Кэш для данных о персонах
      let cachedPersonsData = null;
      let cachedPersonsTimestamp = 0;
      const PERSONS_CACHE_TTL = 10000; // 10 секунд
      
      function invalidatePersonsCache() {
        cachedPersonsData = null;
        cachedPersonsTimestamp = 0;
        personsSubtabsLoaded = false; // Сбрасываем флаг, чтобы список перезагрузился при следующем вызове
      }
      
      async function fetchPersonsWithFiles() {
        const now = Date.now();
        // Используем кэш, если данные свежие
        if (cachedPersonsData && (now - cachedPersonsTimestamp) < PERSONS_CACHE_TTL) {
          return cachedPersonsData;
        }
        
        const data = await fetchJson(`/api/faces/persons-with-files?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
        cachedPersonsData = data;
        cachedPersonsTimestamp = now;
        return data;
      }
      
      // Флаг для отслеживания, был ли список подзакладок персон уже загружен
      let personsSubtabsLoaded = false;
      
      async function loadPersonsSubtabs(force = false) {
        if (!pipelineRunId || tab !== "faces") return;
        
        // Если список уже загружен и кэш актуален, и не требуется принудительная перезагрузка - пропускаем
        if (!force && personsSubtabsLoaded && cachedPersonsData && (Date.now() - cachedPersonsTimestamp) < PERSONS_CACHE_TTL) {
          console.log("[loadPersonsSubtabs] Список уже загружен, пропускаем");
          return;
        }
        
        const startTime = performance.now();
        console.log("[loadPersonsSubtabs] Начало загрузки списка подзакладок персон");
        
        // Показываем индикатор загрузки
        const row = qs("#subtabsFaces");
        if (!row) return;
        const loadingIndicator = document.createElement("span");
        loadingIndicator.className = "muted";
        loadingIndicator.textContent = "Загрузка персон...";
        loadingIndicator.id = "personsLoading";
        // Удаляем старый индикатор, если есть
        const oldIndicator = row.querySelector("#personsLoading");
        if (oldIndicator) oldIndicator.remove();
        row.appendChild(loadingIndicator);
        
        try {
          const fetchStartTime = performance.now();
          const data = await fetchPersonsWithFiles();
          const fetchTime = performance.now() - fetchStartTime;
          console.log(`[loadPersonsSubtabs] API запрос занял: ${fetchTime.toFixed(2)}ms`);
          
          const persons = data?.persons || [];
          
          // Удаляем индикатор загрузки
          const indicator = row.querySelector("#personsLoading");
          if (indicator) indicator.remove();
          
          // Отмечаем, что список загружен
          personsSubtabsLoaded = true;
          
          // Сохраняем имена персон в глобальную переменную для использования в cardHtml
          if (!window.currentPersonName) {
            window.currentPersonName = {};
          }
          persons.forEach(person => {
            window.currentPersonName[person.id] = person.name || `Персона ${person.id}`;
          });
          
          // Удаляем старые подзакладки персон (кроме "К разбору" и "Много лиц")
          const existingPersonBtns = row.querySelectorAll('[data-person-id]');
          existingPersonBtns.forEach(btn => btn.remove());
          
          // Добавляем подзакладки для каждой персоны
          persons.forEach(person => {
            const btn = document.createElement("button");
            btn.className = "subtab";
            btn.id = `subPerson_${person.id}`;
            btn.setAttribute("data-person-id", String(person.id));
            btn.type = "button";
            btn.textContent = `${person.name || `Персона ${person.id}`} (${person.files_count || 0})`;
            btn.onclick = () => setSubtab(`person_${person.id}`);
            row.appendChild(btn);
          });
          
          updateSubtabsVisibility();
          
          const totalTime = performance.now() - startTime;
          console.log(`[loadPersonsSubtabs] Загрузка списка подзакладок завершена за ${totalTime.toFixed(2)}ms, персон: ${persons.length}`);
        } catch (e) {
          console.error("Ошибка загрузки подзакладок персон:", e);
          // Удаляем индикатор загрузки при ошибке
          const indicator = row.querySelector("#personsLoading");
          if (indicator) indicator.remove();
          const totalTime = performance.now() - startTime;
          console.log(`[loadPersonsSubtabs] Ошибка после ${totalTime.toFixed(2)}ms`);
        }
      }
      
      async function loadGroupsSubtabs() {
        if (!pipelineRunId || tab !== "no_faces") return;
        try {
          const data = await fetchJson(`/api/faces/groups-with-files?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
          const groups = data?.groups || [];
          const row = qs("#subtabsNoFaces");
          if (!row) return;
          
          // Удаляем старые подзакладки групп (кроме "К разбору")
          const existingGroupBtns = row.querySelectorAll('[data-group-path]');
          existingGroupBtns.forEach(btn => btn.remove());
          
          // Сортируем группы: сначала поездки (по дате добавления - последние выше), потом остальные по алфавиту
          const sortedGroups = [...groups].sort((a, b) => {
            const nameA = (a.group_path || "").toLowerCase();
            const nameB = (b.group_path || "").toLowerCase();
            
            // Проверяем, является ли группа поездкой (начинается с года)
            const isTripA = /^\d{3,4}/.test(nameA);
            const isTripB = /^\d{3,4}/.test(nameB);
            
            if (isTripA && isTripB) {
              // Обе поездки - сортируем по дате добавления (последние выше)
              const dateA = a.last_created_at || "";
              const dateB = b.last_created_at || "";
              if (dateA && dateB) {
                const dateCompare = dateB.localeCompare(dateA); // Новые выше (по убыванию)
                if (dateCompare !== 0) return dateCompare;
              }
              // Если даты одинаковые или отсутствуют, сортируем по алфавиту
              return nameA.localeCompare(nameB);
            } else if (isTripA) {
              return -1; // Поездки в начале
            } else if (isTripB) {
              return 1;
            } else {
              // Обе не поездки - сортируем по алфавиту
              return nameA.localeCompare(nameB);
            }
          });
          
          // Добавляем подзакладки для каждой группы
          sortedGroups.forEach(group => {
            const btn = document.createElement("button");
            btn.className = "subtab";
            btn.id = `subGroup_${encodeURIComponent(group.group_path)}`;
            btn.setAttribute("data-group-path", String(group.group_path));
            btn.type = "button";
            btn.textContent = `${group.group_path || `Группа ${group.id}`} (${group.files_count || 0})`;
            btn.onclick = () => setSubtab(`group_${encodeURIComponent(group.group_path)}`);
            row.appendChild(btn);
          });
          
          updateSubtabsVisibility();
          
          // НЕ обновляем выпадашки здесь - они будут обновлены в load() после рендеринга карточек
        } catch (e) {
          console.error("Ошибка загрузки подзакладок групп:", e);
        }
      }
      
      async function updateGroupSelects(groups) {
        console.log("[updateGroupSelects] Начинаем обновление выпадашек, групп:", groups.length);
        
        // Предопределенные группы, которые должны быть доступны для выбора (даже если их нет в БД)
        // Это шаблоны для быстрого создания групп
        const predefinedGroups = [
          "Здоровье",
          "Чеки",
          "Дом и ремонт",
          "Артефакты людей"
        ];
        
        // Определяем группы поездок динамически: группы, которые содержат год и название места
        const tripsKeywords = ["Турция", "Минск", "Италия", "Испания", "Греция", "Франция", "Польша", "Чехия", "Германия", "Тургояк"];
        const tripsGroups = new Set();
        
        // Собираем все группы из БД (API уже нормализует данные - убирает префикс "Поездки\")
        const allGroups = new Set();
        const groupsWithData = []; // Сохраняем группы с данными для сортировки
        
        groups.forEach(g => {
          const groupName = g.group_path || "";
          if (!groupName) return; // Пропускаем пустые группы
          allGroups.add(groupName);
          
          // Определяем, является ли группа поездкой
          // Вариант 1: Содержит год (4 цифры) и ключевое слово места из списка
          const hasYear = /\d{4}/.test(groupName);
          const hasPlace = tripsKeywords.some(keyword => groupName.includes(keyword));
          
          // Вариант 2: Начинается с года (YYYY) и содержит хотя бы одно слово после года
          // Это более гибкая логика - если группа начинается с года и содержит текст, считаем ее поездкой
          const startsWithYear = /^\d{4}\s/.test(groupName); // Начинается с 4 цифр и пробела
          const hasTextAfterYear = startsWithYear && groupName.length > 5; // После года есть текст
          
          const isTrip = (hasYear && hasPlace) || (startsWithYear && hasTextAfterYear);
          if (isTrip) {
            tripsGroups.add(groupName);
          }
          
          // Сохраняем данные группы для сортировки
          groupsWithData.push({
            name: groupName,
            isTrip: isTrip,
            last_created_at: g.last_created_at || ""
          });
        });
        
        // Добавляем предопределенные группы, которых еще нет в БД
        predefinedGroups.forEach(predefined => {
          if (!allGroups.has(predefined)) {
            groupsWithData.push({
              name: predefined,
              isTrip: false,
              last_created_at: "" // Нет даты, так как группы еще нет в БД
            });
            allGroups.add(predefined);
          }
        });
        
        // Группируем по категориям
        const categoryMap = {};
        const otherGroups = [];
        
        for (const groupData of groupsWithData) {
          if (groupData.isTrip) {
            const category = "Поездки";
            if (!categoryMap[category]) categoryMap[category] = [];
            categoryMap[category].push({
              name: groupData.name,
              last_created_at: groupData.last_created_at
            });
          } else {
            otherGroups.push(groupData.name);
          }
        }
        
        // Обновляем все select'ы в карточках (ищем по data-file-path)
        const selects = qsa('select[data-file-path]');
        console.log("[updateGroupSelects] Найдено select'ов:", selects.length);
        
        selects.forEach(select => {
          const currentValue = select.value;
          select.innerHTML = '<option value="">Назначить группу...</option>';
          
          // Добавляем группы "Поездки"
          if (categoryMap["Поездки"] && categoryMap["Поездки"].length > 0) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = "Поездки";
            // Сортируем поездки по дате добавления (последние добавленные - выше)
            categoryMap["Поездки"].sort((a, b) => {
              const dateA = a.last_created_at || "";
              const dateB = b.last_created_at || "";
              if (dateA && dateB) {
                const dateCompare = dateB.localeCompare(dateA); // Новые выше (по убыванию)
                if (dateCompare !== 0) return dateCompare;
              }
              // Если даты одинаковые или отсутствуют, сортируем по алфавиту
              return a.name.localeCompare(b.name);
            });
            categoryMap["Поездки"].forEach(trip => {
              const opt = document.createElement("option");
              opt.value = trip.name; // Храним просто название без префикса
              opt.textContent = trip.name;
              optgroup.appendChild(opt);
            });
            select.appendChild(optgroup);
          }
          
          // Добавляем остальные группы
          otherGroups.sort();
          otherGroups.forEach(groupPath => {
            const opt = document.createElement("option");
            opt.value = groupPath;
            opt.textContent = groupPath;
            select.appendChild(opt);
          });
          
          // Добавляем опцию для создания новой группы в категории "Поездки"
          if (categoryMap["Поездки"] && categoryMap["Поездки"].length > 0) {
            const createOptInGroup = document.createElement("option");
            createOptInGroup.value = "__create_new_Поездки__";
            createOptInGroup.textContent = "+ Создать новую поездку...";
            createOptInGroup.style.fontStyle = "italic";
            // Находим optgroup "Поездки" и добавляем опцию в него
            const tripsOptgroup = select.querySelector('optgroup[label="Поездки"]');
            if (tripsOptgroup) {
              tripsOptgroup.appendChild(createOptInGroup);
            }
          }
          
          // Добавляем опцию для создания новой группы (общая)
          const createOpt = document.createElement("option");
          createOpt.value = "__create_new__";
          createOpt.textContent = "+ Создать новую группу...";
          createOpt.style.fontStyle = "italic";
          select.appendChild(createOpt);
          
          // Восстанавливаем выбранное значение
          if (currentValue) {
            select.value = currentValue;
          }
        });
        
        console.log("[updateGroupSelects] Обновлено select'ов:", selects.length);
      }
      
      async function handleGroupSelectFromDropdown(selectEl, event) {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
        
        // Получаем путь из data-file-path атрибута (надежный способ, избегает проблем с экранированием)
        const filePath = selectEl.getAttribute("data-file-path");
        if (!filePath) {
          console.error("[handleGroupSelectFromDropdown] Не найден data-file-path атрибут");
          return;
        }
        
        console.log("[handleGroupSelectFromDropdown] filePath из атрибута:", filePath);
        
        const groupPath = selectEl.value;
        console.log("[handleGroupSelectFromDropdown] groupPath:", groupPath);
        
        if (groupPath === "__create_new__" || groupPath === "__create_new_Поездки__") {
          // Определяем, в какой категории создаем группу
          const isTrips = groupPath === "__create_new_Поездки__";
          const optgroup = selectEl.closest('optgroup');
          const category = isTrips ? "Поездки" : (optgroup ? optgroup.label : null);
          
          let promptText = "Введите название новой группы:";
          if (category === "Поездки" || isTrips) {
            promptText = "Введите название поездки (например: 2025 Италия):";
          }
          
          const newGroupName = prompt(promptText);
          if (newGroupName && newGroupName.trim()) {
            // Храним просто название без префикса категории
            await assignGroupToFile(filePath, newGroupName.trim(), selectEl);
          } else {
            // Возвращаем select в исходное состояние
            selectEl.value = "";
          }
        } else if (groupPath) {
          await assignGroupToFile(filePath, groupPath, selectEl);
        }
      }
      
      async function handlePersonSelectFromDropdown(selectEl, event) {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
        
        const filePath = selectEl.getAttribute("data-file-path");
        if (!filePath) {
          console.error("[handlePersonSelectFromDropdown] Не найден data-file-path атрибут");
          return;
        }
        
        const personId = selectEl.value;
        if (!personId || personId === "") {
          return;
        }
        
        try {
          await postJson("/api/persons/assign-file", {
            pipeline_run_id: Number(pipelineRunId),
            file_path: filePath,
            person_id: parseInt(personId)
          });
          
          // Инвалидируем кэш персон, так как данные изменились
          invalidatePersonsCache();
          // Инвалидируем кэш персон на файле
          const cacheKey = `${pipelineRunId}:${filePath}`;
          personsOnFileCache.delete(cacheKey);
          
          // Обновляем список персон на фото
          await loadPersonsOnFile(filePath);
          
          // Не обновляем подзакладки персон - загрузка персон на конкретный файл не меняет список подзакладок
          
          // Возвращаем select в исходное состояние
          selectEl.value = "";
          
          const person = allPersonsList.find(p => p.id === parseInt(personId));
          const personName = person ? (person.name || `Персона ${personId}`) : `Персона ${personId}`;
          setToast(`Персона "${personName}" добавлена к файлу.`);
        } catch (e) {
          setToast(e?.message || String(e), true);
        }
      }
      
      // Кэш для данных о персонах на файлах
      const personsOnFileCache = new Map();
      const PERSONS_ON_FILE_CACHE_TTL = 30000; // 30 секунд
      
      async function loadPersonsOnFile(filePath) {
        if (!filePath || !pipelineRunId) {
          return;
        }
        
        // Проверяем кэш
        const cacheKey = `${pipelineRunId}:${filePath}`;
        const cached = personsOnFileCache.get(cacheKey);
        if (cached && (Date.now() - cached.timestamp) < PERSONS_ON_FILE_CACHE_TTL) {
          // Используем кэшированные данные
          updatePersonsOnFileUI(filePath, cached.persons, cached.rects);
          return;
        }
        
        try {
          // Загружаем данные параллельно
          const [personsData, rectsData] = await Promise.all([
            fetchJson(`/api/faces/file-persons?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(filePath)}`).catch(() => ({ persons: [] })),
            fetchJson(`/api/faces/rectangles?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(filePath)}`).catch(() => ({ rectangles: [] }))
          ]);
          
          const persons = personsData?.persons || [];
          const allRects = rectsData?.rectangles || [];
          
          // Сохраняем в кэш
          personsOnFileCache.set(cacheKey, {
            persons,
            rects: allRects,
            timestamp: Date.now()
          });
          
          // Обновляем UI
          updatePersonsOnFileUI(filePath, persons, allRects);
        } catch (e) {
          console.error("Ошибка загрузки персон на фото:", e);
        }
      }
      
      function updatePersonsOnFileUI(filePath, persons, allRects) {
        // Находим элемент для отображения персон
        const allPersonsEls = qsa('div[id^="persons-on-file-"]');
        let personsEl = null;
        for (const el of allPersonsEls) {
          const elPath = el.getAttribute("data-file-path");
          if (elPath === filePath) {
            personsEl = el;
            break;
          }
        }
        
        if (personsEl) {
          if (persons.length === 0) {
            personsEl.innerHTML = `<span class="muted">Нет персон на фото</span>`;
          } else {
            // Создаем мапу face_rectangle_id -> индекс в списке
            const rectIndexMap = {};
            allRects.forEach((rect, idx) => {
              if (rect.id) {
                rectIndexMap[rect.id] = idx + 1; // Номер начинается с 1
              }
            });
            
            const personsList = persons.map(p => {
              const name = p.name || `Персона ${p.id}`;
              const faces = p.faces || [];
              let facesInfo = "";
              if (faces.length > 0) {
                const facesDetails = faces.map(f => {
                  const faceNum = rectIndexMap[f.id] || "?";
                  return `#${faceNum} ${f.w}×${f.h}`;
                }).join(", ");
                facesInfo = ` (${facesDetails})`;
              }
              return `<span class="pill" style="background:#eef2ff; color:#1f2937;">${escapeHtml(name)}${facesInfo}</span>`;
            }).join(" ");
            personsEl.innerHTML = `<span class="muted">Персоны на фото:</span> ${personsList}`;
          }
        }
        
        // Обновляем кнопку "это не {PersonName}" если мы на подзакладке персоны
        const isPersonSubtab = subtab && subtab.startsWith("person_");
        if (isPersonSubtab) {
          const currentPersonId = parseInt(subtab.replace("person_", ""));
          const currentPerson = persons.find(p => p.id === currentPersonId);
          
          // Ищем кнопку во всех карточках с этим файлом
          const card = qs(`.card[data-path="${escapeHtml(filePath)}"]`);
          if (card) {
            const notPersonBtn = card.querySelector(`button[data-action="not_person"][data-person-id="${currentPersonId}"]`);
            if (notPersonBtn && currentPerson) {
              const personName = currentPerson.name || `Персона ${currentPersonId}`;
              notPersonBtn.textContent = `Это не ${personName}`;
            }
          }
        }
      }
      
      async function updatePersonSelects(persons) {
        if (!persons || persons.length === 0) return;
        
        // Находим все выпадашки персон
        const selects = qsa('select[onchange*="handlePersonSelectFromDropdown"]');
        selects.forEach(selectEl => {
          const currentPersonId = selectEl.getAttribute("data-current-person-id");
          const filePath = selectEl.getAttribute("data-file-path");
          
          // Очищаем опции (кроме первой)
          while (selectEl.options.length > 1) {
            selectEl.remove(1);
          }
          
          // Добавляем персон (исключая текущую)
          persons.forEach(person => {
            if (currentPersonId && person.id === parseInt(currentPersonId)) {
              return; // Пропускаем текущую персону
            }
            const option = document.createElement("option");
            option.value = String(person.id);
            option.textContent = person.name || `Персона ${person.id}`;
            selectEl.appendChild(option);
          });
        });
        
        // Загружаем персон на фото для всех карточек параллельно
        const filePaths = new Set();
        selects.forEach(selectEl => {
          const filePath = selectEl.getAttribute("data-file-path");
          if (filePath) filePaths.add(filePath);
        });
        
        // Загружаем параллельно батчами по 10 файлов
        const batchSize = 10;
        const filePathsArray = Array.from(filePaths);
        for (let i = 0; i < filePathsArray.length; i += batchSize) {
          const batch = filePathsArray.slice(i, i + batchSize);
          await Promise.all(batch.map(filePath => loadPersonsOnFile(filePath).catch(e => {
            console.error("[updatePersonSelects] Ошибка загрузки персон для", filePath, ":", e);
          })));
        }
      }
      
      async function assignGroupToFile(filePath, groupPath, selectEl = null) {
        if (!groupPath) return;
        
        console.log("[assignGroupToFile] Начинаем назначение группы:", {
          filePath: filePath,
          groupPath: groupPath,
          filePathType: typeof filePath,
          groupPathType: typeof groupPath,
          pipelineRunId: pipelineRunId
        });
        
        try {
          const payload = {
            pipeline_run_id: Number(pipelineRunId),
            path: filePath,
            group_path: groupPath
          };
          console.log("[assignGroupToFile] Отправляем payload:", payload);
          
          const response = await postJson("/api/faces/assign-group", payload);
          console.log("[assignGroupToFile] Ответ сервера:", response);
          
          // Удаляем карточку файла
          // Ищем карточку через родительский элемент select'а или по data-path
          let card = null;
          if (selectEl) {
            // Ищем карточку через родительский элемент
            card = selectEl.closest('.card');
          }
          if (!card) {
            // Пытаемся найти по data-path (используем escapeHtml для правильного экранирования)
            const escapedPath = escapeHtml(filePath);
            // Для CSS селектора нужно экранировать специальные символы
            const cssEscapedPath = filePath.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, '\\$&');
            card = qs(`.card[data-path="${cssEscapedPath}"]`) || 
                   document.querySelector(`.card[data-path="${escapedPath}"]`);
          }
          if (!card) {
            // Последняя попытка - ищем все карточки и сравниваем пути
            const allCards = qsa('.card');
            for (const c of allCards) {
              if (c.getAttribute('data-path') === filePath) {
                card = c;
                break;
              }
            }
          }
          
          if (card) {
            const row = _asInt(card.getAttribute("data-row"));
            try { cardIo.unobserve(card); } catch (e) {}
            if (row) visibleRows.delete(row);
            card.remove();
            console.log("[assignGroupToFile] Карточка удалена:", filePath);
          } else {
            console.warn("[assignGroupToFile] Карточка не найдена для удаления:", filePath);
          }
          
          await refreshTabCounts();
          await loadGroupsSubtabs();
          
          // Обновляем выпадашки групп после назначения (чтобы новая группа появилась в списке)
          if (tab === "no_faces") {
            try {
              const groupsData = await fetchJson(`/api/faces/groups-with-files?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
              await updateGroupSelects(groupsData?.groups || []);
              console.log("[assignGroupToFile] Выпадашки групп обновлены после назначения");
            } catch (e) {
              console.error("[assignGroupToFile] Ошибка обновления выпадашек:", e);
            }
          }
          
          // Если мы на подзакладке группы, перезагружаем список файлов
          // чтобы новый файл появился в списке
          if (tab === "no_faces" && subtab && subtab.startsWith("group_")) {
            // Перезагружаем список файлов для текущей подзакладки
            page = 1;
            if (!loading) {
              load(true);
            }
          } else if (tab === "no_faces" && (subtab === "unsorted_photos" || subtab === "unsorted_videos")) {
            // Если мы на "К разбору" (фото или видео), перезагружаем список, чтобы убедиться, что файл исчез
            // (файл с группой не должен показываться в "К разбору")
            if (!loading) {
              page = 1;
              load(true);
            } else {
              // Если идет загрузка, ждем и перезагружаем
              setTimeout(() => {
                if (!loading) {
                  page = 1;
                  load(true);
                }
              }, 500);
            }
          }
          
          setToast(`Файл назначен в группу "${groupPath}".`);
        } catch (e) {
          setToast(`Ошибка назначения группы: ${e.message}`, true);
          // Возвращаем select в исходное состояние
          if (selectEl) {
            selectEl.value = "";
          } else {
            // Пытаемся найти select по data-file-path
            const selects = qsa(`select[data-file-path="${filePath.replace(/"/g, '&quot;').replace(/'/g, '&#039;')}"]`);
            if (selects.length > 0) {
              selects[0].value = "";
            }
          }
        }
      }
      
      let currentGroupAssignPath = null; // Путь файла, для которого выбираем группу
      let currentPersonAssignPath = null; // Путь файла, для которого выбираем персону
      let allPersonsList = []; // Список всех персон для модального окна
      
      // Функции для работы с модальным окном назначения персон
      async function showPersonDialog(filePath) {
        currentPersonAssignPath = filePath;
        const modal = qs("#modalPerson");
        if (!modal) return null;
        
        // Загружаем список персон
        await loadPersonsForSelect();
        
        // Сбрасываем состояние
        const checkboxMultiple = qs("#checkboxMultiplePersons");
        if (checkboxMultiple) checkboxMultiple.checked = false;
        updatePersonModalMode(false);
        
        // Очищаем поля ввода
        const inputNew = qs("#inputNewPersonName");
        const inputNewMultiple = qs("#inputNewPersonNameMultiple");
        if (inputNew) inputNew.value = "";
        if (inputNewMultiple) inputNewMultiple.value = "";
        
        // Показываем модальное окно
        modal.style.display = "flex";
        modal.setAttribute("aria-hidden", "false");
        
        // Возвращаем Promise, который разрешится с выбранными персонами или null
        return new Promise((resolve) => {
          window.__personDialogResolve = resolve;
        });
      }
      
      async function loadPersonsForSelect() {
        try {
          const resp = await fetch("/api/persons/list");
          const data = await resp.json();
          allPersonsList = data.persons || [];
          
          // Заполняем select для одной персоны
          const select = qs("#selectPerson");
          if (select) {
            select.innerHTML = '<option value="">Выберите персону...</option>';
            
            // Группируем персон по группам
            const groupedPersons = {};
            const noGroupPersons = [];
            
            for (const p of allPersonsList) {
              if (p.is_ignored) continue; // Пропускаем "Посторонние"
              const groupName = p.group || null;
              if (groupName) {
                if (!groupedPersons[groupName]) {
                  groupedPersons[groupName] = {
                    order: p.group_order || 999,
                    persons: []
                  };
                }
                groupedPersons[groupName].persons.push(p);
              } else {
                noGroupPersons.push(p);
              }
            }
            
            // Сортируем группы по order
            const sortedGroups = Object.entries(groupedPersons).sort((a, b) => {
              return a[1].order - b[1].order;
            });
            
            // Сортируем персон внутри каждой группы по имени
            for (const [groupName, groupData] of sortedGroups) {
              groupData.persons.sort((a, b) => {
                const nameA = (a.name || "").toLowerCase();
                const nameB = (b.name || "").toLowerCase();
                return nameA.localeCompare(nameB);
              });
              
              const optgroup = document.createElement("optgroup");
              optgroup.label = groupName;
              for (const person of groupData.persons) {
                const opt = document.createElement("option");
                opt.value = String(person.id);
                opt.textContent = person.name || `Персона ${person.id}`;
                optgroup.appendChild(opt);
              }
              select.appendChild(optgroup);
            }
            
            // Добавляем персон без группы
            noGroupPersons.sort((a, b) => {
              const nameA = (a.name || "").toLowerCase();
              const nameB = (b.name || "").toLowerCase();
              return nameA.localeCompare(nameB);
            });
            
            for (const person of noGroupPersons) {
              const opt = document.createElement("option");
              opt.value = String(person.id);
              opt.textContent = person.name || `Персона ${person.id}`;
              select.appendChild(opt);
            }
          }
          
          // Заполняем список с чекбоксами для нескольких персон
          const checkboxList = qs("#personsCheckboxList");
          if (checkboxList) {
            checkboxList.innerHTML = "";
            
            // Используем ту же группировку
            for (const [groupName, groupData] of sortedGroups) {
              const groupDiv = document.createElement("div");
              groupDiv.style.marginBottom = "8px";
              
              const groupLabel = document.createElement("div");
              groupLabel.style.fontWeight = "700";
              groupLabel.style.fontSize = "12px";
              groupLabel.style.color = "#6b7280";
              groupLabel.style.marginBottom = "4px";
              groupLabel.textContent = groupName;
              groupDiv.appendChild(groupLabel);
              
              for (const person of groupData.persons) {
                const personDiv = document.createElement("div");
                personDiv.style.display = "flex";
                personDiv.style.alignItems = "center";
                personDiv.style.gap = "8px";
                personDiv.style.padding = "4px 0";
                
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `person_checkbox_${person.id}`;
                checkbox.value = String(person.id);
                checkbox.style.width = "18px";
                checkbox.style.height = "18px";
                checkbox.style.cursor = "pointer";
                
                const label = document.createElement("label");
                label.htmlFor = `person_checkbox_${person.id}`;
                label.textContent = person.name || `Персона ${person.id}`;
                label.style.cursor = "pointer";
                label.style.flex = "1";
                
                personDiv.appendChild(checkbox);
                personDiv.appendChild(label);
                groupDiv.appendChild(personDiv);
              }
              
              checkboxList.appendChild(groupDiv);
            }
            
            // Добавляем персон без группы
            if (noGroupPersons.length > 0) {
              for (const person of noGroupPersons) {
                const personDiv = document.createElement("div");
                personDiv.style.display = "flex";
                personDiv.style.alignItems = "center";
                personDiv.style.gap = "8px";
                personDiv.style.padding = "4px 0";
                
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `person_checkbox_${person.id}`;
                checkbox.value = String(person.id);
                checkbox.style.width = "18px";
                checkbox.style.height = "18px";
                checkbox.style.cursor = "pointer";
                
                const label = document.createElement("label");
                label.htmlFor = `person_checkbox_${person.id}`;
                label.textContent = person.name || `Персона ${person.id}`;
                label.style.cursor = "pointer";
                label.style.flex = "1";
                
                personDiv.appendChild(checkbox);
                personDiv.appendChild(label);
                checkboxList.appendChild(personDiv);
              }
            }
          }
        } catch (e) {
          console.error("Ошибка загрузки персон для выбора:", e);
        }
      }
      
      function updatePersonModalMode(isMultiple) {
        const singleMode = qs("#singlePersonMode");
        const multipleMode = qs("#multiplePersonsMode");
        if (singleMode) singleMode.style.display = isMultiple ? "none" : "block";
        if (multipleMode) multipleMode.style.display = isMultiple ? "block" : "none";
      }
      
      function closePersonModal() {
        const modal = qs("#modalPerson");
        if (modal) {
          modal.style.display = "none";
          modal.setAttribute("aria-hidden", "true");
        }
        currentPersonAssignPath = null;
        if (window.__personDialogResolve) {
          window.__personDialogResolve(null);
          window.__personDialogResolve = null;
        }
      }
      
      async function assignSelectedPerson() {
        const checkboxMultiple = qs("#checkboxMultiplePersons");
        const isMultiple = checkboxMultiple ? checkboxMultiple.checked : false;
        
        let personIds = [];
        
        if (isMultiple) {
          // Режим нескольких персон - собираем выбранные чекбоксы
          const checkboxes = qs("#personsCheckboxList")?.querySelectorAll('input[type="checkbox"]:checked');
          if (checkboxes) {
            personIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
          }
          
          // Проверяем, ввели ли новую персону
          const inputNew = qs("#inputNewPersonNameMultiple");
          const newPersonName = inputNew ? inputNew.value.trim() : "";
          if (newPersonName && !personIds.length) {
            // Если выбрана только новая персона, нужно сначала создать её
            try {
              const createResp = await fetch("/api/persons/create", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ name: newPersonName })
              });
              const createData = await createResp.json();
              if (createData.person && createData.person.id) {
                personIds = [createData.person.id];
              } else {
                setToast("Ошибка создания персоны", true);
                return;
              }
            } catch (e) {
              setToast(`Ошибка создания персоны: ${e.message}`, true);
              return;
            }
          } else if (newPersonName && personIds.length) {
            // Если выбраны существующие персоны + новая - создаём новую и добавляем к списку
            try {
              const createResp = await fetch("/api/persons/create", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ name: newPersonName })
              });
              const createData = await createResp.json();
              if (createData.person && createData.person.id) {
                personIds.push(createData.person.id);
              }
            } catch (e) {
              console.error("Ошибка создания дополнительной персоны:", e);
            }
          }
        } else {
          // Режим одной персоны - берём из select или создаём новую
          const select = qs("#selectPerson");
          const selectedValue = select ? select.value : "";
          
          if (selectedValue) {
            personIds = [parseInt(selectedValue)];
          } else {
            const inputNew = qs("#inputNewPersonName");
            const newPersonName = inputNew ? inputNew.value.trim() : "";
            if (newPersonName) {
              try {
                const createResp = await fetch("/api/persons/create", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ name: newPersonName })
                });
                const createData = await createResp.json();
                if (createData.person && createData.person.id) {
                  personIds = [createData.person.id];
                } else {
                  setToast("Ошибка создания персоны", true);
                  return;
                }
              } catch (e) {
                setToast(`Ошибка создания персоны: ${e.message}`, true);
                return;
              }
            }
          }
        }
        
        if (personIds.length === 0) {
          setToast("Выберите персону или введите имя новой персоны", true);
          return;
        }
        
        if (window.__personDialogResolve) {
          window.__personDialogResolve(personIds);
          window.__personDialogResolve = null;
        }
        closePersonModal();
      }
      
      async function showGroupDialog(filePath) {
        currentGroupAssignPath = filePath;
        const modal = qs("#modalGroup");
        if (!modal) return null;
        
        // Загружаем список существующих групп
        await loadGroupsForSelect();
        
        // Очищаем поле ввода новой группы
        const inputNew = qs("#inputNewGroupPath");
        if (inputNew) inputNew.value = "";
        
        // Показываем модальное окно
        modal.style.display = "flex";
        modal.setAttribute("aria-hidden", "false");
        
        // Возвращаем Promise, который разрешится с выбранной группой или null
        return new Promise((resolve) => {
          window.__groupDialogResolve = resolve;
        });
      }
      
      async function loadGroupsForSelect() {
        if (!pipelineRunId) return;
        try {
          const data = await fetchJson(`/api/faces/groups-with-files?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
          const groups = data?.groups || [];
          const select = qs("#selectGroup");
          if (!select) return;
          
          // Предопределенные группы, которые должны быть доступны для выбора (даже если их нет в БД)
          const predefinedGroups = [
            "Здоровье",
            "Чеки",
            "Дом и ремонт",
            "Артефакты людей"
          ];
          
          // Определяем группы поездок динамически (та же логика, что и в updateGroupSelects)
          const tripsKeywords = ["Турция", "Минск", "Италия", "Испания", "Греция", "Франция", "Польша", "Чехия", "Германия", "Тургояк"];
          const tripsGroups = new Set();
          
          select.innerHTML = '<option value="">Выберите группу...</option>';
          
          // Группируем по категориям (убираем префикс "Поездки\" из старых данных для совместимости)
          const categoryMap = {};
          const otherGroups = [];
          const groupsFromDb = new Set(); // Отслеживаем группы из БД
          
          for (const group of groups) {
            let groupName = group.group_path || "";
            if (!groupName) continue; // Пропускаем пустые группы
            // Убираем префикс "Поездки\" или "Поездки/" для совместимости со старыми данными
            groupName = groupName.replace(/^Поездки[\\/]/, "");
            groupsFromDb.add(groupName);
            
            // Определяем, является ли группа поездкой
            // Вариант 1: Содержит год (4 цифры) и ключевое слово места из списка
            const hasYear = /\d{4}/.test(groupName);
            const hasPlace = tripsKeywords.some(keyword => groupName.includes(keyword));
            
            // Вариант 2: Начинается с года (YYYY) и содержит хотя бы одно слово после года
            const startsWithYear = /^\d{4}\s/.test(groupName); // Начинается с 4 цифр и пробела
            const hasTextAfterYear = startsWithYear && groupName.length > 5; // После года есть текст
            
            if ((hasYear && hasPlace) || (startsWithYear && hasTextAfterYear)) {
              const category = "Поездки";
              if (!categoryMap[category]) categoryMap[category] = [];
              categoryMap[category].push({ 
                ...group, 
                group_path: groupName,
                last_created_at: group.last_created_at || ""
              });
              tripsGroups.add(groupName); // Добавляем в Set для последующих проверок
            } else {
              otherGroups.push({ ...group, group_path: groupName });
            }
          }
          
          // Добавляем предопределенные группы, которых еще нет в БД
          predefinedGroups.forEach(predefined => {
            if (!groupsFromDb.has(predefined)) {
              otherGroups.push({
                group_path: predefined,
                files_count: 0,
                last_created_at: ""
              });
            }
          });
          
          // Добавляем группы "Поездки"
          if (categoryMap["Поездки"] && categoryMap["Поездки"].length > 0) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = "Поездки";
            // Сортируем поездки по дате добавления (последние добавленные - выше)
            categoryMap["Поездки"].sort((a, b) => {
              const dateA = a.last_created_at || "";
              const dateB = b.last_created_at || "";
              if (dateA && dateB) {
                const dateCompare = dateB.localeCompare(dateA); // Новые выше
                if (dateCompare !== 0) return dateCompare;
              }
              // Если даты одинаковые или отсутствуют, сортируем по алфавиту
              return (a.group_path || "").localeCompare(b.group_path || "");
            });
            for (const group of categoryMap["Поездки"]) {
              const opt = document.createElement("option");
              opt.value = group.group_path; // Храним просто название без префикса
              opt.textContent = `${group.group_path} (${group.files_count || 0})`;
              optgroup.appendChild(opt);
            }
            select.appendChild(optgroup);
          }
          
          // Добавляем остальные группы
          if (otherGroups.length > 0) {
            otherGroups.sort((a, b) => (a.group_path || "").localeCompare(b.group_path || ""));
            for (const group of otherGroups) {
              const opt = document.createElement("option");
              opt.value = group.group_path;
              opt.textContent = `${group.group_path} (${group.files_count || 0})`;
              select.appendChild(opt);
            }
          }
          
          // Предопределенные группы больше не нужны - показываем только группы из БД
          // Если нужна новая группа, пользователь может создать ее через "+ Создать новую группу..."
        } catch (e) {
          console.error("Ошибка загрузки групп для выбора:", e);
        }
      }
      
      function closeGroupModal() {
        const modal = qs("#modalGroup");
        if (modal) {
          modal.style.display = "none";
          modal.setAttribute("aria-hidden", "true");
        }
        currentGroupAssignPath = null;
        if (window.__groupDialogResolve) {
          window.__groupDialogResolve(null);
          window.__groupDialogResolve = null;
        }
      }
      
      async function assignSelectedGroup() {
        const select = qs("#selectGroup");
        const inputNew = qs("#inputNewGroupPath");
        const selectedValue = select ? select.value : "";
        const newGroupPath = inputNew ? inputNew.value.trim() : "";
        
        let groupPath = null;
        if (selectedValue) {
          groupPath = selectedValue;
        } else if (newGroupPath) {
          groupPath = newGroupPath;
        }
        
        if (!groupPath) {
          setToast("Выберите группу или введите название новой группы", true);
          return;
        }
        
        if (window.__groupDialogResolve) {
          window.__groupDialogResolve(groupPath);
          window.__groupDialogResolve = null;
        }
        closeGroupModal();
      }
      
      function applyTabUI() {
        qs("#tabFaces").classList.toggle("active", tab === "faces");
        qs("#tabQuarantine").classList.toggle("active", tab === "quarantine");
        qs("#tabAnimals").classList.toggle("active", tab === "animals");
        qs("#tabPeopleNoFace").classList.toggle("active", tab === "people_no_face");
        qs("#tabNoFaces").classList.toggle("active", tab === "no_faces");
        updateSubtabsVisibility();
        // no_faces filters removed
      }

      function setSubtab(st) {
        if (tab === "faces") {
          subtab = st;
          // Поддерживаем старый формат "all" для совместимости, но переводим в "unsorted"
          if (subtab === "all") subtab = "unsorted";
          if (!["unsorted","many_faces"].includes(subtab) && !subtab.startsWith("person_")) {
            subtab = "unsorted";
          }
        } else if (tab === "no_faces") {
          subtab = st;
          // Поддерживаем старый формат "all" и "unsorted" для совместимости (переводим в "unsorted_photos")
          if (subtab === "all" || subtab === "unsorted") subtab = "unsorted_photos";
          if (!["unsorted_photos", "unsorted_videos"].includes(subtab) && !subtab.startsWith("group_")) {
            subtab = "unsorted_photos";
          }
        } else {
          return;
        }
        updateSubtabsVisibility();
        updateUrlParams();
        // Перезагружаем список файлов для новой подзакладки
        // Убеждаемся, что subtab валидный перед вызовом load()
        if (tab === "faces" && !["unsorted","many_faces"].includes(subtab) && !subtab.startsWith("person_")) {
          subtab = "unsorted";
        } else if (tab === "no_faces" && !["unsorted_photos", "unsorted_videos"].includes(subtab) && !subtab.startsWith("group_")) {
          subtab = "unsorted_photos";
        }
        page = 1;
        // Проверяем, не идет ли уже загрузка
        if (!loading) {
          load(true);
        } else {
          // Если идет загрузка, ждем ее завершения
          setTimeout(() => {
            if (!loading) {
              load(true);
            }
          }, 500);
        }
      }

      function setTab(t) {
        tab = t;
        // Карантин теперь показывается в "Нет людей"
        if (tab === "quarantine") tab = "no_faces";
        if (!["faces","animals","people_no_face","no_faces"].includes(tab)) tab = "faces";
        if (tab === "faces") {
          if (!subtab || subtab === "all") {
            subtab = "unsorted";
          }
          // Валидируем subtab для faces
          if (!["unsorted","many_faces"].includes(subtab) && !subtab.startsWith("person_")) {
            subtab = "unsorted";
          }
          // Сбрасываем флаг при смене вкладки, чтобы список перезагрузился
          personsSubtabsLoaded = false;
          loadPersonsSubtabs();
        } else if (tab === "no_faces") {
          subtab = "unsorted";
          loadGroupsSubtabs();
        } else {
          subtab = "unsorted";
        }
        applyTabUI();
        updateUrlParams();
        page = 1;
        load(true);
      }
      qs("#tabFaces").onclick = () => setTab("faces");
      qs("#tabQuarantine").onclick = () => setTab("quarantine");
      qs("#tabAnimals").onclick = () => setTab("animals");
      qs("#tabPeopleNoFace").onclick = () => setTab("people_no_face");
      qs("#tabNoFaces").onclick = () => setTab("no_faces");
      qs("#subFacesUnsorted").onclick = () => setSubtab("unsorted");
      qs("#subNoFacesUnsortedPhotos").onclick = () => setSubtab("unsorted_photos");
      qs("#subNoFacesUnsortedVideos").onclick = () => setSubtab("unsorted_videos");
      qs("#subFacesMany").onclick = () => setSubtab("many_faces");
      // Пагинацию заменяем на бесконечную подгрузку при скролле.
      qs("#btnPrev").style.display = "none";
      qs("#btnNext").style.display = "none";
      qs("#page").textContent = "—";
      qs("#btnReload").onclick = () => load(true);

      function jumpToRow(n) {
        const nn = _asInt(n);
        const hint = qs("#jumpHint");
        if (!nn || nn < 1) {
          if (hint) hint.textContent = "Введите номер строки ≥ 1";
          return;
        }
        if (hint) hint.textContent = "";
        const targetPage = Math.floor((nn - 1) / pageSize) + 1;
        jumpTargetRow = nn;
        page = targetPage;
        load(true, { forcePage: targetPage });
      }
      qs("#btnJump").onclick = () => jumpToRow(qs("#jumpRow")?.value);
      qs("#jumpRow").addEventListener("keydown", (e) => {
        if (e.key === "Enter") jumpToRow(qs("#jumpRow")?.value);
      });

      async function refreshTabCounts() {
        if (!pipelineRunId) return;
        try {
          const data = await fetchJson(`/api/faces/tab-counts?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
          const c = data?.counts || {};
          const scFaces = data?.subcounts?.faces || {};
          const manyCnt = Number(scFaces.many_faces ?? 0);
          const unsortedCnt = Number(scFaces.unsorted ?? 0);
          const scNoFaces = data.subcounts?.no_faces || {};
          const noFacesUnsortedPhotosCnt = Number(scNoFaces.unsorted_photos ?? 0);
          const noFacesUnsortedVideosCnt = Number(scNoFaces.unsorted_videos ?? 0);
          qs("#tabFaces").textContent = `Люди (${Number(c.faces ?? 0)})`;
          // Вкладка "Карантин" скрыта - эти файлы теперь в подзакладке "Нет людей" -> "К разбору"
          // qs("#tabQuarantine").textContent = `Карантин (${Number(c.quarantine ?? 0)})`;
          qs("#tabAnimals").textContent = `Животные (${Number(c.animals ?? 0)})`;
          // Вкладка "Есть люди (без лиц)" скрыта - эти файлы теперь в подзакладке "К разбору"
          // qs("#tabPeopleNoFace").textContent = `Есть люди (без лиц) (${Number(c.people_no_face ?? 0)})`;
          qs("#tabNoFaces").textContent = `Нет людей (${Number(c.no_faces ?? 0)})`;
          const bMany = qs("#subFacesMany");
          if (bMany) bMany.textContent = `Много лиц (${manyCnt})`;
          const bUnsorted = qs("#subFacesUnsorted");
          if (bUnsorted) bUnsorted.textContent = `К разбору (${unsortedCnt})`;
          const bNoFacesUnsortedPhotos = qs("#subNoFacesUnsortedPhotos");
          if (bNoFacesUnsortedPhotos) bNoFacesUnsortedPhotos.textContent = `Фото к разбору (${noFacesUnsortedPhotosCnt})`;
          const bNoFacesUnsortedVideos = qs("#subNoFacesUnsortedVideos");
          if (bNoFacesUnsortedVideos) bNoFacesUnsortedVideos.textContent = `Видео к разбору (${noFacesUnsortedVideosCnt})`;
          
          // Не вызываем loadPersonsSubtabs() здесь - обновление списка подзакладок персон
          // происходит явно после действий, которые изменяют привязки (через loadPersonsSubtabs(true))
          
          // Обновляем выпадашки персон в карточках (используем кэшированные данные)
          if (tab === "faces" && subtab && subtab.startsWith("person_")) {
            const personsData = await fetchPersonsWithFiles();
            const persons = personsData?.persons || [];
            await updatePersonSelects(persons);
            
            // Сохраняем имя текущей персоны в глобальную переменную для использования в cardHtml
            const currentPersonId = parseInt(subtab.replace("person_", ""));
            const currentPerson = persons.find(p => p.id === currentPersonId);
            if (currentPerson) {
              if (!window.currentPersonName) {
                window.currentPersonName = {};
              }
              window.currentPersonName[currentPersonId] = currentPerson.name || `Персона ${currentPersonId}`;
            }
          }
        } catch (e) {
          // best-effort
        }
      }

      function cardHtml(it, rowNum) {
        const path = it.path || "";
        const kind = it.preview_kind || "none";
        const pv = it.preview_url || "";
        const manual = (it.faces_manual_label || "").toLowerCase();
        const manualPill = manual ? `<span class="pill">manual: ${escapeHtml(manual)}</span>` : ``;
        const facesCnt = Number(it.faces_count || 0);
        const qReason = it.faces_quarantine_reason || "";
        const qPill = qReason ? `<span class="pill">q: ${escapeHtml(qReason)}</span>` : ``;
        const aKind = it.animals_kind || "";
        const aPill = aKind ? `<span class="pill">animal: ${escapeHtml(aKind)}</span>` : ``;
        const pnfPerson = it.people_no_face_person || "";
        const pnfPill = (tab === "people_no_face" && pnfPerson) ? `<span class="pill">person: ${escapeHtml(pnfPerson)}</span>` : ``;
        const placeC = (it.place_country || "").toString().trim();
        const placeCity = (it.place_city || "").toString().trim();
        const placeLabel = (placeC || placeCity) ? [placeC, placeCity].filter(Boolean).join(", ") : "";
        const takenAt = (it.taken_at || "").toString();
        const takenDate = (takenAt && takenAt.length >= 10) ? takenAt.slice(0, 10) : "";
        const placePill = (tab === "no_faces" && placeLabel) ? `<span class="pill">место: ${escapeHtml(placeLabel)}</span>` : ``;
        const datePill = (tab === "no_faces" && takenDate) ? `<span class="pill">дата: ${escapeHtml(takenDate)}</span>` : ``;
        const framesBtn = (kind === "video" && pv)
          ? `<button class="vfbtn" type="button" data-act="frames" data-path="${escapeHtml(path)}" data-src="${escapeHtml(pv)}">Кадры</button>`
          : ``;
        const thumb = (kind === "image" && pv)
          ? `<img loading="lazy" alt="preview" referrerpolicy="no-referrer" src="${escapeHtml(pv)}" />`
          : (kind === "video" && pv)
            ? `<video controls muted preload="metadata" src="${escapeHtml(pv)}"></video>`
            : `<div class="noimg">нет превью</div>`;
        
        // Определяем, находимся ли мы на подзакладке персоны (нужно для всех вкладок)
        // Используем явную проверку, чтобы избежать ошибок, если tab или subtab не определены
        const currentTab = typeof tab !== "undefined" ? tab : "faces";
        const currentSubtab = typeof subtab !== "undefined" ? subtab : "";
        const isPersonSubtab = currentTab === "faces" && currentSubtab && typeof currentSubtab === "string" && currentSubtab.startsWith("person_");
        const escapedPath = escapeHtml(path);
        
        let btn = "";
        if (currentTab === "faces") {
          // Если мы на подзакладке персоны, показываем выпадашку для добавления персоны и кнопку "это не {PersonName}"
          const currentPersonId = isPersonSubtab ? parseInt(currentSubtab.replace("person_", "")) : null;
          
          let personSelectHtml = "";
          let notPersonBtn = "";
          
          if (isPersonSubtab && currentPersonId) {
            // Выпадашка для добавления персоны (как для групп)
            const personSelectId = `person-select-${escapedPath.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50)}`;
            personSelectHtml = `<select class="btn" style="padding:6px 12px; cursor:pointer; border:1px solid #d1d5db; border-radius:4px; background:white; min-width:180px;" onchange="handlePersonSelectFromDropdown(this, event)" id="${personSelectId}" data-file-path="${escapedPath}" data-current-person-id="${currentPersonId}">
              <option value="">Добавить персону...</option>
            </select>`;
            
            // Кнопка "это не {PersonName}" - получаем имя персоны из глобального списка или используем ID
            let personName = `Персона ${currentPersonId}`;
            if (window.currentPersonName && window.currentPersonName[currentPersonId]) {
              personName = window.currentPersonName[currentPersonId];
            }
            notPersonBtn = `<button class="btn danger" data-action="not_person" data-person-id="${currentPersonId}" title="Это не эта персона">Это не ${escapeHtml(personName)}</button>`;
          } else {
            personSelectHtml = `<button class="btn" data-action="assign_person" title="Назначить персону (можно несколько)">Персона</button>`;
          }
          
          // На подзакладке персоны убираем кнопки "Люди без лиц", "Лиц нет" и "Карантин"
          if (isPersonSubtab) {
            btn = `
              ${personSelectHtml}
              <button class="btn" data-action="mark_cat">Кот</button>
              ${notPersonBtn}
              <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
            `;
          } else {
            btn = `
              ${personSelectHtml}
              <button class="btn" data-action="mark_cat">Кот</button>
              <button class="btn" data-action="mark_quarantine">Карантин</button>
              <button class="btn" data-action="people_no_face">Люди без лиц</button>
              <button class="btn danger" data-action="no_faces">Лиц нет</button>
              ${notPersonBtn}
              <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
            `;
          }
        } else if (tab === "no_faces") {
          // Выпадашка для групп (как в кластерах)
          const escapedPath = escapeHtml(path);
          const groupSelectId = `group-select-${escapedPath.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50)}`;
          // Используем data-file-path атрибут для передачи пути, чтобы избежать проблем с экранированием в onchange
          // Обработчик будет получать путь из атрибута
          const groupSelectHtml = `<select class="btn" style="padding:6px 12px; cursor:pointer; border:1px solid #d1d5db; border-radius:4px; background:white; min-width:180px;" onchange="handleGroupSelectFromDropdown(this, event)" id="${groupSelectId}" data-file-path="${escapedPath}">
            <option value="">Назначить группу...</option>
          </select>`;
          btn = `
            <button class="btn" data-action="annotate_faces">Лица есть (разметить)</button>
            <button class="btn" data-action="mark_cat">Кот</button>
            <button class="btn" data-action="people_no_face">Есть люди (без лиц)</button>
            ${groupSelectHtml}
            <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
          `;
        } else if (currentTab === "quarantine") {
          btn = `
            <button class="btn" data-action="mark_faces">Нормальные лица</button>
            <button class="btn" data-action="mark_cat">Кот</button>
            <button class="btn danger" data-action="no_faces">Лиц нет</button>
            <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
          `;
        } else if (currentTab === "animals") {
          btn = `
            <button class="btn" data-action="mark_faces">Это не животное (лица)</button>
            <button class="btn danger" data-action="not_animal_no_faces">Это не животное (нет лиц)</button>
            <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
          `;
        } else if (currentTab === "people_no_face") {
          btn = `
            <button class="btn" data-action="reset">Сброс</button>
            <button class="btn danger" data-action="delete" title="Удалить файл (переместить в _delete)">🗑️</button>
          `;
        }
        const pastGold = !!it.sorted_past_gold;
        const cls = pastGold ? "card past-gold" : "card";
        const qMan = Number(it.quarantine_manual || 0);
        const pnfMan = Number(it.people_no_face_manual || 0);
        const aMan = Number(it.animals_manual || 0);
        const aManKind = (it.animals_manual_kind || "").toString();
        const pnfPerson2 = (it.people_no_face_person || "").toString();
        const fileId = it.file_id ? Number(it.file_id) : null;
        return `
          <div class="${cls}"
               data-path="${escapeHtml(path)}"
               ${fileId ? `data-file-id="${fileId}"` : ''}
               data-row="${Number(rowNum || 0) || ""}"
               data-faces-manual="${escapeHtml(manual)}"
               data-quarantine-manual="${escapeHtml(String(qMan))}"
               data-people-no-face-manual="${escapeHtml(String(pnfMan))}"
               data-people-no-face-person="${escapeHtml(pnfPerson2)}"
               data-animals-manual="${escapeHtml(String(aMan))}"
               data-animals-manual-kind="${escapeHtml(aManKind)}">
            <div class="thumb" data-path="${escapeHtml(path)}" data-kind="${escapeHtml(kind)}" data-src="${escapeHtml(pv)}">
              ${framesBtn}
              ${thumb}
            </div>
            <div class="card-body">
              <div class="path"><code>${escapeHtml(it.path_short || path)}</code></div>
              <div class="kv">
                ${rowNum ? `<span class="pill">#${Number(rowNum)}</span>` : ``}
                <span class="pill">лиц: ${facesCnt}</span>
                ${manualPill}
                ${qPill}
                ${aPill}
                ${pnfPill}
                ${placePill}
                ${datePill}
                ${it.size_human ? `<span class="pill">${escapeHtml(it.size_human)}</span>` : ``}
              </div>
              ${isPersonSubtab ? `<div class="kv" id="persons-on-file-${path.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50)}" data-file-path="${path}" style="margin-top:6px; font-size:11px; color:#6b7280;">
                <span class="muted">Загрузка персон на фото...</span>
              </div>` : ``}
              <div class="actions">
                ${btn}
              </div>
            </div>
          </div>
        `;
      }

      async function load(reset=false, opts={}) {
        if (!pipelineRunId) return;
        if (loading) return;
        if (!reset && !hasMore) return;
        
        const loadStartTime = performance.now();
        console.log(`[load] Начало загрузки карточек, reset=${reset}, tab=${tab}, subtab=${subtab}`);
        loading = true;
        setToast("");
        try {
          // Виртуализация: удаляем старые элементы при большом количестве для экономии памяти
          // Поддерживаем максимум 200 элементов в DOM, удаляя самые старые при превышении
          const maxLoadedItems = 200; // максимум 200 элементов в DOM одновременно (очень агрессивная виртуализация)
          const cards = _cards();
          // Начинаем удалять элементы уже при 200, чтобы не допустить переполнения
          if (!reset && cards.length >= maxLoadedItems) {
            // Удаляем первые 80 элементов (40% от максимума), чтобы освободить память
            const toRemove = cards.slice(0, 80);
            toRemove.forEach(card => {
              const row = _asInt(card.getAttribute("data-row"));
              try { cardIo.unobserve(card); } catch (e) {}
              if (row) visibleRows.delete(row);
              // Очищаем изображения из памяти перед удалением
              const img = card.querySelector("img");
              if (img) {
                img.src = "";
                img.removeAttribute("src");
                img.onload = null;
                img.onerror = null;
              }
              const video = card.querySelector("video");
              if (video) {
                video.src = "";
                video.removeAttribute("src");
                video.onload = null;
                video.onerror = null;
                try { video.load(); } catch (e) {}
              }
              // Очищаем все обработчики событий
              const clone = card.cloneNode(false);
              card.parentNode?.replaceChild(clone, card);
              clone.remove();
            });
            // Принудительная сборка мусора через requestIdleCallback
            if (window.requestIdleCallback) {
              requestIdleCallback(() => {
                console.log(`[load] Удалено 80 старых элементов, осталось в DOM: ${_cards().length}`);
              });
            } else {
              console.log(`[load] Удалено 80 старых элементов, осталось в DOM: ${_cards().length}`);
            }
          }
          if (reset && opts && typeof opts.forcePage === "number" && opts.forcePage >= 1) {
            page = Math.trunc(opts.forcePage);
          }
          if (reset) {
            hasMore = true;
            totalCount = null;
            loadedCount = 0;
            visibleRows.clear();
            try { cardIo.disconnect(); } catch (e) {}
            qs("#grid").innerHTML = `<div class="muted">Загрузка…</div>`;
          } else if (page === 1 && loadedCount === 0) {
            qs("#grid").innerHTML = `<div class="muted">Загрузка…</div>`;
          }
          let url = `/api/faces/results?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&tab=${encodeURIComponent(tab)}&subtab=${encodeURIComponent(subtab)}&page=${encodeURIComponent(String(page))}&page_size=${encodeURIComponent(String(pageSize))}`;
          if (tab === "no_faces") {
            url += `&sort=${encodeURIComponent(nfSort)}`;
          }
          const apiStartTime = performance.now();
          const data = await fetchJson(url);
          const apiTime = performance.now() - apiStartTime;
          console.log(`[load] API запрос /api/faces/results занял: ${apiTime.toFixed(2)}ms, получено элементов: ${(data?.items || []).length}`);
          qs("#prId").textContent = String(data.pipeline_run_id);
          qs("#frId").textContent = String(data.face_run_id);
          
          qs("#rootPath").textContent = data.root_path || "—";
          totalCount = (data.total != null) ? Number(data.total) : totalCount;
          qs("#total").textContent = String(totalCount ?? "—");
          const items = Array.isArray(data.items) ? data.items : [];
          const startRow = ((Number(page) - 1) * pageSize) + 1;
          if (reset) qs("#grid").innerHTML = "";
          if (!items.length && loadedCount === 0) {
            qs("#grid").innerHTML = `<div class="muted">Пусто.</div>`;
          } else if (items.length) {
            // Обычное отображение - разбиваем на части для производительности
            const chunkSize = 15;
            let htmlChunk = "";
            for (let i = 0; i < items.length; i++) {
              htmlChunk += cardHtml(items[i], startRow + i);
              if ((i + 1) % chunkSize === 0 || i === items.length - 1) {
                qs("#grid").insertAdjacentHTML("beforeend", htmlChunk);
                htmlChunk = "";
                // Даем браузеру передышку между вставками (каждые 15 элементов)
                if ((i + 1) % chunkSize === 0) {
                  await new Promise(resolve => setTimeout(resolve, 10));
                }
              }
            }
          }
          loadedCount += items.length;
          
          // Загружаем имя текущей персоны ДО создания карточек, если мы на подзакладке персоны (используем кэш)
          if (tab === "faces" && subtab && subtab.startsWith("person_")) {
            const currentPersonId = parseInt(subtab.replace("person_", ""));
            if (currentPersonId && (!window.currentPersonName || !window.currentPersonName[currentPersonId])) {
              // Загружаем список персон для получения имени
              try {
                const personsData = await fetchPersonsWithFiles();
                const persons = personsData?.persons || [];
                if (!window.currentPersonName) {
                  window.currentPersonName = {};
                }
                const currentPerson = persons.find(p => p.id === currentPersonId);
                if (currentPerson) {
                  window.currentPersonName[currentPersonId] = currentPerson.name || `Персона ${currentPersonId}`;
                }
              } catch (e) {
                console.error("[load] Ошибка загрузки имени персоны:", e);
              }
            }
          }
          
          // Загружаем персоны на фото для карточек, если мы на подзакладке персоны
          if (tab === "faces" && subtab && subtab.startsWith("person_")) {
            console.log("[load] Загружаем персоны для карточек, items:", items.length);
            // Загружаем персоны для всех загруженных карточек асинхронно
            // Используем requestAnimationFrame + setTimeout для гарантии, что DOM обновлен
            requestAnimationFrame(() => {
              setTimeout(async () => {
                console.log("[load] Начинаем загрузку персон для", items.length, "карточек");
                // Проверяем, что элементы уже в DOM
                const testEls = qsa('div[id^="persons-on-file-"]');
                console.log("[load] Элементов persons-on-file в DOM:", testEls.length);
                
                // Загружаем параллельно батчами по 10 файлов
                const batchSize = 10;
                for (let i = 0; i < items.length; i += batchSize) {
                  const batch = items.slice(i, i + batchSize).filter(item => item.path);
                  await Promise.all(batch.map(item => loadPersonsOnFile(item.path).catch(e => {
                    console.error("[load] Ошибка загрузки персон для", item.path, ":", e);
                  })));
                  // Небольшая задержка между батчами
                  if (i + batchSize < items.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                  }
                }
              }, 500); // Увеличиваем задержку до 500мс
            });
          }
          
          // hasMore определяется не только по количеству загруженных элементов,
          // но и по общему количеству элементов (totalCount), чтобы поддерживать прокрутку до конца
          hasMore = items.length === pageSize && (totalCount == null || loadedCount < totalCount);
          
          const totalTime = performance.now() - loadStartTime;
          console.log(`[load] Загрузка карточек завершена за ${totalTime.toFixed(2)}ms, элементов: ${items.length}, всего загружено: ${loadedCount}`);
          
          await refreshTabCounts();
          
          // Если это вкладка "Нет людей", загружаем группы для выпадашек после рендеринга карточек
          if (tab === "no_faces") {
            // Используем requestAnimationFrame + setTimeout для гарантии, что DOM обновлен
            // Также используем повторные попытки, если select'ы еще не появились
            requestAnimationFrame(() => {
              let attempts = 0;
              const maxAttempts = 10;
              const checkAndUpdate = async () => {
                try {
                  // Проверяем, есть ли select'ы в DOM
                  const selectsBefore = qsa('select[data-file-path]');
                  console.log(`[load] Попытка ${attempts + 1}/${maxAttempts}: Select'ов в DOM:`, selectsBefore.length);
                  
                  if (selectsBefore.length > 0) {
                    // Select'ы есть, загружаем группы и обновляем
                    console.log("[load] Загружаем группы для выпадашек, pipeline_run_id:", pipelineRunId);
                    const groupsData = await fetchJson(`/api/faces/groups-with-files?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
                    console.log("[load] Получено групп:", groupsData?.groups?.length || 0, groupsData?.groups);
                    
                    await updateGroupSelects(groupsData?.groups || []);
                    
                    // Проверяем после обновления
                    const selectsAfter = qsa('select[data-file-path]');
                    console.log("[load] Select'ов в DOM после обновления:", selectsAfter.length);
                    if (selectsAfter.length > 0) {
                      const firstSelect = selectsAfter[0];
                      console.log("[load] Первый select имеет опций:", firstSelect.options.length);
                    }
                  } else if (attempts < maxAttempts) {
                    // Select'ы еще не появились, повторяем попытку через 200мс
                    attempts++;
                    setTimeout(checkAndUpdate, 200);
                  } else {
                    console.warn("[load] Select'ы не появились после", maxAttempts, "попыток, пропускаем обновление");
                  }
                } catch (e) {
                  console.error("[load] Ошибка загрузки групп для выпадашек:", e);
                }
              };
              
              // Начинаем проверку через 300мс
              setTimeout(checkAndUpdate, 300);
            });
          }
          
          observeNewCards();
          _posScheduleUpdate();

          // if jump requested: scroll to the exact row within this page
          if (reset && jumpTargetRow != null) {
            const target = jumpTargetRow;
            jumpTargetRow = null;
            const el = _cards().find(c => _asInt(c.getAttribute("data-row")) === target);
            if (el) {
              el.scrollIntoView({ block: "start", behavior: "auto" });
              el.style.boxShadow = "0 0 0 2px rgba(59,130,246,0.45)";
              setTimeout(() => { try { el.style.boxShadow = ""; } catch (e) {} }, 1200);
            } else {
              window.scrollTo({ top: 0, behavior: "auto" });
            }
          }

          // actions - обработчики добавлены через делегирование событий (см. инициализацию ниже)
        } catch (e) {
          console.error("[load] Ошибка загрузки:", e);
          setToast(e?.message || String(e), true);
          if (loadedCount === 0) qs("#grid").innerHTML = "";
          hasMore = false;
          // Не перезагружаем страницу при ошибке, просто останавливаем загрузку
        } finally {
          loading = false;
        }
      }

      // --- viewer / annotate ---
      const lb = qs("#lightbox");
      const lbImg = qs("#lbImg");
      const lbVideo = qs("#lbVideo");
      const lbCanvas = qs("#lbCanvas");
      const lbCtx = lbCanvas.getContext("2d");
      const lbPath = qs("#lbPath");
      const lbMode = qs("#lbMode");
      const lbAnnotate = qs("#lbAnnotate");
      const lbClear = qs("#lbClear");
      const lbSave = qs("#lbSave");
      const rectList = qs("#rectList");
      const lbTabs = qs("#lbTabs");
      const lbTabVideo = qs("#lbTabVideo");
      const lbTabF1 = qs("#lbTabF1");
      const lbTabF2 = qs("#lbTabF2");
      const lbTabF3 = qs("#lbTabF3");
      let curPath = "";
      let curAutoRects = [];   // auto (read-only)
      let curManualRects = []; // manual (editable)
      let drawEnabled = false;
      let dragging = false;
      let dragStart = null;
      let tempRect = null;
      let curSrc = "";
      let curKind = "image"; // 'image' | 'video'
      let curVideoSrc = "";
      let curVideoFrameIdx = 0; // 0=video, 1..3=frame
      let curVideoFrames = null; // {frames:[...]}

      function closeLb() {
        lb.classList.remove("open");
        lb.setAttribute("aria-hidden","true");
        try { if (lbVideo) { lbVideo.pause(); lbVideo.removeAttribute("src"); lbVideo.load(); } } catch (e) {}
        curPath = "";
        curSrc = "";
        curAutoRects = [];
        curManualRects = [];
        curKind = "image";
        curVideoSrc = "";
        curVideoFrameIdx = 0;
        curVideoFrames = null;
        drawEnabled = false;
        dragging = false;
        dragStart = null;
        tempRect = null;
        lbCanvas.classList.remove("draw-on");
        if (lbAnnotate) lbAnnotate.style.display = "none";
        if (lbTabs) lbTabs.style.display = "none";
        if (lbImg) lbImg.style.display = "";
        if (lbVideo) lbVideo.style.display = "none";
      }
      qs("#lbClose").onclick = closeLb;
      lb.addEventListener("click", (e) => { if (e.target === lb) closeLb(); });
      window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeLb(); });

      let curRectsWithPersons = []; // Храним информацию о прямоугольниках с персонами
      
      async function loadRectsWithPersons() {
        if (!curPath || !pipelineRunId) {
          curRectsWithPersons = [];
          console.log('[loadRectsWithPersons] Нет curPath или pipelineRunId');
          return;
        }
        
        try {
          console.log('[loadRectsWithPersons] Загружаем данные для:', { curPath, pipelineRunId });
          const data = await fetchJson(`/api/faces/rectangles?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(curPath)}`);
          console.log('[loadRectsWithPersons] Получены данные:', { rectanglesCount: data?.rectangles?.length || 0, rectangles: data?.rectangles });
          curRectsWithPersons = (data?.rectangles || []).map((r, i) => ({
            index: i,
            id: r.id,
            x: Number(r.bbox_x || 0),
            y: Number(r.bbox_y || 0),
            w: Number(r.bbox_w || 0),
            h: Number(r.bbox_h || 0),
            person_id: r.person_id || null,
            person_name: r.person_name || null,
            is_manual: Number(r.is_manual || 0) === 1
          }));
          console.log('[loadRectsWithPersons] Обработанные данные:', { 
            count: curRectsWithPersons.length, 
            withPersons: curRectsWithPersons.filter(r => r.person_name).length,
            rects: curRectsWithPersons.map(r => ({ x: r.x, y: r.y, person_name: r.person_name }))
          });
        } catch (e) {
          console.error("Ошибка загрузки прямоугольников с персонами:", e);
          curRectsWithPersons = [];
        }
      }
      
      function renderRectList() {
        const all = [...(curAutoRects||[]), ...(curManualRects||[])];
        if (all.length === 0) {
          rectList.innerHTML = `<span class="muted">—</span>`;
          return;
        }
        
        // Сопоставляем прямоугольники с информацией о персонах
        const rectsHtml = all.map((r, i) => {
          const rectInfo = curRectsWithPersons.find(ri => {
            // Сопоставляем по индексу или по координатам
            return (ri.index === i) || 
                   (Math.abs(ri.x - r.x) < 5 && Math.abs(ri.y - r.y) < 5 && 
                    Math.abs(ri.w - r.w) < 5 && Math.abs(ri.h - r.h) < 5);
          });
          
          const personName = rectInfo?.person_name;
          const personId = rectInfo?.person_id;
          const rectId = rectInfo?.id;
          
          let pillContent = `#${i+1} ${r.w}×${r.h}`;
          if (personName) {
            pillContent += ` (${escapeHtml(personName)})`;
          }
          
          const pillClass = personName ? "rectpill" : "rectpill";
          const pillStyle = personName ? "background:#dbeafe; color:#1e40af;" : "";
          
          return `<span class="${pillClass}" style="${pillStyle}" data-rect-id="${rectId || ''}" data-rect-index="${i}" data-person-id="${personId || ''}" title="${personName ? `Персона: ${escapeHtml(personName)}. Двойной клик для изменения.` : 'Двойной клик для назначения персоны.'}">${pillContent}</span>`;
        }).join("");
        
        rectList.innerHTML = rectsHtml;
      }

      function resizeCanvasToImage() {
        const w = lbImg.clientWidth;
        const h = lbImg.clientHeight;
        lbCanvas.width = Math.max(1, Math.floor(w));
        lbCanvas.height = Math.max(1, Math.floor(h));
        lbCanvas.style.width = w + "px";
        lbCanvas.style.height = h + "px";
      }

      function drawOverlay() {
        if (!lbCtx) return;
        resizeCanvasToImage();
        lbCtx.clearRect(0,0,lbCanvas.width, lbCanvas.height);
        if (curKind === "video" && curVideoFrameIdx === 0) {
          return; // no overlay on video playback
        }
        const iw = lbImg.naturalWidth || 1;
        const ih = lbImg.naturalHeight || 1;
        const sx = lbCanvas.width / iw;
        const sy = lbCanvas.height / ih;
        lbCtx.lineWidth = 2;
        
        // Удаляем старые подписи
        const imgWrap = qs("#imgWrap");
        if (imgWrap) {
          const oldLabels = imgWrap.querySelectorAll(".lb-rectangle-label");
          oldLabels.forEach(el => el.remove());
        }
        
        // Используем curRectsWithPersons как основной источник данных (там уже есть информация о персонах)
        // Если curRectsWithPersons пуст, используем curAutoRects/curManualRects как fallback
        const rectsToDraw = curRectsWithPersons.length > 0 ? curRectsWithPersons : 
          [...(curAutoRects||[]).map((r, i) => ({...r, index: i, is_manual: false, person_name: null})),
           ...(curManualRects||[]).map((r, i) => ({...r, index: i + (curAutoRects||[]).length, is_manual: true, person_name: null}))];
        
        console.log('[drawOverlay] Данные для отрисовки:', {
          curRectsWithPersonsLength: curRectsWithPersons.length,
          curAutoRectsLength: curAutoRects?.length || 0,
          curManualRectsLength: curManualRects?.length || 0,
          rectsToDrawLength: rectsToDraw.length,
          rectsToDraw: rectsToDraw.map(r => ({ x: r.x, y: r.y, w: r.w, h: r.h, person_name: r.person_name, is_manual: r.is_manual }))
        });
        
        // Рисуем прямоугольники и создаем подписи
        rectsToDraw.forEach((rectInfo, i) => {
          const isManual = rectInfo.is_manual || false;
          const personName = rectInfo.person_name || null;
          
          // Рисуем прямоугольник на canvas
          lbCtx.strokeStyle = isManual ? "rgba(59,130,246,0.95)" : "rgba(250,204,21,0.95)";
          const rectX = rectInfo.x * sx;
          const rectY = rectInfo.y * sy;
          const rectW = rectInfo.w * sx;
          const rectH = rectInfo.h * sy;
          lbCtx.strokeRect(rectX, rectY, rectW, rectH);
          
          // Создаем подпись как DOM-элемент (аналогично face_cluster_detail.html)
          // Показываем имя персоны, если оно назначено
          if (imgWrap && personName) {
            const label = document.createElement('div');
            label.className = `lb-rectangle-label ${isManual ? 'manual' : ''}`;
            label.textContent = personName;
            label.style.left = `${rectX}px`;
            label.style.top = `${Math.max(0, rectY - 20)}px`;
            imgWrap.appendChild(label);
            console.log('[drawOverlay] Создана подпись:', { personName, rectX, rectY, isManual, i, label });
          } else if (imgWrap) {
            console.log('[drawOverlay] Подпись не создана (нет personName):', { i, personName, rectInfo, imgWrap: !!imgWrap });
          }
        });
        
        // temp
        if (tempRect) {
          lbCtx.strokeStyle = "rgba(16,185,129,0.95)";
          lbCtx.strokeRect(tempRect.x * sx, tempRect.y * sy, tempRect.w * sx, tempRect.h * sy);
        }
      }

      async function fetchRects(path) {
        const data = await fetchJson(`/api/faces/rectangles?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(path)}`);
        const rects = Array.isArray(data.rectangles) ? data.rectangles : [];
        const auto = [];
        const manual = [];
        rects.forEach(r => {
          const rr = { x: Number(r.bbox_x||0), y: Number(r.bbox_y||0), w: Number(r.bbox_w||0), h: Number(r.bbox_h||0) };
          const im = Number(r.is_manual || 0) === 1;
          (im ? manual : auto).push(rr);
        });
        return { auto, manual };
      }

      async function openViewer(path, src, opts={}) {
        curKind = "image";
        curPath = path;
        curSrc = src || "";
        lbPath.textContent = path;
        lbImg.referrerPolicy = "no-referrer";
        lbImg.draggable = false;
        if (lbTabs) lbTabs.style.display = "none";
        if (lbVideo) lbVideo.style.display = "none";
        if (lbImg) lbImg.style.display = "";
        lbImg.src = src;
        const isAnnotate = (opts.mode === "annotate");
        lbMode.textContent = isAnnotate ? "разметка" : "просмотр";
        lbClear.style.display = isAnnotate ? "" : "none";
        lbSave.style.display = isAnnotate ? "" : "none";
        // В режиме просмотра показываем кнопку "Разметить" (только для картинок)
        if (lbAnnotate) lbAnnotate.style.display = (!isAnnotate && !!curSrc) ? "" : "none";
        drawEnabled = isAnnotate;
        lbCanvas.classList.toggle("draw-on", !!drawEnabled);

        lb.classList.add("open");
        lb.setAttribute("aria-hidden","false");

        await new Promise((resolve) => {
          if (lbImg.complete) return resolve();
          lbImg.onload = () => resolve();
          lbImg.onerror = () => resolve();
        });

        const rr = await fetchRects(path).catch(() => ({ auto: [], manual: [] }));
        curAutoRects = rr.auto || [];
        curManualRects = rr.manual || [];
        // Загружаем информацию о персонах для подписей
        await loadRectsWithPersons();
        renderRectList();
        drawOverlay();
        
        // Обновляем подписи при изменении размера изображения
        if (lbImg) {
          const resizeObserver = new ResizeObserver(() => {
            if (curPath && curKind === "image") {
              drawOverlay();
            }
          });
          resizeObserver.observe(lbImg);
          // Сохраняем observer для очистки при закрытии
          if (!window.lbImgResizeObserver) {
            window.lbImgResizeObserver = resizeObserver;
          }
        }
      }

      function _lbTabSetActive(which) {
        [lbTabVideo, lbTabF1, lbTabF2, lbTabF3].forEach(b => {
          if (!b) return;
          b.classList.toggle("active", b === which);
        });
      }

      async function _ensureVideoFramesLoaded() {
        if (curVideoFrames) return curVideoFrames;
        const data = await fetchJson(`/api/faces/video-manual-frames?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(curPath)}`);
        curVideoFrames = data || { frames: [] };
        return curVideoFrames;
      }

      function _videoFrameObj(idx) {
        const arr = (curVideoFrames && Array.isArray(curVideoFrames.frames)) ? curVideoFrames.frames : [];
        return arr.find(x => Number(x?.frame_idx) === Number(idx)) || { frame_idx: idx, t_sec: null, rects: [] };
      }

      async function _showVideoTab() {
        curKind = "video";
        curVideoFrameIdx = 0;
        drawEnabled = false;
        lbCanvas.classList.remove("draw-on");
        lbMode.textContent = "видео";
        if (lbAnnotate) lbAnnotate.style.display = "none";
        lbClear.style.display = "none";
        lbSave.style.display = "none";
        curAutoRects = [];
        curManualRects = [];
        renderRectList();
        if (lbImg) lbImg.style.display = "none";
        if (lbVideo) {
          lbVideo.style.display = "";
          lbVideo.src = curVideoSrc || "";
        }
        drawOverlay();
      }

      async function _showVideoFrame(idx) {
        curKind = "video";
        curVideoFrameIdx = Number(idx);
        if (!(curVideoFrameIdx >= 1 && curVideoFrameIdx <= 3)) return;
        if (lbVideo) {
          try { lbVideo.pause(); } catch (e) {}
          lbVideo.style.display = "none";
        }
        if (lbImg) lbImg.style.display = "";
        // default mode: view (allow "Разметить")
        lbMode.textContent = "просмотр";
        if (lbAnnotate) lbAnnotate.style.display = "";
        lbClear.style.display = "none";
        lbSave.style.display = "none";
        drawEnabled = false;
        lbCanvas.classList.remove("draw-on");

        await _ensureVideoFramesLoaded().catch(() => ({ frames: [] }));
        const fr = _videoFrameObj(curVideoFrameIdx);
        curAutoRects = [];
        curManualRects = Array.isArray(fr.rects) ? fr.rects.map(r => ({ x:Number(r.x||0), y:Number(r.y||0), w:Number(r.w||0), h:Number(r.h||0) })) : [];

        const frameUrl = `/api/faces/video-frame?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(curPath)}&frame_idx=${encodeURIComponent(String(curVideoFrameIdx))}`;
        lbImg.referrerPolicy = "no-referrer";
        lbImg.draggable = false;
        lbImg.src = frameUrl;
        await new Promise((resolve) => {
          if (lbImg.complete) return resolve();
          lbImg.onload = () => resolve();
          lbImg.onerror = () => resolve();
        });
        // Загружаем информацию о персонах для подписей (для видео-кадров)
        await loadRectsWithPersons();
        renderRectList();
        drawOverlay();
      }

      async function openVideoViewer(path, src) {
        curKind = "video";
        curPath = path;
        curVideoSrc = src || "";
        curSrc = ""; // img preview is not used
        lbPath.textContent = path;
        if (lbTabs) lbTabs.style.display = "";

        lb.classList.add("open");
        lb.setAttribute("aria-hidden","false");

        curVideoFrames = null;
        await _ensureVideoFramesLoaded().catch(() => ({ frames: [] }));
        _lbTabSetActive(lbTabVideo);
        await _showVideoTab();
      }

      // Переключение "просмотр" -> "разметка" прямо в модалке
      if (lbAnnotate) {
        lbAnnotate.onclick = async () => {
          if (!curPath) return;
          // Для картинок нужен src. Для видео-кадров src = /api/faces/video-frame..., он уже стоит в lbImg.
          if (curKind === "image" && !curSrc) return;
          // Просто перевключаем UI-флаги, прямоугольники уже загружены в curAutoRects/curManualRects
          lbMode.textContent = "разметка";
          lbClear.style.display = "";
          lbSave.style.display = "";
          lbAnnotate.style.display = "none";
          drawEnabled = true;
          lbCanvas.classList.add("draw-on");
          drawOverlay();
          setToast("Режим разметки: потяни мышью по картинке, чтобы добавить прямоугольник.");
        };
      }

      function screenToNatural(pt) {
        const iw = lbImg.naturalWidth || 1;
        const ih = lbImg.naturalHeight || 1;
        const sx = iw / (lbImg.clientWidth || 1);
        const sy = ih / (lbImg.clientHeight || 1);
        return { x: pt.x * sx, y: pt.y * sy };
      }

      function getLocalPoint(e) {
        const rect = lbImg.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
        return { x, y };
      }

      function enableDrawingHandlers() {
        lbCanvas.onmousedown = (e) => {
          if (!drawEnabled) return;
          if (!(e instanceof MouseEvent)) return;
          e.preventDefault();
          dragging = true;
          dragStart = getLocalPoint(e);
          tempRect = null;
        };
        lbCanvas.onmousemove = (e) => {
          if (!drawEnabled || !dragging || !dragStart) return;
          e.preventDefault();
          const p = getLocalPoint(e);
          const x0 = Math.min(dragStart.x, p.x);
          const y0 = Math.min(dragStart.y, p.y);
          const w0 = Math.abs(dragStart.x - p.x);
          const h0 = Math.abs(dragStart.y - p.y);
          const n0 = screenToNatural({ x: x0, y: y0 });
          const n1 = screenToNatural({ x: x0 + w0, y: y0 + h0 });
          tempRect = { x: Math.round(n0.x), y: Math.round(n0.y), w: Math.round(n1.x - n0.x), h: Math.round(n1.y - n0.y) };
          drawOverlay();
        };
        lbCanvas.onmouseup = (e) => {
          if (!drawEnabled || !dragging) return;
          e.preventDefault();
          dragging = false;
          if (tempRect && tempRect.w >= 8 && tempRect.h >= 8) {
            curManualRects.push(tempRect);
            tempRect = null;
            renderRectList();
          } else {
            tempRect = null;
          }
          drawOverlay();
        };
      }
      enableDrawingHandlers();

      lbClear.onclick = () => {
        curManualRects = [];
        tempRect = null;
        renderRectList();
        drawOverlay();
      };
      lbSave.onclick = async () => {
        try {
          const savedPath = curPath;
          if (curKind === "video" && curVideoFrameIdx >= 1 && curVideoFrameIdx <= 3) {
            const fr = _videoFrameObj(curVideoFrameIdx);
            await postJson("/api/faces/video-manual-frame", {
              pipeline_run_id: Number(pipelineRunId),
              path: curPath,
              frame_idx: Number(curVideoFrameIdx),
              t_sec: fr?.t_sec ?? null,
              rects: curManualRects
            });
          } else {
            await postJson("/api/faces/manual-rectangles", { pipeline_run_id: Number(pipelineRunId), path: curPath, rects: curManualRects });
          }
          closeLb();
          // На вкладке "Нет людей" это потоковая операция: карточка должна уйти в "Люди" без прыжков списка.
          if (tab === "no_faces") {
            removeCardByPath(savedPath);
          }
          await refreshTabCounts();
          setToast("Сохранено.");
        } catch (e) {
          setToast(e?.message || String(e), true);
        }
      };

      async function openAnnotate(path, src) {
        if (!src) { setToast("Нет превью для разметки", true); return; }
        await openViewer(path, src, { mode: "annotate" });
      }

      // video tabs
      try {
        if (lbTabVideo) lbTabVideo.onclick = async () => { _lbTabSetActive(lbTabVideo); await _showVideoTab(); };
        if (lbTabF1) lbTabF1.onclick = async () => { _lbTabSetActive(lbTabF1); await _showVideoFrame(1); };
        if (lbTabF2) lbTabF2.onclick = async () => { _lbTabSetActive(lbTabF2); await _showVideoFrame(2); };
        if (lbTabF3) lbTabF3.onclick = async () => { _lbTabSetActive(lbTabF3); await _showVideoFrame(3); };
      } catch (e) {}

      // init from query
      const rid = getParam("pipeline_run_id");
      if (rid && /^\d+$/.test(rid)) pipelineRunId = Number(rid);
      qs("#prId").textContent = pipelineRunId != null ? String(pipelineRunId) : "—";
      // Управление доступностью кнопки "Переместить файлы в папки"
      const btnSort = qs("#btnSortIntoFolders");
      if (btnSort) {
        if (pipelineRunId != null) {
          btnSort.disabled = false;
          btnSort.style.display = "";
        } else {
          btnSort.disabled = true;
          btnSort.title = "Переместить файлы в папки (требуется pipeline_run_id)";
        }
      }
      applyTabUI();
      if (tab === "faces") {
        // Загружаем подзакладки асинхронно, не блокируя UI (не ждем завершения)
        loadPersonsSubtabs();
        // Обновляем выпадашки персон в карточках после загрузки подзакладок (используем кэш)
        if (subtab && subtab.startsWith("person_")) {
          // Загружаем асинхронно, не блокируя
          fetchPersonsWithFiles().then(async (personsData) => {
            try {
              const persons = personsData?.persons || [];
              await updatePersonSelects(persons);
            } catch (e) {
              console.error("Ошибка загрузки персон для выпадашек:", e);
            }
          });
        }
      } else if (tab === "no_faces") {
        loadGroupsSubtabs();
      }
      updateUrlParams();
      // open video modal directly (used by /gold "Кадры" button)
      try {
        const ovp = getParam("open_video_path");
        if (ovp && pipelineRunId != null && String(ovp).startsWith("local:")) {
          const src = `/api/local/preview?path=${encodeURIComponent(String(ovp))}&pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`;
          // small delay so modal elements are ready
          setTimeout(() => { openVideoViewer(String(ovp), src).catch(() => {}); }, 50);
        }
      } catch (e) {}
      // wire no_faces filters
      // no_faces filters removed
      // sentinel for infinite scroll
      const sentinel = document.createElement("div");
      sentinel.id = "sentinel";
      sentinel.className = "muted";
      sentinel.style.padding = "18px 0";
      sentinel.textContent = "…";
      qs("#grid").after(sentinel);
      let lastLoadTime = 0;
      const minLoadInterval = 500; // минимум 500мс между загрузками
      const io = new IntersectionObserver((entries) => {
        try {
          const e = entries && entries[0];
          if (e && e.isIntersecting) {
            const now = Date.now();
            if (!loading && hasMore && (now - lastLoadTime) >= minLoadInterval) {
              lastLoadTime = now;
              page += 1;
              load(false).catch(err => {
                console.error("[infinite-scroll] Ошибка загрузки:", err);
                setToast("Ошибка загрузки следующей страницы", true);
              });
            }
          }
        } catch (err) {
          console.error("[infinite-scroll] Ошибка в IntersectionObserver:", err);
        }
      }, { root: null, rootMargin: "200px 0px", threshold: 0.01 });
      io.observe(sentinel);

      // Делегирование событий для кнопок действий (один обработчик вместо тысяч)
      function _getPrevManualFromCard(cardEl) {
        const c = cardEl || {};
        const facesManual = (c.getAttribute?.("data-faces-manual") || "").toString().trim().toLowerCase();
        const qMan = Number(c.getAttribute?.("data-quarantine-manual") || 0);
        const pnfMan = Number(c.getAttribute?.("data-people-no-face-manual") || 0);
        const pnfPerson = (c.getAttribute?.("data-people-no-face-person") || "").toString() || "";
        const aMan = Number(c.getAttribute?.("data-animals-manual") || 0);
        const aManKind = (c.getAttribute?.("data-animals-manual-kind") || "").toString().trim().toLowerCase();
        if (pnfMan === 1) return { label: "people_no_face", person: (pnfPerson || null) };
        if (facesManual === "faces") return { label: "faces", person: null };
        if (facesManual === "no_faces") return { label: "no_faces", person: null };
        if (qMan === 1) return { label: "quarantine", person: null };
        if (aMan === 1) return { label: (aManKind === "cat" ? "cat" : "cat"), person: null };
        return { label: "", person: null };
      }
      function _pushUndo(state) {
        if (!window.__undoStack) window.__undoStack = [];
        if (state && state.path) {
          window.__undoStack.push(state);
          if (window.__undoStack.length > 10) window.__undoStack.shift();
        }
        const b = qs("#btnUndo");
        if (!b) return;
        b.style.display = (window.__undoStack && window.__undoStack.length > 0) ? "" : "none";
      }
      qs("#grid").addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-action]");
        if (!btn) return;
        const card = btn.closest(".card");
        const p = card?.getAttribute("data-path") || "";
        const action = btn.getAttribute("data-action");
        if (!p) return;
        try {
          const removeCard = () => removeCardByPath(p);
          if (action === "delete") {
            const res = await postJson("/api/faces/delete", { pipeline_run_id: Number(pipelineRunId), path: p });
            if (res.ok && res.undo_data) {
              _pushUndo({ action: "delete", path: res.undo_data.original_path, delete_path: res.undo_data.delete_path, undo_data: res.undo_data });
            }
            removeCard();
            await refreshTabCounts();
            setToast(`Файл удалён. Удалено из gold: ${res.removed_from_gold || 0} записей.`);
          } else if (action === "no_faces") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "no_faces" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            if (tab === "faces" || tab === "quarantine") { removeCard(); await refreshTabCounts(); } else { await load(true); }
          } else if (action === "mark_faces") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "faces" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            if (tab === "quarantine" || tab === "animals") { removeCard(); await refreshTabCounts(); } else { await load(true); }
          } else if (action === "not_animal_no_faces") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "not_animal_no_faces" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            if (tab === "animals") { removeCard(); await refreshTabCounts(); } else { await load(true); }
          } else if (action === "mark_cat") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "cat" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            if (tab === "faces" || tab === "quarantine" || tab === "no_faces") { removeCard(); await refreshTabCounts(); } else { await load(true); }
          } else if (action === "mark_quarantine") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "quarantine" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            if (tab === "faces") { removeCard(); await refreshTabCounts(); } else { await load(true); }
          } else if (action === "annotate_faces") {
            const thumb = card?.querySelector(".thumb[data-src]");
            const src = thumb?.getAttribute("data-src") || "";
            await openAnnotate(p, src);
          } else if (action === "people_no_face") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "people_no_face" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            removeCard();
            await refreshTabCounts();
          } else if (action === "assign_person" || action === "add_person") {
            const personIds = await showPersonDialog(p);
            if (personIds && personIds.length > 0) {
              // Назначаем персону файлу напрямую (file_persons)
              for (const personId of personIds) {
                await postJson("/api/persons/assign-file", {
                  pipeline_run_id: Number(pipelineRunId),
                  file_path: p,
                  person_id: personId
                });
              }
              _pushUndo({ action: "assign_person", path: p, person_ids: personIds });
              
              // Если мы на подзакладке персоны и добавляем еще одну персону - файл не удаляется с текущей подзакладки
              // Просто обновляем данные и подзакладки
              if (action === "add_person") {
                // Файл остается на текущей подзакладке, но также появляется на подзакладках новых персон
                await refreshTabCounts();
                await loadPersonsSubtabs(true); // Принудительная перезагрузка, т.к. изменились привязки
                if (personIds.length === 1) {
                  const person = allPersonsList.find(per => per.id === personIds[0]);
                  const personName = person ? (person.name || `Персона ${personIds[0]}`) : `Персона ${personIds[0]}`;
                  setToast(`Добавлена персона "${personName}". Файл будет виден на подзакладках всех назначенных персон.`);
                } else {
                  setToast(`Добавлено ${personIds.length} персон. Файл будет виден на подзакладках всех назначенных персон.`);
                }
              } else {
                // Обычное назначение - файл улетает с текущей подзакладки
                removeCard();
                await refreshTabCounts();
                await loadPersonsSubtabs(true); // Принудительная перезагрузка, т.к. изменились привязки
                if (personIds.length === 1) {
                  const person = allPersonsList.find(per => per.id === personIds[0]);
                  const personName = person ? (person.name || `Персона ${personIds[0]}`) : `Персона ${personIds[0]}`;
                  setToast(`Файл назначен персоне "${personName}".`);
                } else {
                  setToast(`Файл назначен ${personIds.length} персонам.`);
                }
              }
            }
          } else if (action === "assign_group") {
            const groupPath = await showGroupDialog(p);
            if (groupPath) {
              await postJson("/api/faces/assign-group", { pipeline_run_id: Number(pipelineRunId), path: p, group_path: groupPath });
              _pushUndo({ action: "assign_group", path: p, group_path: groupPath });
              removeCard();
              await refreshTabCounts();
              await loadGroupsSubtabs();
              setToast(`Файл назначен в группу "${groupPath}".`);
            }
          } else if (action === "not_person") {
            // Отвязываем файл от персоны (удаляем все привязки к этой персоне)
            const personId = parseInt(btn.getAttribute("data-person-id") || "0");
            if (!personId) {
              setToast("Не указан ID персоны", true);
              return;
            }
            
            try {
              // Удаляем привязки через face_labels (для всех лиц на фото)
              const rectsData = await fetchJson(`/api/faces/rectangles?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(p)}`).catch(() => ({ rectangles: [] }));
              const rects = rectsData?.rectangles || [];
              
              for (const rect of rects) {
                if (rect.person_id === personId && rect.id) {
                  // Удаляем face_label для этого лица
                  invalidatePersonsCache();
                  await postJson("/api/persons/remove-assignment", {
                    assignment_type: "face",
                    face_rectangle_id: rect.id,
                    person_id: personId
                  }).catch(() => {}); // Игнорируем ошибки, если привязки нет
                }
              }
              
              // Удаляем прямую привязку через file_persons
              await postJson("/api/persons/remove-assignment", {
                assignment_type: "file",
                pipeline_run_id: Number(pipelineRunId),
                file_path: p,
                person_id: personId
              }).catch(() => {}); // Игнорируем ошибки, если привязки нет
              
              // Файл улетает с текущей подзакладки
              removeCard();
              await refreshTabCounts();
              await loadPersonsSubtabs(true); // Принудительная перезагрузка, т.к. изменились привязки
              
              const person = allPersonsList.find(per => per.id === personId);
              const personName = person ? (person.name || `Персона ${personId}`) : `Персона ${personId}`;
              setToast(`Файл отвязан от персоны "${personName}".`);
            } catch (e) {
              setToast(e?.message || String(e), true);
            }
          } else if (action === "reset") {
            const prev = _getPrevManualFromCard(card);
            await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "" });
            _pushUndo({ action: "manual_label", path: p, prev_label: prev.label, prev_person: prev.person });
            removeCard();
            await refreshTabCounts();
          } else if (action === "not_person") {
            const personId = parseInt(btn.getAttribute("data-person-id") || "0");
            if (!personId) return;
            
            // Удаляем привязку файла к персоне
            try {
              await postJson("/api/persons/remove-assignment", {
                assignment_type: "file",
                pipeline_run_id: Number(pipelineRunId),
                file_path: p,
                person_id: personId
              });
              
              removeCard();
              await refreshTabCounts();
              await loadPersonsSubtabs(true); // Принудительная перезагрузка, т.к. изменились привязки
              setToast("Привязка к персоне удалена.");
            } catch (e) {
              setToast(e?.message || String(e), true);
            }
          }
        } catch (e) {
          setToast(e?.message || String(e), true);
        }
      });
      
      // Обработчик двойного клика на прямоугольник для назначения персоны
      if (rectList) {
        rectList.addEventListener("dblclick", async (e) => {
          const pill = e.target.closest(".rectpill");
          if (!pill) return;
          
          const rectId = pill.getAttribute("data-rect-id");
          const rectIndex = parseInt(pill.getAttribute("data-rect-index") || "0");
          const currentPersonId = pill.getAttribute("data-person-id");
          
          if (!rectId || !curPath || !pipelineRunId) return;
          
          // Показываем диалог выбора персоны
          const personIds = await showPersonDialog(curPath);
          if (personIds && personIds.length > 0) {
            // Назначаем персону лицу
            for (const personId of personIds) {
              try {
                invalidatePersonsCache();
                await postJson("/api/faces/assign-face-person", {
                  pipeline_run_id: Number(pipelineRunId),
                  face_rectangle_id: parseInt(rectId),
                  person_id: parseInt(personId)
                });
              } catch (e) {
                setToast(e?.message || String(e), true);
                return;
              }
            }
            
            // Инвалидируем кэш персон
            invalidatePersonsCache();
            // Инвалидируем кэш персон на файле
            const cacheKey = `${pipelineRunId}:${curPath}`;
            personsOnFileCache.delete(cacheKey);
            
            // Обновляем информацию о прямоугольниках
            await loadRectsWithPersons();
            renderRectList();
            drawOverlay();
            
            // Обновляем список персон на фото в карточке
            await loadPersonsOnFile(curPath);
            
            const person = allPersonsList.find(per => per.id === personIds[0]);
            const personName = person ? (person.name || `Персона ${personIds[0]}`) : `Персона ${personIds[0]}`;
            setToast(`Прямоугольник #${rectIndex + 1} назначен персоне "${personName}".`);
          }
        });
      }
      // Делегирование для двойного клика по превью - используем новую карточку фотографий
      qs("#grid").addEventListener("dblclick", async (e) => {
        const thumb = e.target.closest(".thumb[data-kind='image'][data-src]");
        if (!thumb) return;
        const p = thumb.getAttribute("data-path") || "";
        const src = thumb.getAttribute("data-src") || "";
        if (!p || !src) return;
        
        // Формируем list_context из текущих данных
        const cards = Array.from(qs("#grid").querySelectorAll(".card[data-path]"));
        const currentCard = cards.find(card => card.getAttribute("data-path") === p);
        const currentIndex = currentCard ? cards.indexOf(currentCard) : 0;
        
        // Получаем file_id из данных карточки (если есть)
        const fileIdAttr = currentCard?.getAttribute("data-file-id");
        const fileId = fileIdAttr ? parseInt(fileIdAttr) : null;
        
        // Формируем items для list_context
        const items = cards.map((card, idx) => {
          const cardPath = card.getAttribute("data-path") || "";
          const cardFileId = card.getAttribute("data-file-id");
          return {
            file_id: cardFileId ? parseInt(cardFileId) : null,
            file_path: cardPath,
            face_rectangle_id: null,
            person_rectangle_id: null
          };
        });
        
        // Формируем list_context
        const listContext = {
          source_page: "faces",
          items: items,
          current_index: currentIndex,
          total_count: total || items.length,
          api_fallback: {
            endpoint: "/api/faces/results",
            params: {
              pipeline_run_id: pipelineRunId,
              tab: tab,
              subtab: subtab,
              sort: sort,
              from: fromTs,
              to: toTs,
              page_size: 60
            }
          }
        };
        
        // Открываем карточку фотографий
        if (window.openPhotoCard) {
          window.openPhotoCard({
            file_id: fileId,
            file_path: p,
            pipeline_run_id: pipelineRunId,
            list_context: listContext
          });
        } else {
          // Fallback на старый viewer, если новый модуль не загружен
          await openViewer(p, src, { mode: "view" });
        }
      });
      // Делегирование для кнопки кадров видео
      qs("#grid").addEventListener("click", async (e) => {
        const btn = e.target.closest("button.vfbtn[data-act='frames']");
        if (!btn) return;
        try { e.preventDefault(); e.stopPropagation(); } catch (ee) {}
        const p = btn.getAttribute("data-path") || "";
        const src = btn.getAttribute("data-src") || "";
        if (!p || !src) return;
        await openVideoViewer(p, src);
      });

      // Инициализация обработчиков модального окна персон
      const checkboxMultiplePersonsEl = qs("#checkboxMultiplePersons");
      if (checkboxMultiplePersonsEl) {
        checkboxMultiplePersonsEl.addEventListener("change", (e) => {
          updatePersonModalMode(e.target.checked);
        });
      }
      
      const inputNewPersonEl = qs("#inputNewPersonName");
      if (inputNewPersonEl) {
        inputNewPersonEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            assignSelectedPerson();
          } else if (e.key === "Escape") {
            e.preventDefault();
            closePersonModal();
          }
        });
      }
      
      const inputNewPersonMultipleEl = qs("#inputNewPersonNameMultiple");
      if (inputNewPersonMultipleEl) {
        inputNewPersonMultipleEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            assignSelectedPerson();
          } else if (e.key === "Escape") {
            e.preventDefault();
            closePersonModal();
          }
        });
      }
      
      // Закрытие модального окна персон по клику вне его
      const modalPersonEl = qs("#modalPerson");
      if (modalPersonEl) {
        modalPersonEl.addEventListener("click", (e) => {
          if (e.target === modalPersonEl) {
            closePersonModal();
          }
        });
      }
      
      // Инициализация обработчиков модального окна группы
      const inputNewGroupEl = qs("#inputNewGroupPath");
      if (inputNewGroupEl) {
        inputNewGroupEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            assignSelectedGroup();
          } else if (e.key === "Escape") {
            e.preventDefault();
            closeGroupModal();
          }
        });
      }
      
      // Закрытие модального окна по клику вне его
      const modalGroupEl = qs("#modalGroup");
      if (modalGroupEl) {
        modalGroupEl.addEventListener("click", (e) => {
          if (e.target === modalGroupEl) {
            closeGroupModal();
          }
        });
      }
      
      refreshTabCounts();
      load(true);

      // Undo (последние несколько действий)
      qs("#btnUndo").onclick = async () => {
        if (!window.__undoStack || window.__undoStack.length === 0) return;
        const st = window.__undoStack.pop(); // Берём последнее действие
        if (!st || !st.path) {
          if (window.__undoStack.length === 0) {
            qs("#btnUndo").style.display = "none";
          }
          return;
        }
        try {
          qs("#btnUndo").disabled = true;
          if (st.action === "delete") {
            // Откат удаления: восстанавливаем файл из _delete
            const undoData = st.undo_data;
            if (!undoData || !undoData.delete_path || !undoData.original_path) {
              setToast("Недостаточно данных для отката удаления", true);
              return;
            }
            // Перемещаем файл обратно
            const res = await postJson("/api/faces/restore-from-delete", {
              pipeline_run_id: Number(pipelineRunId),
              delete_path: undoData.delete_path,
              original_path: undoData.original_path,
              original_name: undoData.original_name,
              original_parent_path: undoData.original_parent_path,
            });
            if (res.ok) {
              // Сначала сбрасываем все manual labels
              await postJson("/api/faces/manual-label", {
                pipeline_run_id: Number(pipelineRunId),
                path: undoData.original_path,
                label: "",
              });
              // Затем восстанавливаем manual labels в правильном порядке
              if (undoData.original_people_no_face_manual) {
                await postJson("/api/faces/manual-label", {
                  pipeline_run_id: Number(pipelineRunId),
                  path: undoData.original_path,
                  label: "people_no_face",
                  person: undoData.original_people_no_face_person || "",
                });
              } else if (undoData.original_faces_manual_label) {
                await postJson("/api/faces/manual-label", {
                  pipeline_run_id: Number(pipelineRunId),
                  path: undoData.original_path,
                  label: undoData.original_faces_manual_label,
                });
              }
              if (undoData.original_quarantine_manual) {
                await postJson("/api/faces/manual-label", {
                  pipeline_run_id: Number(pipelineRunId),
                  path: undoData.original_path,
                  label: "quarantine",
                });
              }
              if (undoData.original_animals_manual) {
                await postJson("/api/faces/manual-label", {
                  pipeline_run_id: Number(pipelineRunId),
                  path: undoData.original_path,
                  label: "cat",
                });
              }
              setToast("Undo: файл восстановлен из _delete.");
            } else {
              setToast(`Ошибка восстановления: ${res.detail || "unknown"}`, true);
            }
          } else if (st.action === "manual_label") {
            // Откат manual label
            const payload = { pipeline_run_id: Number(pipelineRunId), path: String(st.path), label: String(st.prev_label || "") };
            if (String(st.prev_label || "") === "people_no_face" && st.prev_person) {
              payload.person = String(st.prev_person);
            }
            await postJson("/api/faces/manual-label", payload);
            setToast("Undo: откатил последнее действие.");
          }
          if (window.__undoStack.length === 0) {
            qs("#btnUndo").style.display = "none";
          }
          await refreshTabCounts();
          await load(true);
        } catch (e) {
          setToast(e?.message || String(e), true);
        } finally {
          qs("#btnUndo").disabled = false;
        }
      };

      // Sort into folders
      qs("#btnSortIntoFolders").onclick = async () => {
        if (pipelineRunId == null) {
          setToast("pipeline_run_id не задан", true);
          return;
        }
        if (!confirm("Переместить файлы в папки по категориям?\n\nШаг 1: _non_media, _broken_media\nШаг 3: _faces, _quarantine, _animals, _people_no_face, _no_faces\n\nЭто действие переместит файлы на YaDisk (или локально) в соответствующие папки.")) {
          return;
        }
        try {
          qs("#btnSortIntoFolders").disabled = true;
          setToast("Сортировка файлов...");
          const payload = { pipeline_run_id: Number(pipelineRunId), dry_run: false };
          const resp = await postJson("/api/faces/sort-into-folders", payload);
          if (resp.ok) {
            const moved = resp.moved_count || 0;
            const errors = resp.errors || [];
            if (errors.length > 0) {
              setToast(`Перенесено: ${moved}, ошибок: ${errors.length}`, true);
              console.error("Sort errors:", errors);
            } else {
              setToast(`Успешно перенесено файлов: ${moved}`);
            }
            await refreshTabCounts();
            await load(true);
          } else {
            setToast("Ошибка при сортировке", true);
          }
        } catch (e) {
          setToast(e?.message || String(e), true);
        } finally {
          qs("#btnSortIntoFolders").disabled = false;
        }
      };
    </script>
    
    <!-- Подключение единой карточки фотографий -->
    <!-- Включаем photo_card.html напрямую -->
    <div class="photo-card-modal" id="photoCardModal" aria-hidden="true" style="display: none;">
      <div class="photo-card-panel" role="dialog" aria-modal="true">
        <div class="photo-card-top">
          <code class="photo-card-path" id="photoCardPath">—</code>
          <div class="photo-card-actions">
            <span class="pill" id="photoCardMode">просмотр</span>
            <button class="btn" id="photoCardToggleRectangles" type="button">Скрыть прямоугольники</button>
            <button class="btn" id="photoCardUndo" type="button" style="display:none;" title="Отменить последнее действие">Undo</button>
            <button class="btn" id="photoCardClose" type="button">Закрыть</button>
          </div>
        </div>
        <div class="photo-card-tabs" id="photoCardTabs" style="display:none;">
          <button class="lb-tab" id="photoCardTabVideo" type="button">Видео</button>
          <button class="lb-tab" id="photoCardTabF1" type="button">Кадр 1</button>
          <button class="lb-tab" id="photoCardTabF2" type="button">Кадр 2</button>
          <button class="lb-tab" id="photoCardTabF3" type="button">Кадр 3</button>
        </div>
        <div class="photo-card-body">
          <div class="imgwrap" id="photoCardImgWrap">
            <img id="photoCardImg" alt="preview" />
            <video id="photoCardVideo" controls preload="metadata" style="display:none;"></video>
            <canvas id="photoCardCanvas"></canvas>
          </div>
        </div>
        <div class="photo-card-navigation" id="photoCardNavigation" style="display:none;">
          <button class="btn" id="photoCardPrev" type="button">←</button>
          <span class="photo-card-position" id="photoCardPosition">1 из 1</span>
          <button class="btn" id="photoCardNext" type="button">→</button>
        </div>
        <div class="photo-card-bottom">
          <div class="muted">Прямоугольники:</div>
          <div class="rectlist" id="photoCardRectList"></div>
          <div id="photoCardSpecialActions" style="display:none; margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
            <button class="btn" id="photoCardAssignOutsider" type="button">Все остальные - посторонние</button>
            <button class="btn danger" id="photoCardMarkAsCat" type="button">Это кот</button>
            <button class="btn danger" id="photoCardMarkAsNoPeople" type="button">Нет людей</button>
          </div>
        </div>
      </div>
    </div>
    <div class="photo-card-modal" id="photoCardPersonModal" aria-hidden="true" style="display: none;">
      <div class="photo-card-panel" role="dialog" aria-modal="true" style="max-width: 500px;">
        <div class="photo-card-top">
          <div style="font-weight:700;">Назначить персону</div>
          <button class="btn" id="photoCardPersonModalClose" type="button" style="padding:4px 8px;">✕</button>
        </div>
        <div style="padding: 16px;">
          <div style="margin-bottom:12px; font-weight:700;">Выберите персону:</div>
          <select id="photoCardSelectPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:16px;">
            <option value="">Выберите персону...</option>
          </select>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <div style="margin-bottom:8px; font-weight:700;">Или создайте новую:</div>
            <input type="text" id="photoCardInputNewPersonName" placeholder="Имя персоны" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:8px;" />
          </div>
          <button class="btn" id="photoCardAssignPerson" type="button" style="width:100%; margin-top:16px;">Назначить</button>
        </div>
        <div class="photo-card-bottom" style="justify-content:flex-end;">
          <button class="btn" id="photoCardPersonModalCancel" type="button">Отмена</button>
        </div>
      </div>
    </div>
    <style>
      .photo-card-modal { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .photo-card-modal[aria-hidden="false"] { display: flex; }
      .photo-card-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(1200px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); display: flex; flex-direction: column; }
      .photo-card-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .photo-card-top code { font-size: 11px; }
      .photo-card-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .photo-card-tabs { display:flex; gap:8px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; background:#f9fafb; flex-wrap:wrap; }
      .photo-card-body { background: #111827; display: flex; align-items: center; justify-content: center; padding: 10px; flex: 1; overflow: auto; }
      .photo-card-navigation { display: flex; align-items: center; justify-content: center; gap: 12px; padding: 10px 12px; border-top: 1px solid #e5e7eb; border-bottom: 1px solid #e5e7eb; background: #f9fafb; }
      .photo-card-position { font-weight: 700; font-size: 14px; }
      .photo-card-bottom { padding: 10px 12px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
      .photo-card-rectangle { position: absolute; pointer-events: auto; cursor: pointer; z-index: 1000; }
      .photo-card-rectangle-label { position: absolute; pointer-events: none; white-space: nowrap; max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    </style>
    <script src="/static/photo_card.js?v=2"></script>
  </body>
</html>


