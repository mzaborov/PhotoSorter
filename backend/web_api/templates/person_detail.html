<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Персона</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1400px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin-bottom:20px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.primary { background:#111827; color:#fff; border-color:#111827; }
      .btn.primary:hover { background:#374151; }
      .btn.small { padding:4px 8px; font-size:12px; }
      .thumb-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap:12px; margin-top:16px; }
      .thumb { width: 100%; aspect-ratio: 1; background:#fff; display:flex; align-items:center; justify-content:center; border:1px solid #e5e7eb; border-radius:8px; overflow:hidden; cursor: pointer; position:relative; }
      .thumb img { width: 100%; height: 100%; object-fit: cover; }
      .thumb .noimg { color:#6b7280; font-size:11px; text-align:center; padding:8px; }
      .thumb:hover { border-color:#0b57d0; }
      .thumb .face-actions { position:absolute; bottom:4px; left:4px; right:4px; display:none; gap:4px; flex-wrap:wrap; }
      .thumb:hover .face-actions { display:flex; }
      .thumb .face-btn { background:rgba(0,0,0,0.8); color:#fff; border:none; border-radius:4px; padding:4px 6px; font-size:10px; cursor:pointer; flex:1; min-width:0; }
      .thumb .face-btn:hover { background:rgba(0,0,0,0.95); }
      .thumb.avatar { border:3px solid #0b57d0; }
      .info-section { background:#f9fafb; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:20px; }
      .info-section h3 { margin:0 0 12px 0; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; font-size:13px; }
      .loading { opacity: 0.6; pointer-events: none; }
      .form-group { margin-bottom:12px; }
      .form-group label { display:block; margin-bottom:4px; font-weight:700; }
      .form-group input { width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; }
      /* Lightbox */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 92vw; max-height: 92vh; width: min(1200px, 92vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; position: relative; }
      .lb-body img { max-width: 92vw; max-height: calc(92vh - 56px); width: auto; height: auto; display: block; object-fit: contain; background: #111827; }
      .lb-rectangle { position: absolute; border: 3px solid #0b57d0; pointer-events: none; box-shadow: 0 0 0 2px rgba(11, 87, 208, 0.3); z-index: 1001; }
      .lb-rectangle.other { border-color: #fbbf24; box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.3); z-index: 1000; pointer-events: auto; cursor: pointer; }
      .lb-rectangle-label { 
        position: absolute; 
        background: rgba(251, 191, 36, 0.95); 
        color: #111827; 
        padding: 3px 8px; 
        font-size: 12px; 
        font-weight: 700; 
        border-radius: 4px; 
        white-space: nowrap; 
        z-index: 10001; 
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(251, 191, 36, 1);
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .lb-rectangle-label:hover {
        background: rgba(251, 191, 36, 1);
        cursor: pointer;
      }
      /* Modal */
      .modal { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .modal.show { display: flex; }
      .modal-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(500px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .modal-header { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display:flex; justify-content:space-between; align-items:center; }
      .modal-body { padding: 16px; max-height: calc(94vh - 120px); overflow-y: auto; }
      .modal-footer { padding: 12px 16px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; justify-content:flex-end; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <div>
          <h2 style="margin:0; display:flex; align-items:center; gap:12px;">
            <span id="personName">Загрузка...</span>
            <span id="personAvatar" style="display:none;"></span>
          </h2>
          <div class="muted" style="margin-top:6px;" id="personInfo">Загрузка...</div>
        </div>
        <div>
          <a href="/persons" class="muted">← к списку персон</a> · 
          <a href="/persons/{{ person_id }}/clusters" class="muted">Кластеры персоны</a>
        </div>
      </div>

      <div class="info-section">
        <h3>Управление персоной</h3>
        <div class="form-group">
          <label>Имя персоны:</label>
          <div style="display:flex; gap:8px;">
            <input type="text" id="inputPersonName" placeholder="Имя персоны" />
            <button class="btn primary" id="btnUpdateName" type="button">Сохранить</button>
          </div>
        </div>
        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn primary" id="btnSaveToGold" type="button">Сохранить в gold</button>
        </div>
      </div>

      <div>
        <h3>Все лица персоны (<span id="facesCount">-</span>)</h3>
        <div class="muted" style="margin-top:6px;">Двойной клик на лицо — открыть полную фотографию</div>
        <div class="thumb-grid" id="facesGrid"></div>
      </div>
    </div>

    <!-- Lightbox для просмотра полной фотографии -->
    <div class="lb" id="lightbox">
      <div class="lb-panel">
        <div class="lb-top">
          <div class="muted"><code id="lbPath"></code></div>
          <div style="display:flex; gap:10px; align-items:center;">
            <a id="lbOpen" class="pill" href="#" target="_blank" rel="noopener noreferrer" style="display:none;">Открыть</a>
            <button class="btn" id="lbFixClipping" type="button" style="display:none;" title="Пересчитать координаты bbox с исправленным клиппингом">Исправить клипинг</button>
            <button class="btn" type="button" onclick="closeLightbox()">Закрыть</button>
          </div>
        </div>
        <div class="lb-body" id="lbBody">
          <img id="lbImg" alt="preview" />
          <div id="lbRectangle" class="lb-rectangle"></div>
        </div>
      </div>
    </div>

    <!-- Modal для переназначения лица -->
    <div class="modal" id="modalReassign">
      <div class="modal-panel">
        <div class="modal-header">
          <h3 style="margin:0;">Переназначить лицо</h3>
          <button class="btn" type="button" onclick="closeModal('modalReassign')">✕</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Выберите персону:</label>
            <select id="selectReassignPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px;">
              <option value="">Загрузка...</option>
            </select>
          </div>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <button class="btn" type="button" onclick="clearFaceAssignment()" style="width:100%;">Очистить (найти ближайший кластер)</button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn" type="button" onclick="closeModal('modalReassign')">Отмена</button>
          <button class="btn primary" type="button" onclick="confirmReassign()">Переназначить</button>
        </div>
      </div>
    </div>

    <script>
      const personId = {{ person_id }};
      let personData = null;
      let allPersons = [];
      let currentReassignFaceId = null;
      let currentFaceBbox = null; // Bbox текущего отображаемого лица
      let currentFaceId = null; // ID текущего отображаемого лица
      let currentFilePath = null; // Путь к текущему файлу для исправления клиппинга
      let allFacesOnImage = []; // Все лица на текущем изображении
      let isDrawingFaces = false; // Флаг для предотвращения множественных вызовов drawAllFaceRectangles

      function showToast(msg, isError = false) {
        alert(msg);
      }

      async function loadPerson() {
        try {
          const resp = await fetch(`/api/persons/${personId}`);
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
          }
          personData = await resp.json();
          
          // Обновляем заголовок
          document.getElementById('personName').textContent = personData.person.name;
          document.getElementById('inputPersonName').value = personData.person.name;
          
          // Загружаем аватар если есть
          if (personData.person.avatar_face_id) {
            const avatarUrl = await getFaceThumbnail(personData.person.avatar_face_id);
            if (avatarUrl) {
              const avatarEl = document.getElementById('personAvatar');
              avatarEl.innerHTML = `<img src="${avatarUrl}" alt="Avatar" style="width:48px; height:48px; object-fit:cover; border-radius:50%; border:2px solid #0b57d0;" />`;
              avatarEl.style.display = 'block';
            }
          }
          
          // Обновляем информацию
          const facesCount = personData.faces.length;
          document.getElementById('facesCount').textContent = facesCount;
          document.getElementById('personInfo').textContent = `${facesCount} лиц`;
          
          // Рендерим лица
          renderFaces();
        } catch (e) {
          console.error('Ошибка загрузки персоны:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function getFaceThumbnail(faceId) {
        try {
          const resp = await fetch(`/api/face-rectangles/${faceId}/thumbnail`);
          if (!resp.ok) return null;
          const data = await resp.json();
          if (data.thumb_jpeg_base64) {
            return `data:image/jpeg;base64,${data.thumb_jpeg_base64}`;
          }
        } catch (e) {
          console.error('Ошибка загрузки thumbnail:', e);
        }
        return null;
      }

      async function renderFaces() {
        const grid = document.getElementById('facesGrid');
        if (!personData || !personData.faces) {
          grid.innerHTML = '<div class="muted">Нет лиц</div>';
          return;
        }
        
        const faces = personData.faces;
        if (faces.length === 0) {
          grid.innerHTML = '<div class="muted">Нет лиц</div>';
          return;
        }
        
        grid.innerHTML = await Promise.all(faces.map(async (face) => {
          const thumbUrl = face.thumb_jpeg_base64 ? 
            `data:image/jpeg;base64,${face.thumb_jpeg_base64}` : null;
          
          const isAvatar = personData.person.avatar_face_id === face.face_id;
          const avatarClass = isAvatar ? ' avatar' : '';
          
          const escapedPath = (face.file_path || '').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
          const bboxJson = face.bbox ? JSON.stringify(face.bbox).replace(/"/g, '&quot;') : '';
          return `
            <div class="thumb${avatarClass}" data-face-id="${face.face_id}" data-file-path="${escapedPath}" data-bbox="${bboxJson}" ondblclick="handleFaceDoubleClick(this)">
              ${thumbUrl ? `<img src="${thumbUrl}" alt="Face ${face.face_id}" />` : '<div class="noimg">Нет превью</div>'}
              <div class="face-actions">
                <button class="face-btn" onclick="event.stopPropagation(); ignoreFace(${face.face_id})" title="Это не лицо">Не лицо</button>
                <button class="face-btn" onclick="event.stopPropagation(); reassignFace(${face.face_id})" title="Это другой человек">Другой</button>
                <button class="face-btn" onclick="event.stopPropagation(); setAvatar(${face.face_id})" title="Назначить аватаром" ${isAvatar ? 'disabled' : ''}>Аватар</button>
              </div>
            </div>
          `;
        })).then(html => html.join(''));
      }

      function handleFaceDoubleClick(element) {
        const faceId = parseInt(element.getAttribute('data-face-id'));
        const filePath = element.getAttribute('data-file-path');
        const bboxStr = element.getAttribute('data-bbox');
        let bboxData = null;
        if (bboxStr) {
          try {
            bboxData = JSON.parse(bboxStr.replace(/&quot;/g, '"'));
          } catch (e) {
            console.error('Ошибка парсинга bbox:', e);
          }
        }
        
        openFaceImage(faceId, filePath, bboxData);
      }

      function openFaceImage(faceId, filePath, bboxData) {
        // Находим информацию о лице
        const faces = personData?.faces || [];
        const face = faces.find(f => f.face_id === faceId);
        if (!face) {
          return;
        }
        
        const path = face.file_path || filePath;
        currentFilePath = path; // Сохраняем путь для исправления клиппинга
        const lb = document.getElementById('lightbox');
        const lbPath = document.getElementById('lbPath');
        const lbImg = document.getElementById('lbImg');
        const lbOpen = document.getElementById('lbOpen');
        const lbRectangle = document.getElementById('lbRectangle');
        const lbFixClipping = document.getElementById('lbFixClipping');
        
        // Показываем кнопку "Исправить клипинг" только для изображений (не для видео)
        if (lbFixClipping) {
          lbFixClipping.style.display = (path && !path.match(/\.(mp4|mov|avi|mkv|webm|m4v|3gp)$/i)) ? '' : 'none';
        }
        
        if (lbPath) lbPath.textContent = path;
        
        // Сохраняем faceId и bbox для отрисовки
        currentFaceId = faceId;
        if (bboxData && typeof bboxData === 'object') {
          currentFaceBbox = bboxData;
        } else if (face && face.bbox) {
          currentFaceBbox = face.bbox;
        } else {
          currentFaceBbox = null;
        }
        
        
        // Убеждаемся, что currentFaceBbox установлен
        if (!currentFaceBbox) {
          console.error('openFaceImage: ОШИБКА - currentFaceBbox не установлен!', {
            bboxData,
            faceBbox: face?.bbox,
            faceId: face?.face_id
          });
        }
        
        // Проверяем наличие размеров изображения и EXIF orientation, загружаем их, если нужно
        const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
        const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
        if (!hasImageSize || (!hasExifOrientation && path)) {
          // Загружаем размеры изображения и сохраняем в БД
          fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
            .then(res => res.json())
            .then(data => {
              if (data.ok && data.width && data.height) {
                // Обновляем размеры в personData для текущего лица
                if (face) {
                  face.image_size = { 
                    width: data.width, 
                    height: data.height,
                    exif_orientation: data.exif_orientation || null
                  };
                }
                // Перерисовываем rectangles с новыми размерами
                if (lbImg && lbImg.complete) {
                  drawAllFaceRectangles();
                }
              }
            })
            .catch(err => {
              console.error('Failed to load image dimensions:', err);
            });
        }
        
        // Скрываем rectangle до загрузки изображения
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
        
        // Определяем URL для превью
        let previewUrl = '';
        let openUrl = '';
        
        if (path.startsWith('disk:')) {
          previewUrl = `/api/yadisk/preview-image?size=XL&path=${encodeURIComponent(path)}`;
          openUrl = `/api/yadisk/open?path=${encodeURIComponent(path)}`;
        } else if (path.startsWith('local:')) {
          previewUrl = `/api/local/preview?path=${encodeURIComponent(path)}`;
          openUrl = '#';
        }
        
        if (lbOpen) {
          if (openUrl && openUrl !== '#') {
            lbOpen.href = openUrl;
            lbOpen.style.display = 'inline-block';
          } else {
            lbOpen.style.display = 'none';
          }
        }
        
        // Открываем lightbox сразу, не дожидаясь загрузки изображения
        openLightbox();
        
        // Загружаем все лица на этом фото
        fetch(`/api/file-faces?file_path=${encodeURIComponent(path)}`)
          .then(res => res.json())
          .then(data => {
            allFacesOnImage = data.faces || [];
            // Данные о лицах загружены, но изображение может еще не загрузиться
            // tryDrawAllFaces будет вызван из onload, когда изображение точно загрузится
            // Но если изображение уже загружено, вызываем сразу
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              drawAllFaceRectangles();
            }
          })
          .catch(err => {
            console.error('Failed to load faces on image:', err);
            allFacesOnImage = [];
            // Даже если ошибка, пытаемся нарисовать текущее лицо, если изображение уже загружено
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              drawAllFaceRectangles();
            }
          });
        
        // Загружаем изображение
        if (lbImg && previewUrl) {
          // Устанавливаем обработчик onload
          lbImg.onload = function() {
            // Проверяем, что элементы действительно готовы в DOM
            const checkAndDraw = () => {
              const lbImgCheck = document.getElementById('lbImg');
              const lbBodyCheck = document.getElementById('lbBody');
              if (lbImgCheck && lbBodyCheck && lbImgCheck.complete) {
                // Теперь изображение точно загружено, рисуем rectangles (если данные о лицах уже загружены)
                if (allFacesOnImage !== undefined) {
                  drawAllFaceRectangles();
                }
              } else {
                requestAnimationFrame(checkAndDraw);
              }
            };
            
            // Используем requestAnimationFrame для гарантии, что DOM обновлен
            requestAnimationFrame(() => {
              requestAnimationFrame(checkAndDraw);
            });
            
            // Если размеры еще не загружены, пытаемся их получить
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      drawAllFaceRectangles();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      drawAllFaceRectangles();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                      drawAllFaceRectangles();
                    });
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawAllFaceRectangles();
              });
            }
          };
          
          // Если изображение уже загружено и это тот же URL, не перезагружаем
          if (lbImg.src !== previewUrl && !lbImg.src.includes(previewUrl)) {
            lbImg.src = previewUrl;
          } else if (lbImg.complete) {
            // Изображение уже загружено, проверяем размеры и рисуем rectangle
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            
            // Функция для отрисовки после проверки данных о лицах
            const drawWhenReady = () => {
              if (allFacesOnImage !== undefined) {
                drawAllFaceRectangles();
              }
            };
            
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    drawWhenReady();
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawWhenReady();
              });
            }
          }
        }
      }

      function openLightbox() {
        document.getElementById('lightbox').classList.add('open');
      }
      
      function drawAllFaceRectangles() {
        // Защита от множественных вызовов
        if (isDrawingFaces) {
          return;
        }
        isDrawingFaces = true;
        
        try {
          // Сначала рисуем остальные лица (желтые rectangles с подписями)
          // Синий rectangle нарисуем в конце, чтобы он был поверх желтых
          const lbImg = document.getElementById('lbImg');
          const lbBody = document.getElementById('lbBody');
          
          // Детальная диагностика
          if (!lbImg) {
            console.error('drawAllFaceRectangles: lbImg не найден', {
              lightboxExists: !!document.getElementById('lightbox'),
              lightboxOpen: document.getElementById('lightbox')?.classList.contains('open')
            });
            return;
          }
          if (!lbBody) {
            console.error('drawAllFaceRectangles: lbBody не найден', {
              lightboxExists: !!document.getElementById('lightbox'),
              lightboxOpen: document.getElementById('lightbox')?.classList.contains('open'),
              lbBodyElements: document.querySelectorAll('.lb-body').length,
              allLbBodyIds: Array.from(document.querySelectorAll('[id*="lb"]')).map(el => el.id)
            });
            return;
          }
          if (!lbImg.complete) {
            console.error('drawAllFaceRectangles: lbImg.complete === false', {
              src: lbImg.src,
              naturalWidth: lbImg.naturalWidth,
              naturalHeight: lbImg.naturalHeight,
              width: lbImg.width,
              height: lbImg.height
            });
            return;
          }
        // Если currentFaceBbox не установлен, пытаемся получить из personData
        if (!currentFaceBbox && currentFaceId) {
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          if (face && face.bbox) {
            currentFaceBbox = face.bbox;
          }
        }
        
        // Удаляем старые желтые rectangles (но НЕ основной синий rectangle #lbRectangle)
        const oldRects = lbBody.querySelectorAll('.lb-rectangle.other, .lb-rectangle-label:not(.current)');
        oldRects.forEach(el => el.remove());
        
        // Если данные о лицах еще не загружены (undefined), не рисуем ничего
        // Если данные загружены, но лиц нет - рисуем только текущее лицо
        if (allFacesOnImage === undefined) {
          return;
        }
        
        // Если нет других лиц, просто рисуем текущее лицо
        if (allFacesOnImage.length === 0) {
          drawFaceRectangle();
          return;
        }
          
          // Получаем размеры изображения
          const imgRect = lbImg.getBoundingClientRect();
          const imgNaturalWidth = lbImg.naturalWidth;
          const imgNaturalHeight = lbImg.naturalHeight;
          const imgDisplayWidth = imgRect.width;
          const imgDisplayHeight = imgRect.height;
          
          if (imgNaturalWidth === 0 || imgNaturalHeight === 0) {
            return;
          }
          
          // Получаем размеры исходного изображения для масштабирования
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          const originalImageSize = face?.image_size;
          
          // Если размеры исходного изображения еще не получены, не рисуем желтые квадраты
          // Они будут нарисованы после получения размеров
          if (!originalImageSize || !originalImageSize.width || !originalImageSize.height) {
            drawFaceRectangle();
            return;
          }
        
        // Рисуем каждое лицо (кроме текущего)
        for (const otherFace of allFacesOnImage) {
          // Сравниваем как числа и как строки
          const otherFaceIdNum = Number(otherFace.face_id);
          const currentFaceIdNum = Number(currentFaceId);
          const isCurrent = otherFaceIdNum === currentFaceIdNum || 
                           otherFace.face_id === currentFaceId;
          
          if (isCurrent) {
            continue; // Пропускаем текущее лицо (оно будет нарисовано синим в конце)
          }
          
          let bboxX = otherFace.bbox.x;
          let bboxY = otherFace.bbox.y;
          let bboxW = otherFace.bbox.w;
          let bboxH = otherFace.bbox.h;
          
          // Масштабируем координаты
          if (originalImageSize && originalImageSize.width && originalImageSize.height) {
            const originalWidth = originalImageSize.width;
            const originalHeight = originalImageSize.height;
            const exifOrientation = originalImageSize.exif_orientation;
            const originalRatio = originalWidth / originalHeight;
            const previewRatio = imgNaturalWidth / imgNaturalHeight;
            const isRotated90 = Math.abs(originalRatio - 1/previewRatio) < 0.1;
            
            if (isRotated90 && exifOrientation) {
              const scaleX = imgNaturalWidth / originalHeight;
              const scaleY = imgNaturalHeight / originalWidth;
              
              if (exifOrientation === 6) {
                const tempX = bboxX;
                const tempW = bboxW;
                bboxX = bboxY * scaleX;
                bboxY = (originalWidth - tempX - tempW) * scaleY;
                bboxW = bboxH * scaleX;
                bboxH = tempW * scaleY;
              } else if (exifOrientation === 8) {
                const tempX = bboxX;
                const tempW = bboxW;
                bboxX = (originalHeight - bboxY - bboxH) * scaleX;
                bboxY = tempX * scaleY;
                bboxW = bboxH * scaleX;
                bboxH = tempW * scaleY;
              } else if (exifOrientation === 3) {
                const scaleX2 = imgNaturalWidth / originalWidth;
                const scaleY2 = imgNaturalHeight / originalHeight;
                bboxX = (originalWidth - bboxX - bboxW) * scaleX2;
                bboxY = (originalHeight - bboxY - bboxH) * scaleY2;
                bboxW = bboxW * scaleX2;
                bboxH = bboxH * scaleY2;
              } else {
                const scaleX2 = imgNaturalWidth / originalWidth;
                const scaleY2 = imgNaturalHeight / originalHeight;
                bboxX = bboxX * scaleX2;
                bboxY = bboxY * scaleY2;
                bboxW = bboxW * scaleX2;
                bboxH = bboxH * scaleY2;
              }
            } else {
              const scaleX = imgNaturalWidth / originalWidth;
              const scaleY = imgNaturalHeight / originalHeight;
              bboxX = bboxX * scaleX;
              bboxY = bboxY * scaleY;
              bboxW = bboxW * scaleX;
              bboxH = bboxH * scaleY;
            }
          } else if (bboxX >= imgNaturalWidth || bboxY >= imgNaturalHeight || (bboxX + bboxW) > imgNaturalWidth || (bboxY + bboxH) > imgNaturalHeight) {
            const originalWidth = Math.max(bboxX + bboxW, imgNaturalWidth);
            const originalHeight = Math.max(bboxY + bboxH, imgNaturalHeight);
            const scaleX = imgNaturalWidth / originalWidth;
            const scaleY = imgNaturalHeight / originalHeight;
            bboxX = bboxX * scaleX;
            bboxY = bboxY * scaleY;
            bboxW = bboxW * scaleX;
            bboxH = bboxH * scaleY;
          }
          
          // Ограничиваем границы
          bboxX = Math.max(0, Math.min(bboxX, imgNaturalWidth));
          bboxY = Math.max(0, Math.min(bboxY, imgNaturalHeight));
          if (bboxX + bboxW > imgNaturalWidth) {
            bboxW = Math.max(1, imgNaturalWidth - bboxX);
          }
          if (bboxY + bboxH > imgNaturalHeight) {
            bboxH = Math.max(1, imgNaturalHeight - bboxY);
          }
          bboxW = Math.max(1, Math.min(bboxW, imgNaturalWidth - bboxX));
          bboxH = Math.max(1, Math.min(bboxH, imgNaturalHeight - bboxY));
          
          // Масштабируем к отображаемому размеру
          const scaleX = imgDisplayWidth / imgNaturalWidth;
          const scaleY = imgDisplayHeight / imgNaturalHeight;
          const rectX = bboxX * scaleX;
          const rectY = bboxY * scaleY;
          const rectW = bboxW * scaleX;
          const rectH = bboxH * scaleY;
          
          // Позиционируем относительно body
          const bodyRect = lbBody.getBoundingClientRect();
          const left = (imgRect.left - bodyRect.left) + rectX;
          const top = (imgRect.top - bodyRect.top) + rectY;
          
          // Создаем желтый rectangle
          const rect = document.createElement('div');
          rect.className = 'lb-rectangle other';
          rect.style.left = `${left}px`;
          rect.style.top = `${top}px`;
          rect.style.width = `${rectW}px`;
          rect.style.height = `${rectH}px`;
          rect.style.display = 'block';
          rect.style.position = 'absolute';
          rect.style.zIndex = '1000';
          rect.style.cursor = 'pointer';
          rect.style.pointerEvents = 'auto';
          
          // Добавляем клик для перехода к кластеру или назначения персоны
          if (otherFace.cluster_id) {
            rect.onclick = function(e) {
              e.stopPropagation();
              const clusterUrl = `/face-clusters/${otherFace.cluster_id}`;
              window.open(clusterUrl, '_blank');
            };
            rect.title = (otherFace.person_name || '') + (otherFace.cluster_id ? ` | Кластер #${otherFace.cluster_id} (клик для открытия)` : '');
          }
          
          lbBody.appendChild(rect);
          
          // Добавляем подпись с именем персоны (если назначена)
          const labelText = otherFace.person_name 
            ? (otherFace.person_name + (otherFace.is_me ? ' (я)' : ''))
            : (otherFace.cluster_id ? `Кластер #${otherFace.cluster_id}` : 'Не назначено');
          
          const label = document.createElement('div');
          label.className = 'lb-rectangle-label';
          label.textContent = labelText;
          label.style.left = `${left}px`;
          label.style.top = `${top - 20}px`;
          label.style.position = 'absolute';
          label.style.zIndex = '10001';
          label.style.pointerEvents = 'none';
          if (otherFace.cluster_id) {
            label.style.cursor = 'pointer';
            label.onclick = function(e) {
              e.stopPropagation();
              const clusterUrl = `/face-clusters/${otherFace.cluster_id}`;
              window.open(clusterUrl, '_blank');
            };
          }
          lbBody.appendChild(label);
        }
        
          // В конце рисуем текущее лицо (синий rectangle) поверх желтых
          drawFaceRectangle();
        } finally {
          isDrawingFaces = false;
        }
      }

      function drawFaceRectangle() {
        // Всегда пытаемся получить bbox из personData, если currentFaceBbox не установлен
        if (!currentFaceBbox && currentFaceId) {
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          if (face && face.bbox) {
            currentFaceBbox = face.bbox;
          } else {
            return;
          }
        }
        
        if (!currentFaceBbox) {
          return;
        }
        
        const lbImg = document.getElementById('lbImg');
        const lbRectangle = document.getElementById('lbRectangle');
        if (!lbImg || !lbRectangle) {
          return;
        }
        
        if (!lbImg.complete) {
          return;
        }
        
        // Получаем реальные размеры отображаемого изображения
        const imgRect = lbImg.getBoundingClientRect();
        const imgNaturalWidth = lbImg.naturalWidth;
        const imgNaturalHeight = lbImg.naturalHeight;
        const imgDisplayWidth = imgRect.width;
        const imgDisplayHeight = imgRect.height;
        
        // Проверяем, что изображение загружено и имеет правильные размеры
        if (imgNaturalWidth === 0 || imgNaturalHeight === 0) {
          // Скрываем rectangle до получения правильных размеров
          if (lbRectangle) {
            lbRectangle.style.display = 'none';
          }
          // Удаляем надпись, если она уже была создана
          const lbBody = lbImg.parentElement;
          if (lbBody) {
            const oldLabel = lbBody.querySelector('.lb-rectangle-label.current');
            if (oldLabel) oldLabel.remove();
          }
          return;
        }
        
        // Проверяем, что отображаемые размеры тоже правильные
        if (imgDisplayWidth === 0 || imgDisplayHeight === 0) {
          // Скрываем rectangle до получения правильных размеров
          if (lbRectangle) {
            lbRectangle.style.display = 'none';
          }
          // Удаляем надпись, если она уже была создана
          const lbBody = lbImg.parentElement;
          if (lbBody) {
            const oldLabel = lbBody.querySelector('.lb-rectangle-label.current');
            if (oldLabel) oldLabel.remove();
          }
          return;
        }
        
        // Масштабируем bbox координаты от исходного изображения к preview
        let bboxX = currentFaceBbox.x;
        let bboxY = currentFaceBbox.y;
        let bboxW = currentFaceBbox.w;
        let bboxH = currentFaceBbox.h;
        
        // Получаем размеры исходного изображения из данных лица
        const face = personData?.faces?.find(f => f.face_id === currentFaceId);
        const originalImageSize = face?.image_size;
        
        // Если размеры исходного изображения еще не получены, скрываем rectangle и надпись, выходим
        // Размеры будут получены из API и rectangle будет перерисован
        if (!originalImageSize || !originalImageSize.width || !originalImageSize.height) {
          if (lbRectangle) {
            lbRectangle.style.display = 'none';
          }
          // Удаляем надпись, если она уже была создана
          const lbBody = lbImg.parentElement;
          if (lbBody) {
            const oldLabel = lbBody.querySelector('.lb-rectangle-label.current');
            if (oldLabel) oldLabel.remove();
          }
          return;
        }
        
        // Если есть размеры исходного изображения и они отличаются от preview, масштабируем
        if (originalImageSize && originalImageSize.width && originalImageSize.height) {
          const originalWidth = originalImageSize.width;
          const originalHeight = originalImageSize.height;
          const exifOrientation = originalImageSize.exif_orientation;
          const originalRatio = originalWidth / originalHeight;
          const previewRatio = imgNaturalWidth / imgNaturalHeight;
          const isRotated90 = Math.abs(originalRatio - 1/previewRatio) < 0.1;
          
          if (isRotated90 && exifOrientation) {
            const scaleX = imgNaturalWidth / originalHeight;
            const scaleY = imgNaturalHeight / originalWidth;
            
            if (exifOrientation === 6) {
              const tempX = bboxX;
              const tempW = bboxW;
              bboxX = bboxY * scaleX;
              bboxY = (originalWidth - tempX - tempW) * scaleY;
              bboxW = bboxH * scaleX;
              bboxH = tempW * scaleY;
            } else if (exifOrientation === 8) {
              const tempX = bboxX;
              const tempW = bboxW;
              bboxX = (originalHeight - bboxY - bboxH) * scaleX;
              bboxY = tempX * scaleY;
              bboxW = bboxH * scaleX;
              bboxH = tempW * scaleY;
            } else if (exifOrientation === 3) {
              const scaleX2 = imgNaturalWidth / originalWidth;
              const scaleY2 = imgNaturalHeight / originalHeight;
              bboxX = (originalWidth - bboxX - bboxW) * scaleX2;
              bboxY = (originalHeight - bboxY - bboxH) * scaleY2;
              bboxW = bboxW * scaleX2;
              bboxH = bboxH * scaleY2;
            } else {
              const scaleX2 = imgNaturalWidth / originalWidth;
              const scaleY2 = imgNaturalHeight / originalHeight;
              bboxX = bboxX * scaleX2;
              bboxY = bboxY * scaleY2;
              bboxW = bboxW * scaleX2;
              bboxH = bboxH * scaleY2;
            }
          } else {
            const scaleX = imgNaturalWidth / originalWidth;
            const scaleY = imgNaturalHeight / originalHeight;
            bboxX = bboxX * scaleX;
            bboxY = bboxY * scaleY;
            bboxW = bboxW * scaleX;
            bboxH = bboxH * scaleY;
          }
        } else if (bboxX >= imgNaturalWidth || bboxY >= imgNaturalHeight || (bboxX + bboxW) > imgNaturalWidth || (bboxY + bboxH) > imgNaturalHeight) {
          const originalWidth = Math.max(bboxX + bboxW, imgNaturalWidth);
          const originalHeight = Math.max(bboxY + bboxH, imgNaturalHeight);
          const scaleX = imgNaturalWidth / originalWidth;
          const scaleY = imgNaturalHeight / originalHeight;
          bboxX = bboxX * scaleX;
          bboxY = bboxY * scaleY;
          bboxW = bboxW * scaleX;
          bboxH = bboxH * scaleY;
        }
        
        // Убеждаемся, что bbox координаты не выходят за границы preview
        bboxX = Math.max(0, Math.min(bboxX, imgNaturalWidth));
        bboxY = Math.max(0, Math.min(bboxY, imgNaturalHeight));
        if (bboxX + bboxW > imgNaturalWidth) {
          bboxW = Math.max(1, imgNaturalWidth - bboxX);
        }
        if (bboxY + bboxH > imgNaturalHeight) {
          bboxH = Math.max(1, imgNaturalHeight - bboxY);
        }
        bboxW = Math.max(1, Math.min(bboxW, imgNaturalWidth - bboxX));
        bboxH = Math.max(1, Math.min(bboxH, imgNaturalHeight - bboxY));
        
        // Вычисляем масштаб от preview к отображаемому размеру
        const scaleX = imgDisplayWidth / imgNaturalWidth;
        const scaleY = imgDisplayHeight / imgNaturalHeight;
        
        // Вычисляем позицию и размер rectangle на отображаемом изображении
        const rectX = bboxX * scaleX;
        const rectY = bboxY * scaleY;
        const rectW = bboxW * scaleX;
        const rectH = bboxH * scaleY;
        
        // Позиционируем rectangle относительно изображения
        const lbBody = lbImg.parentElement;
        if (!lbBody) {
          return;
        }
        
        const bodyRect = lbBody.getBoundingClientRect();
        
        // Удаляем старую подпись для синего rectangle (если есть)
        const oldLabel = lbBody.querySelector('.lb-rectangle-label.current');
        if (oldLabel) oldLabel.remove();
        
        const left = (imgRect.left - bodyRect.left) + rectX;
        const top = (imgRect.top - bodyRect.top) + rectY;
        
        // Сначала показываем rectangle
        lbRectangle.style.left = left + 'px';
        lbRectangle.style.top = top + 'px';
        lbRectangle.style.width = rectW + 'px';
        lbRectangle.style.height = rectH + 'px';
        lbRectangle.style.display = 'block';
        
        // Только после того, как rectangle показан, добавляем подпись
        // Это гарантирует, что надпись не появится раньше rectangle
        const currentPerson = personData?.person;
        const labelText = currentPerson?.name 
          ? (currentPerson.name + (currentPerson.is_me ? ' (я)' : ''))
          : 'Не назначено';
        
        const label = document.createElement('div');
        label.className = 'lb-rectangle-label current';
        label.textContent = labelText;
        label.style.left = `${left}px`;
        label.style.top = `${top - 20}px`;
        label.style.position = 'absolute';
        label.style.zIndex = '10002';
        label.style.pointerEvents = 'none';
        label.style.background = 'rgba(11, 87, 208, 0.95)';
        label.style.color = '#fff';
        label.style.padding = '3px 8px';
        label.style.fontSize = '12px';
        label.style.fontWeight = '700';
        label.style.borderRadius = '4px';
        label.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
        label.style.border = '1px solid rgba(11, 87, 208, 1)';
        label.style.whiteSpace = 'nowrap';
        lbBody.appendChild(label);
      }

      function closeLightbox() {
        document.getElementById('lightbox').classList.remove('open');
        currentFaceBbox = null;
        const lbRectangle = document.getElementById('lbRectangle');
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
      }

      // Закрытие lightbox по клику вне изображения или Escape
      document.addEventListener('click', (e) => {
        const lb = document.getElementById('lightbox');
        if (lb && e.target === lb) {
          closeLightbox();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeLightbox();
        }
      });

      // Перерисовка rectangles при изменении размера окна
      window.addEventListener('resize', () => {
        if (document.getElementById('lightbox').classList.contains('open')) {
          drawAllFaceRectangles();
        }
      });

      async function updatePersonName() {
        const newName = document.getElementById('inputPersonName').value.trim();
        if (!newName) {
          showToast('Имя не может быть пустым', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка обновления имени');
          }
          
          showToast('Имя обновлено');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка обновления имени:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function saveToGold() {
        const btn = document.getElementById('btnSaveToGold');
        if (!btn) return;
        
        btn.disabled = true;
        btn.textContent = 'Сохранение...';
        
        try {
          const resp = await fetch(`/api/persons/${personId}/save-to-gold`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          });
          
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data.detail || data.error || 'Ошибка сохранения');
          }
          
          showToast(`Сохранено в gold: ${data.faces_count} лиц, ${data.files_updated} файлов`, false);
        } catch (e) {
          showToast(`Ошибка: ${e.message}`, true);
        } finally {
          btn.disabled = false;
          btn.textContent = 'Сохранить в gold';
        }
      }


      async function ignoreFace(faceId) {
        if (!confirm('Пометить это лицо как "не лицо"?')) {
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${faceId}/ignore`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо помечено как "не лицо"');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function reassignFace(faceId) {
        currentReassignFaceId = faceId;
        
        // Загружаем список персон
        try {
          const resp = await fetch('/api/persons/list');
          if (!resp.ok) throw new Error('Не удалось загрузить список персон');
          const data = await resp.json();
          allPersons = data.persons || [];
          
          // Загружаем похожие лица
          const similarResp = await fetch(`/api/persons/${personId}/faces/${faceId}/similar?limit=3`);
          let similarFaces = [];
          if (similarResp.ok) {
            const similarData = await similarResp.json();
            similarFaces = similarData.similar_faces || [];
          }
          
          // Заполняем выпадашку
          const select = document.getElementById('selectReassignPerson');
          select.innerHTML = '<option value="">Выберите персону...</option>';
          
          // Добавляем 3 ближайших по embeddings
          if (similarFaces.length > 0) {
            select.innerHTML += '<optgroup label="Ближайшие по embeddings:">';
            for (const sf of similarFaces) {
              if (sf.person_id && sf.person_id !== personId) {
                const person = allPersons.find(p => p.id === sf.person_id);
                if (person) {
                  select.innerHTML += `<option value="${sf.person_id}">${person.name} (расстояние: ${sf.distance.toFixed(3)})</option>`;
                }
              }
            }
            select.innerHTML += '</optgroup>';
          }
          
          // Добавляем всех персон
          select.innerHTML += '<optgroup label="Все персоны:">';
          for (const p of allPersons) {
            if (p.id !== personId && !p.is_ignored) {
              select.innerHTML += `<option value="${p.id}">${p.name}${p.is_me ? ' (я)' : ''}</option>`;
            }
          }
          select.innerHTML += '</optgroup>';
          
          openModal('modalReassign');
        } catch (e) {
          console.error('Ошибка загрузки данных:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function confirmReassign() {
        const targetPersonId = document.getElementById('selectReassignPerson').value;
        if (!targetPersonId) {
          showToast('Выберите персону', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/reassign`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target_person_id: parseInt(targetPersonId) }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка переназначения');
          }
          
          showToast('Лицо переназначено');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка переназначения:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function clearFaceAssignment() {
        if (!confirm('Удалить лицо из текущей персоны и найти ближайший кластер?')) {
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/clear`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо удалено из персоны');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function setAvatar(faceId) {
        try {
          const resp = await fetch(`/api/persons/${personId}/set-avatar`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ face_id: faceId }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка установки аватара');
          }
          
          showToast('Аватар установлен');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка установки аватара:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      function openModal(modalId) {
        document.getElementById(modalId).classList.add('show');
      }

      function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('show');
      }

      // Обработчик кнопки "Исправить клипинг"
      async function handleFixClipping() {
        if (!currentFilePath) {
          showToast('Нет пути к файлу', true);
          return;
        }
        
        // Получаем face_run_id из первого лица персоны (все лица персоны должны быть из одного run)
        const firstFace = personData?.faces?.[0];
        if (!firstFace || !firstFace.face_run_id) {
          showToast('Не найден run_id для исправления клиппинга', true);
          return;
        }
        
        const btn = document.getElementById('lbFixClipping');
        if (!btn) {
          return;
        }
        
        try {
          btn.disabled = true;
          const resp = await fetch('/api/faces/fix-clipping', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              face_run_id: Number(firstFace.face_run_id),
              path: currentFilePath,
            }),
          });
          
          if (!resp.ok) {
            let errorDetail = '';
            try {
              const errorJson = await resp.json();
              errorDetail = errorJson.detail || errorJson.error || JSON.stringify(errorJson);
            } catch {
              const errorText = await resp.text();
              errorDetail = errorText || `HTTP ${resp.status}`;
            }
            showToast(`Ошибка ${resp.status}: ${errorDetail}`, true);
            return;
          }
          
          const res = await resp.json();
          if (res.ok) {
            // Сохраняем текущие данные для обновления после перезагрузки
            const savedFaceId = currentFaceId;
            const savedFilePath = currentFilePath;
            
            // Перезагружаем персону, чтобы обновить bbox в отображении
            await loadPerson();
            
            // Если lightbox открыт, принудительно переоткрываем его
            if (savedFaceId) {
              const faceEl = document.querySelector(`[data-face-id="${savedFaceId}"]`);
              if (faceEl) {
                // Обновляем bbox из обновлённого personData перед переоткрытием
                const faces = personData?.faces || [];
                const face = faces.find(f => f.face_id === savedFaceId);
                if (face && face.bbox) {
                  const bboxJson = JSON.stringify(face.bbox).replace(/"/g, '&quot;');
                  faceEl.setAttribute('data-bbox', bboxJson);
                }
                handleFaceDoubleClick(faceEl);
              }
            }
          } else {
            const errorMsg = res.detail || 'Ошибка пересчёта';
            showToast(errorMsg, true);
          }
        } catch (e) {
          const errorMsg = e?.message || String(e);
          showToast('Ошибка: ' + errorMsg, true);
        } finally {
          btn.disabled = false;
        }
      }

      // Инициализация
      document.getElementById('btnUpdateName').addEventListener('click', updatePersonName);
      document.getElementById('btnSaveToGold').addEventListener('click', saveToGold);
      document.getElementById('inputPersonName').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') updatePersonName();
      });
      
      // Обработчик кнопки "Исправить клипинг"
      const btnFixClipping = document.getElementById('lbFixClipping');
      if (btnFixClipping) {
        btnFixClipping.onclick = handleFixClipping;
      }
      
      loadPerson();
    </script>
  </body>
</html>
