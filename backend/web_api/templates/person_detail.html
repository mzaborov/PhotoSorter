<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Персона</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1400px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin-bottom:20px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.primary { background:#111827; color:#fff; border-color:#111827; }
      .btn.primary:hover { background:#374151; }
      .btn.small { padding:4px 8px; font-size:12px; }
      .thumb-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap:12px; margin-top:16px; }
      .thumb { width: 100%; aspect-ratio: 1; background:#fff; display:flex; align-items:center; justify-content:center; border:1px solid #e5e7eb; border-radius:8px; overflow:hidden; cursor: pointer; position:relative; }
      .thumb img { width: 100%; height: 100%; object-fit: cover; }
      .thumb .noimg { color:#6b7280; font-size:11px; text-align:center; padding:8px; }
      .thumb:hover { border-color:#0b57d0; }
      .thumb .face-actions { position:absolute; bottom:4px; left:4px; right:4px; display:none; gap:4px; flex-wrap:wrap; }
      .thumb:hover .face-actions { display:flex; }
      .thumb .face-btn { background:rgba(0,0,0,0.8); color:#fff; border:none; border-radius:4px; padding:4px 6px; font-size:10px; cursor:pointer; flex:1; min-width:0; }
      .thumb .face-btn:hover { background:rgba(0,0,0,0.95); }
      .thumb.avatar { border:3px solid #0b57d0; }
      .info-section { background:#f9fafb; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:20px; }
      .info-section h3 { margin:0 0 12px 0; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; font-size:13px; }
      .loading { opacity: 0.6; pointer-events: none; }
      .form-group { margin-bottom:12px; }
      .form-group label { display:block; margin-bottom:4px; font-weight:700; }
      .form-group input { width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; }
      /* Lightbox */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 92vw; max-height: 92vh; width: min(1200px, 92vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; position: relative; }
      .lb-body img { max-width: 92vw; max-height: calc(92vh - 56px); width: auto; height: auto; display: block; object-fit: contain; background: #111827; }
      .lb-rectangle { position: absolute; border: 3px solid #0b57d0; pointer-events: none; box-shadow: 0 0 0 2px rgba(11, 87, 208, 0.3); z-index: 1001; }
      .lb-rectangle.other { border-color: #fbbf24; box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.3); z-index: 1000; pointer-events: auto; cursor: pointer; }
      .lb-rectangle-label { 
        position: absolute; 
        background: rgba(251, 191, 36, 0.95); 
        color: #111827; 
        padding: 3px 8px; 
        font-size: 12px; 
        font-weight: 700; 
        border-radius: 4px; 
        white-space: nowrap; 
        z-index: 10001; 
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(251, 191, 36, 1);
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .lb-rectangle-label:hover {
        background: rgba(251, 191, 36, 1);
        cursor: pointer;
      }
      /* Modal */
      .modal { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .modal.show { display: flex; }
      .modal-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(500px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .modal-header { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display:flex; justify-content:space-between; align-items:center; }
      .modal-body { padding: 16px; max-height: calc(94vh - 120px); overflow-y: auto; }
      .modal-footer { padding: 12px 16px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; justify-content:flex-end; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <div>
          <h2 style="margin:0; display:flex; align-items:center; gap:12px;">
            <span id="personName">Загрузка...</span>
            <span id="personAvatar" style="display:none;"></span>
          </h2>
          <div class="muted" style="margin-top:6px;" id="personInfo">Загрузка...</div>
        </div>
        <div>
          <a href="/persons" class="muted">← к списку персон</a> · 
          <a href="/persons/{{ person_id }}/clusters" class="muted">Кластеры персоны</a>
        </div>
      </div>

      <div class="info-section">
        <h3>Управление персоной</h3>
        <div class="form-group">
          <label>Имя персоны:</label>
          <div style="display:flex; gap:8px;">
            <input type="text" id="inputPersonName" placeholder="Имя персоны" />
            <button class="btn primary" id="btnUpdateName" type="button">Сохранить</button>
          </div>
        </div>
        <div class="form-group" style="margin-top:12px;">
          <label>Группа:</label>
          <div style="display:flex; gap:8px;">
            <select id="selectPersonGroup" style="flex:1; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px;">
              <option value="">Без группы</option>
              <option value="Я и Супруга">Я и Супруга</option>
              <option value="Дети">Дети</option>
              <option value="Родственники">Родственники</option>
              <option value="Синяя диагональ">Синяя диагональ</option>
              <option value="Работа">Работа</option>
            </select>
            <button class="btn primary" id="btnUpdateGroup" type="button">Сохранить</button>
          </div>
        </div>
        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn primary" id="btnSaveToGold" type="button">Сохранить в gold</button>
        </div>
      </div>

      <div>
        <h3>Все лица персоны (<span id="facesCount">-</span>)</h3>
        <div class="muted" style="margin-top:6px;">Двойной клик на лицо — открыть полную фотографию</div>
        <div id="facesGridContainer">
          <div id="facesGridArchive" style="margin-bottom:24px;">
            <h4 style="margin:0 0 12px 0; font-size:16px; font-weight:600; color:#1f2937;">Архив</h4>
            <div class="thumb-grid" id="facesGridArchiveContent"></div>
          </div>
          <div id="facesGridRun">
            <h4 style="margin:0 0 12px 0; font-size:16px; font-weight:600; color:#1f2937;">Текущий прогон</h4>
            <div class="thumb-grid" id="facesGridRunContent"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Lightbox для просмотра полной фотографии -->
    <div class="lb" id="lightbox">
      <div class="lb-panel">
        <div class="lb-top">
          <div class="muted"><code id="lbPath"></code></div>
          <div style="display:flex; gap:10px; align-items:center;">
            <a id="lbOpen" class="pill" href="#" target="_blank" rel="noopener noreferrer" style="display:none;">Открыть</a>
            <button class="btn" id="lbFixClipping" type="button" style="display:none;" title="Пересчитать координаты bbox с исправленным клиппингом">Исправить клипинг</button>
            <button class="btn" type="button" onclick="closeLightbox()">Закрыть</button>
          </div>
        </div>
        <div class="lb-body" id="lbBody">
          <img id="lbImg" alt="preview" />
          <div id="lbRectangle" class="lb-rectangle"></div>
        </div>
      </div>
    </div>

    <!-- Modal для переназначения лица -->
    <div class="modal" id="modalReassign">
      <div class="modal-panel">
        <div class="modal-header">
          <h3 style="margin:0;">Переназначить лицо</h3>
          <button class="btn" type="button" onclick="closeModal('modalReassign')">✕</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Выберите персону:</label>
            <select id="selectReassignPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px;">
              <option value="">Загрузка...</option>
            </select>
          </div>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <button class="btn" type="button" onclick="clearFaceAssignment()" style="width:100%;">Очистить (найти ближайший кластер)</button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn" type="button" onclick="closeModal('modalReassign')">Отмена</button>
          <button class="btn primary" type="button" onclick="confirmReassign()">Переназначить</button>
        </div>
      </div>
    </div>

    <script src="/static/face_rectangles_viewer.js"></script>
    <script>
      const personId = {{ person_id }};
      let personData = null;
      let allPersons = [];
      let currentReassignFaceId = null;
      let currentFaceBbox = null; // Bbox текущего отображаемого лица
      let currentFaceId = null; // ID текущего отображаемого лица
      let currentFilePath = null; // Путь к текущему файлу для исправления клиппинга
      let allFacesOnImage = []; // Все лица на текущем изображении
      let isDrawingFaces = false; // Флаг для предотвращения множественных вызовов drawAllFaceRectangles
      
      // Сохраняем ссылку на функцию из модуля ПЕРЕД любыми переопределениями
      // Проверяем сразу после загрузки скрипта
      let drawAllFaceRectanglesFromModule = null;
      let drawFaceRectangleFromModule = null;
      
      // Пробуем получить функции из глобальной области видимости
      if (typeof drawAllFaceRectangles !== 'undefined') {
        drawAllFaceRectanglesFromModule = drawAllFaceRectangles;
        console.log('Module loaded: drawAllFaceRectangles found', typeof drawAllFaceRectangles);
      } else {
        console.warn('Module not loaded: drawAllFaceRectangles is undefined');
      }
      
      if (typeof drawFaceRectangle !== 'undefined') {
        drawFaceRectangleFromModule = drawFaceRectangle;
        console.log('Module loaded: drawFaceRectangle found', typeof drawFaceRectangle);
      } else {
        console.warn('Module not loaded: drawFaceRectangle is undefined');
      }
      
      // Проверяем, что модуль загрузился
      if (!drawAllFaceRectanglesFromModule || !drawFaceRectangleFromModule) {
        console.error('face_rectangles_viewer.js module not loaded!', {
          drawAllFaceRectangles: typeof drawAllFaceRectangles,
          drawFaceRectangle: typeof drawFaceRectangle
        });
      }

      function showToast(msg, isError = false) {
        alert(msg);
      }

      async function loadPerson() {
        try {
          const resp = await fetch(`/api/persons/${personId}`);
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
          }
          personData = await resp.json();
          
          // Обновляем заголовок
          document.getElementById('personName').textContent = personData.person.name;
          document.getElementById('inputPersonName').value = personData.person.name;
          
          // Обновляем группу
          const groupSelect = document.getElementById('selectPersonGroup');
          if (groupSelect) {
            groupSelect.value = personData.person.group || '';
          }
          
          // Загружаем аватар если есть
          if (personData.person.avatar_face_id) {
            const avatarUrl = await getFaceThumbnail(personData.person.avatar_face_id);
            if (avatarUrl) {
              const avatarEl = document.getElementById('personAvatar');
              avatarEl.innerHTML = `<img src="${avatarUrl}" alt="Avatar" style="width:48px; height:48px; object-fit:cover; border-radius:50%; border:2px solid #0b57d0;" />`;
              avatarEl.style.display = 'block';
            }
          }
          
          // Обновляем информацию с разделением на архив и текущий прогон
          const facesCount = personData.faces.length;
          const facesArchive = personData.faces.filter(f => f.is_archive).length;
          const facesRun = personData.faces.filter(f => f.is_run).length;
          document.getElementById('facesCount').textContent = facesCount;
          document.getElementById('personInfo').textContent = `${facesCount} лиц (Архив: ${facesArchive}, Прогон: ${facesRun})`;
          
          // Рендерим лица
          renderFaces();
        } catch (e) {
          console.error('Ошибка загрузки персоны:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function getFaceThumbnail(faceId) {
        try {
          const resp = await fetch(`/api/face-rectangles/${faceId}/thumbnail`);
          if (!resp.ok) return null;
          const data = await resp.json();
          if (data.thumb_jpeg_base64) {
            return `data:image/jpeg;base64,${data.thumb_jpeg_base64}`;
          }
        } catch (e) {
          console.error('Ошибка загрузки thumbnail:', e);
        }
        return null;
      }

      async function renderFaces() {
        const archiveGrid = document.getElementById('facesGridArchiveContent');
        const runGrid = document.getElementById('facesGridRunContent');
        const archiveSection = document.getElementById('facesGridArchive');
        const runSection = document.getElementById('facesGridRun');
        
        if (!personData || !personData.faces) {
          archiveGrid.innerHTML = '<div class="muted">Нет лиц</div>';
          runGrid.innerHTML = '<div class="muted">Нет лиц</div>';
          return;
        }
        
        const faces = personData.faces;
        if (faces.length === 0) {
          archiveGrid.innerHTML = '<div class="muted">Нет лиц</div>';
          runGrid.innerHTML = '<div class="muted">Нет лиц</div>';
          return;
        }
        
        // Разделяем лица на архивные и из текущего прогона
        const archiveFaces = faces.filter(f => f.is_archive);
        const runFaces = faces.filter(f => f.is_run);
        
        // Скрываем секцию, если нет лиц
        if (archiveFaces.length === 0) {
          archiveSection.style.display = 'none';
        } else {
          archiveSection.style.display = 'block';
          archiveGrid.innerHTML = await Promise.all(archiveFaces.map(async (face) => renderFaceThumb(face))).then(h => h.join(''));
        }
        
        if (runFaces.length === 0) {
          runSection.style.display = 'none';
        } else {
          runSection.style.display = 'block';
          runGrid.innerHTML = await Promise.all(runFaces.map(async (face) => renderFaceThumb(face))).then(h => h.join(''));
        }
      }
      
      async function renderFaceThumb(face) {
        const thumbUrl = face.thumb_jpeg_base64 ? 
          `data:image/jpeg;base64,${face.thumb_jpeg_base64}` : null;
        
        const isAvatar = personData.person.avatar_face_id === face.face_id;
        const avatarClass = isAvatar ? ' avatar' : '';
        
        const escapedPath = (face.file_path || '').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        const bboxJson = face.bbox ? JSON.stringify(face.bbox).replace(/"/g, '&quot;') : '';
        return `
          <div class="thumb${avatarClass}" data-face-id="${face.face_id}" data-file-path="${escapedPath}" data-bbox="${bboxJson}" ondblclick="handleFaceDoubleClick(this)">
            ${thumbUrl ? `<img src="${thumbUrl}" alt="Face ${face.face_id}" />` : '<div class="noimg">Нет превью</div>'}
            <div class="face-actions">
              <button class="face-btn" onclick="event.stopPropagation(); ignoreFace(${face.face_id})" title="Это не лицо">Не лицо</button>
              <button class="face-btn" onclick="event.stopPropagation(); reassignFace(${face.face_id})" title="Это другой человек">Другой</button>
              <button class="face-btn" onclick="event.stopPropagation(); setAvatar(${face.face_id})" title="Назначить аватаром" ${isAvatar ? 'disabled' : ''}>Аватар</button>
            </div>
          </div>
        `;
      }

      function handleFaceDoubleClick(element) {
        const faceId = parseInt(element.getAttribute('data-face-id'));
        const filePath = element.getAttribute('data-file-path');
        const bboxStr = element.getAttribute('data-bbox');
        let bboxData = null;
        if (bboxStr) {
          try {
            bboxData = JSON.parse(bboxStr.replace(/&quot;/g, '"'));
          } catch (e) {
            console.error('Ошибка парсинга bbox:', e);
          }
        }
        
        openFaceImage(faceId, filePath, bboxData);
      }

      function openFaceImage(faceId, filePath, bboxData) {
        // Находим информацию о лице
        const faces = personData?.faces || [];
        const face = faces.find(f => f.face_id === faceId);
        if (!face) {
          return;
        }
        
        const path = face.file_path || filePath;
        currentFilePath = path; // Сохраняем путь для исправления клиппинга
        const lb = document.getElementById('lightbox');
        const lbPath = document.getElementById('lbPath');
        const lbImg = document.getElementById('lbImg');
        const lbOpen = document.getElementById('lbOpen');
        const lbRectangle = document.getElementById('lbRectangle');
        const lbFixClipping = document.getElementById('lbFixClipping');
        
        // Показываем кнопку "Исправить клипинг" только для изображений (не для видео)
        if (lbFixClipping) {
          lbFixClipping.style.display = (path && !path.match(/\.(mp4|mov|avi|mkv|webm|m4v|3gp)$/i)) ? '' : 'none';
        }
        
        if (lbPath) lbPath.textContent = path;
        
        // Сохраняем faceId и bbox для отрисовки
        currentFaceId = faceId;
        if (bboxData && typeof bboxData === 'object') {
          currentFaceBbox = bboxData;
        } else if (face && face.bbox) {
          currentFaceBbox = face.bbox;
        } else {
          currentFaceBbox = null;
        }
        
        
        // Убеждаемся, что currentFaceBbox установлен
        if (!currentFaceBbox) {
          console.error('openFaceImage: ОШИБКА - currentFaceBbox не установлен!', {
            bboxData,
            faceBbox: face?.bbox,
            faceId: face?.face_id
          });
        }
        
        // Проверяем наличие размеров изображения и EXIF orientation, загружаем их, если нужно
        const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
        const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
        if (!hasImageSize || (!hasExifOrientation && path)) {
          // Загружаем размеры изображения и сохраняем в БД
          fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
            .then(res => res.json())
            .then(data => {
              if (data.ok && data.width && data.height) {
                // Обновляем размеры в personData для текущего лица
                if (face) {
                  face.image_size = { 
                    width: data.width, 
                    height: data.height,
                    exif_orientation: data.exif_orientation || null
                  };
                }
                // Перерисовываем rectangles с новыми размерами
                if (lbImg && lbImg.complete) {
                  // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                }
              }
            })
            .catch(err => {
              console.error('Failed to load image dimensions:', err);
            });
        }
        
        // Скрываем rectangle до загрузки изображения
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
        
        // Определяем URL для превью
        let previewUrl = '';
        let openUrl = '';
        
        if (path.startsWith('disk:')) {
          previewUrl = `/api/yadisk/preview-image?size=XL&path=${encodeURIComponent(path)}`;
          openUrl = `/api/yadisk/open?path=${encodeURIComponent(path)}`;
        } else if (path.startsWith('local:')) {
          previewUrl = `/api/local/preview?path=${encodeURIComponent(path)}`;
          openUrl = '#';
        }
        
        if (lbOpen) {
          if (openUrl && openUrl !== '#') {
            lbOpen.href = openUrl;
            lbOpen.style.display = 'inline-block';
          } else {
            lbOpen.style.display = 'none';
          }
        }
        
        // Используем новую карточку фотографий, если доступна
        if (window.openPhotoCard) {
          // Формируем list_context из всех лиц персоны
          const allFaces = personData?.faces || [];
          const currentIndex = allFaces.findIndex(f => f.face_id === currentFaceId);
          
          const items = allFaces.map(f => ({
            file_id: f.file_id || null,
            file_path: f.file_path || null,
            face_rectangle_id: f.face_id || null,
            person_rectangle_id: null
          }));
          
          const listContext = {
            source_page: "person_detail",
            items: items,
            current_index: currentIndex >= 0 ? currentIndex : 0,
            total_count: items.length,
            api_fallback: null
          };
          
          // Определяем pipeline_run_id из данных лица (если есть)
          const faceData = allFaces.find(f => f.face_id === currentFaceId);
          const pipelineRunId = faceData?.pipeline_run_id || faceData?.run_id || null;
          
          window.openPhotoCard({
            file_id: face?.file_id || null,
            file_path: path,
            pipeline_run_id: pipelineRunId,
            list_context: listContext,
            highlight_rectangle: {
              type: 'face_rectangle',
              id: currentFaceId
            }
          });
          return; // Выходим, не используем старый lightbox
        }
        
        // Открываем lightbox сразу, не дожидаясь загрузки изображения (fallback)
        openLightbox();
        
        // Загружаем все лица на этом фото
        fetch(`/api/file-faces?file_path=${encodeURIComponent(path)}`)
          .then(res => res.json())
          .then(data => {
            allFacesOnImage = data.faces || [];
            console.log('Loaded faces on image:', allFacesOnImage.length, 'currentFaceId:', currentFaceId, 'faces:', allFacesOnImage);
            // Данные о лицах загружены, но изображение может еще не загрузиться
            // tryDrawAllFaces будет вызван из onload, когда изображение точно загрузится
            // Но если изображение уже загружено, вызываем сразу
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              // Получаем размеры исходного изображения для масштабирования
              const face = personData?.faces?.find(f => f.face_id === currentFaceId);
              const originalImageSize = face?.image_size;
              if (drawAllFaceRectanglesFromModule) {
                drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
              }
              drawFaceRectangleLocal();
            }
          })
          .catch(err => {
            console.error('Failed to load faces on image:', err);
            allFacesOnImage = [];
            // Даже если ошибка, пытаемся нарисовать текущее лицо, если изображение уже загружено
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              // Получаем размеры исходного изображения для масштабирования
              const face = personData?.faces?.find(f => f.face_id === currentFaceId);
              const originalImageSize = face?.image_size;
              if (drawAllFaceRectanglesFromModule) {
                drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
              }
              drawFaceRectangleLocal();
            }
          });
        
        // Загружаем изображение
        if (lbImg && previewUrl) {
          // Устанавливаем обработчик onload
          lbImg.onload = function() {
            // Проверяем, что элементы действительно готовы в DOM
            const checkAndDraw = () => {
              const lbImgCheck = document.getElementById('lbImg');
              const lbBodyCheck = document.getElementById('lbBody');
              if (lbImgCheck && lbBodyCheck && lbImgCheck.complete) {
                // Теперь изображение точно загружено, рисуем rectangles (если данные о лицах уже загружены)
                if (allFacesOnImage !== undefined) {
                  // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                }
              } else {
                requestAnimationFrame(checkAndDraw);
              }
            };
            
            // Используем requestAnimationFrame для гарантии, что DOM обновлен
            requestAnimationFrame(() => {
              requestAnimationFrame(checkAndDraw);
            });
            
            // Если размеры еще не загружены, пытаемся их получить
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawAllFaceRectanglesLocal();
              });
            }
          };
          
          // Если изображение уже загружено и это тот же URL, не перезагружаем
          if (lbImg.src !== previewUrl && !lbImg.src.includes(previewUrl)) {
            lbImg.src = previewUrl;
          } else if (lbImg.complete) {
            // Изображение уже загружено, проверяем размеры и рисуем rectangle
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            
            // Функция для отрисовки после проверки данных о лицах
            const drawWhenReady = () => {
              if (allFacesOnImage !== undefined) {
                drawAllFaceRectanglesLocal();
              }
            };
            
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    drawWhenReady();
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawWhenReady();
              });
            }
          }
        }
      }

      function openLightbox() {
        document.getElementById('lightbox').classList.add('open');
      }
      

      function drawFaceRectangleLocal() {
        // Всегда пытаемся получить bbox из personData, если currentFaceBbox не установлен
        if (!currentFaceBbox && currentFaceId) {
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          if (face && face.bbox) {
            currentFaceBbox = face.bbox;
          } else {
            return;
          }
        }
        
        if (!currentFaceBbox) {
          return;
        }
        
        const lbImg = document.getElementById('lbImg');
        if (!lbImg || !lbImg.complete) {
          return;
        }
        
        // Получаем размеры исходного изображения из данных лица
        const face = personData?.faces?.find(f => f.face_id === currentFaceId);
        const originalImageSize = face?.image_size;
        const currentPerson = personData?.person;
        
        // Вызываем функцию из модуля
        if (drawFaceRectangleFromModule) {
          drawFaceRectangleFromModule(
            currentFaceBbox,
            originalImageSize,
            currentPerson?.name,
            currentPerson?.is_me,
            face?.cluster_id
          );
        }
      }

      function closeLightbox() {
        document.getElementById('lightbox').classList.remove('open');
        currentFaceBbox = null;
        const lbRectangle = document.getElementById('lbRectangle');
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
      }

      // Закрытие lightbox по клику вне изображения или Escape
      document.addEventListener('click', (e) => {
        const lb = document.getElementById('lightbox');
        if (lb && e.target === lb) {
          closeLightbox();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeLightbox();
        }
      });

      // Перерисовка rectangles при изменении размера окна
      window.addEventListener('resize', () => {
        if (document.getElementById('lightbox').classList.contains('open')) {
          // Получаем размеры исходного изображения для масштабирования
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          const originalImageSize = face?.image_size;
          if (drawAllFaceRectanglesFromModule) {
            drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
          }
          drawFaceRectangleLocal();
        }
      });

      async function updatePersonName() {
        const newName = document.getElementById('inputPersonName').value.trim();
        if (!newName) {
          showToast('Имя не может быть пустым', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка обновления имени');
          }
          
          showToast('Имя обновлено');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка обновления имени:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function updatePersonGroup() {
        const groupSelect = document.getElementById('selectPersonGroup');
        const newGroup = groupSelect ? (groupSelect.value || null) : null;
        const currentName = document.getElementById('inputPersonName').value.trim();
        
        if (!currentName) {
          showToast('Имя не может быть пустым', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: currentName, group: newGroup }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка обновления группы');
          }
          
          showToast('Группа обновлена');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка обновления группы:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function saveToGold() {
        const btn = document.getElementById('btnSaveToGold');
        if (!btn) return;
        
        btn.disabled = true;
        btn.textContent = 'Сохранение...';
        
        try {
          const resp = await fetch(`/api/persons/${personId}/save-to-gold`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          });
          
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data.detail || data.error || 'Ошибка сохранения');
          }
          
          showToast(`Сохранено в gold: ${data.faces_count} лиц, ${data.files_updated} файлов`, false);
        } catch (e) {
          showToast(`Ошибка: ${e.message}`, true);
        } finally {
          btn.disabled = false;
          btn.textContent = 'Сохранить в gold';
        }
      }


      async function ignoreFace(faceId) {
        if (!confirm('Пометить это лицо как "не лицо"?')) {
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${faceId}/ignore`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо помечено как "не лицо"');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function reassignFace(faceId) {
        currentReassignFaceId = faceId;
        
        // Загружаем список персон
        try {
          const resp = await fetch('/api/persons/list');
          if (!resp.ok) throw new Error('Не удалось загрузить список персон');
          const data = await resp.json();
          allPersons = data.persons || [];
          
          // Загружаем похожие лица
          const similarResp = await fetch(`/api/persons/${personId}/faces/${faceId}/similar?limit=3`);
          let similarFaces = [];
          if (similarResp.ok) {
            const similarData = await similarResp.json();
            similarFaces = similarData.similar_faces || [];
          }
          
          // Заполняем выпадашку
          const select = document.getElementById('selectReassignPerson');
          select.innerHTML = '<option value="">Выберите персону...</option>';
          
          // Добавляем 3 ближайших по embeddings
          if (similarFaces.length > 0) {
            const optgroupSimilar = document.createElement('optgroup');
            optgroupSimilar.label = 'Ближайшие по embeddings:';
            for (const sf of similarFaces) {
              if (sf.person_id && sf.person_id !== personId) {
                const person = allPersons.find(p => p.id === sf.person_id);
                if (person && !person.is_ignored) {
                  const opt = document.createElement('option');
                  opt.value = sf.person_id;
                  opt.textContent = `${person.name} (расстояние: ${sf.distance.toFixed(3)})`;
                  optgroupSimilar.appendChild(opt);
                }
              }
            }
            if (optgroupSimilar.children.length > 0) {
              select.appendChild(optgroupSimilar);
            }
          }
          
          // Группируем остальных персон по группам
          const groupedPersons = {};
          const noGroupPersons = [];
          
          for (const p of allPersons) {
            if (p.id === personId || p.is_ignored) continue;
            const groupName = p.group || null;
            if (groupName) {
              if (!groupedPersons[groupName]) {
                groupedPersons[groupName] = {
                  order: p.group_order || 999,
                  persons: []
                };
              }
              groupedPersons[groupName].persons.push(p);
            } else {
              noGroupPersons.push(p);
            }
          }
          
          // Сортируем группы по order
          const sortedGroups = Object.entries(groupedPersons).sort((a, b) => {
            return a[1].order - b[1].order;
          });
          
          // Сортируем персон внутри каждой группы по имени
          for (const [groupName, groupData] of sortedGroups) {
            groupData.persons.sort((a, b) => {
              const nameA = (a.name || '').toLowerCase();
              const nameB = (b.name || '').toLowerCase();
              return nameA.localeCompare(nameB);
            });
          }
          
          // Сортируем персон без группы по имени
          noGroupPersons.sort((a, b) => {
            const nameA = (a.name || '').toLowerCase();
            const nameB = (b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
          });
          
          // Рендерим группы
          for (const [groupName, groupData] of sortedGroups) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = groupName;
            for (const p of groupData.persons) {
              const opt = document.createElement('option');
              opt.value = p.id;
              opt.textContent = p.name + (p.is_me ? ' (я)' : '');
              optgroup.appendChild(opt);
            }
            select.appendChild(optgroup);
          }
          
          // Рендерим персон без группы (если есть)
          if (noGroupPersons.length > 0) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = 'Без группы';
            for (const p of noGroupPersons) {
              const opt = document.createElement('option');
              opt.value = p.id;
              opt.textContent = p.name + (p.is_me ? ' (я)' : '');
              optgroup.appendChild(opt);
            }
            select.appendChild(optgroup);
          }
          
          openModal('modalReassign');
        } catch (e) {
          console.error('Ошибка загрузки данных:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function confirmReassign() {
        const targetPersonId = document.getElementById('selectReassignPerson').value;
        if (!targetPersonId) {
          showToast('Выберите персону', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/reassign`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target_person_id: parseInt(targetPersonId) }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка переназначения');
          }
          
          showToast('Лицо переназначено');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка переназначения:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function clearFaceAssignment() {
        if (!confirm('Удалить лицо из текущей персоны и найти ближайший кластер?')) {
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/clear`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо удалено из персоны');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function setAvatar(faceId) {
        try {
          const resp = await fetch(`/api/persons/${personId}/set-avatar`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ face_id: faceId }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка установки аватара');
          }
          
          showToast('Аватар установлен');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка установки аватара:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      function openModal(modalId) {
        document.getElementById(modalId).classList.add('show');
      }

      function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('show');
      }

      // Обработчик кнопки "Исправить клипинг"
      async function handleFixClipping() {
        if (!currentFilePath) {
          showToast('Нет пути к файлу', true);
          return;
        }
        
        // Получаем face_run_id из первого лица персоны (все лица персоны должны быть из одного run)
        const firstFace = personData?.faces?.[0];
        if (!firstFace || !firstFace.face_run_id) {
          showToast('Не найден run_id для исправления клиппинга', true);
          return;
        }
        
        const btn = document.getElementById('lbFixClipping');
        if (!btn) {
          return;
        }
        
        try {
          btn.disabled = true;
          const resp = await fetch('/api/faces/fix-clipping', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              face_run_id: Number(firstFace.face_run_id),
              path: currentFilePath,
            }),
          });
          
          if (!resp.ok) {
            let errorDetail = '';
            try {
              const errorJson = await resp.json();
              errorDetail = errorJson.detail || errorJson.error || JSON.stringify(errorJson);
            } catch {
              const errorText = await resp.text();
              errorDetail = errorText || `HTTP ${resp.status}`;
            }
            showToast(`Ошибка ${resp.status}: ${errorDetail}`, true);
            return;
          }
          
          const res = await resp.json();
          if (res.ok) {
            // Сохраняем текущие данные для обновления после перезагрузки
            const savedFaceId = currentFaceId;
            const savedFilePath = currentFilePath;
            
            // Перезагружаем персону, чтобы обновить bbox в отображении
            await loadPerson();
            
            // Если lightbox открыт, принудительно переоткрываем его
            if (savedFaceId) {
              const faceEl = document.querySelector(`[data-face-id="${savedFaceId}"]`);
              if (faceEl) {
                // Обновляем bbox из обновлённого personData перед переоткрытием
                const faces = personData?.faces || [];
                const face = faces.find(f => f.face_id === savedFaceId);
                if (face && face.bbox) {
                  const bboxJson = JSON.stringify(face.bbox).replace(/"/g, '&quot;');
                  faceEl.setAttribute('data-bbox', bboxJson);
                }
                handleFaceDoubleClick(faceEl);
              }
            }
          } else {
            const errorMsg = res.detail || 'Ошибка пересчёта';
            showToast(errorMsg, true);
          }
        } catch (e) {
          const errorMsg = e?.message || String(e);
          showToast('Ошибка: ' + errorMsg, true);
        } finally {
          btn.disabled = false;
        }
      }

      // Инициализация
      document.getElementById('btnUpdateName').addEventListener('click', updatePersonName);
      document.getElementById('btnUpdateGroup').addEventListener('click', updatePersonGroup);
      document.getElementById('btnSaveToGold').addEventListener('click', saveToGold);
      document.getElementById('inputPersonName').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') updatePersonName();
      });
      
      // Обработчик кнопки "Исправить клипинг"
      const btnFixClipping = document.getElementById('lbFixClipping');
      if (btnFixClipping) {
        btnFixClipping.onclick = handleFixClipping;
      }
      
      loadPerson();
    </script>
    
    <!-- Подключение единой карточки фотографий -->
    <div class="photo-card-modal" id="photoCardModal" aria-hidden="true" style="display: none;">
      <div class="photo-card-panel" role="dialog" aria-modal="true">
        <div class="photo-card-top">
          <code class="photo-card-path" id="photoCardPath">—</code>
          <div class="photo-card-actions">
            <span class="pill" id="photoCardMode">просмотр</span>
            <button class="btn" id="photoCardToggleRectangles" type="button">Скрыть прямоугольники</button>
            <button class="btn" id="photoCardUndo" type="button" style="display:none;" title="Отменить последнее действие">Undo</button>
            <button class="btn" id="photoCardClose" type="button">Закрыть</button>
          </div>
        </div>
        <div class="photo-card-tabs" id="photoCardTabs" style="display:none;">
          <button class="lb-tab" id="photoCardTabVideo" type="button">Видео</button>
          <button class="lb-tab" id="photoCardTabF1" type="button">Кадр 1</button>
          <button class="lb-tab" id="photoCardTabF2" type="button">Кадр 2</button>
          <button class="lb-tab" id="photoCardTabF3" type="button">Кадр 3</button>
        </div>
        <div class="photo-card-body">
          <div class="imgwrap" id="photoCardImgWrap">
            <img id="photoCardImg" alt="preview" />
            <video id="photoCardVideo" controls preload="metadata" style="display:none;"></video>
            <canvas id="photoCardCanvas"></canvas>
          </div>
        </div>
        <div class="photo-card-navigation" id="photoCardNavigation" style="display:none;">
          <button class="btn" id="photoCardPrev" type="button">←</button>
          <span class="photo-card-position" id="photoCardPosition">1 из 1</span>
          <button class="btn" id="photoCardNext" type="button">→</button>
        </div>
        <div class="photo-card-bottom">
          <div class="muted">Прямоугольники:</div>
          <div class="rectlist" id="photoCardRectList"></div>
          <div id="photoCardSpecialActions" style="display:none; margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
            <button class="btn" id="photoCardAssignOutsider" type="button">Все остальные - посторонние</button>
            <button class="btn danger" id="photoCardMarkAsCat" type="button">Это кот</button>
            <button class="btn danger" id="photoCardMarkAsNoPeople" type="button">Нет людей</button>
          </div>
        </div>
      </div>
    </div>
    <div class="photo-card-modal" id="photoCardPersonModal" aria-hidden="true" style="display: none;">
      <div class="photo-card-panel" role="dialog" aria-modal="true" style="max-width: 500px;">
        <div class="photo-card-top">
          <div style="font-weight:700;">Назначить персону</div>
          <button class="btn" id="photoCardPersonModalClose" type="button" style="padding:4px 8px;">✕</button>
        </div>
        <div style="padding: 16px;">
          <div style="margin-bottom:12px; font-weight:700;">Выберите персону:</div>
          <select id="photoCardSelectPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:16px;">
            <option value="">Выберите персону...</option>
          </select>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <div style="margin-bottom:8px; font-weight:700;">Или создайте новую:</div>
            <input type="text" id="photoCardInputNewPersonName" placeholder="Имя персоны" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; margin-bottom:8px;" />
          </div>
          <button class="btn" id="photoCardAssignPerson" type="button" style="width:100%; margin-top:16px;">Назначить</button>
        </div>
        <div class="photo-card-bottom" style="justify-content:flex-end;">
          <button class="btn" id="photoCardPersonModalCancel" type="button">Отмена</button>
        </div>
      </div>
    </div>
    <style>
      .photo-card-modal { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .photo-card-modal[aria-hidden="false"] { display: flex; }
      .photo-card-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(1200px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); display: flex; flex-direction: column; }
      .photo-card-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .photo-card-top code { font-size: 11px; }
      .photo-card-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .photo-card-tabs { display:flex; gap:8px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; background:#f9fafb; flex-wrap:wrap; }
      .photo-card-body { background: #111827; display: flex; align-items: center; justify-content: center; padding: 10px; flex: 1; overflow: auto; }
      .photo-card-navigation { display: flex; align-items: center; justify-content: center; gap: 12px; padding: 10px 12px; border-top: 1px solid #e5e7eb; border-bottom: 1px solid #e5e7eb; background: #f9fafb; }
      .photo-card-position { font-weight: 700; font-size: 14px; }
      .photo-card-bottom { padding: 10px 12px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
      .photo-card-rectangle { position: absolute; pointer-events: auto; cursor: pointer; z-index: 1000; }
      .photo-card-rectangle-label { position: absolute; pointer-events: none; white-space: nowrap; max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    </style>
    <script src="/static/photo_card.js"></script>
  </body>
</html>
