<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Персона</title>
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <symbol id="icon-line-copy-right" viewBox="0 0 16 16" fill="none">
        <rect x="5.5" y="5.5" width="9" height="9" stroke="currentColor" stroke-width="1.2" fill="none" rx="1.5" stroke-linejoin="round"/>
        <rect x="1.5" y="1.5" width="9" height="9" stroke="currentColor" stroke-width="1.2" fill="none" rx="1.5" stroke-linejoin="round"/>
      </symbol>
    </svg>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1400px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin-bottom:20px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.primary { background:#111827; color:#fff; border-color:#111827; }
      .btn.primary:hover { background:#374151; }
      .btn.small { padding:4px 8px; font-size:12px; }
      .thumb-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap:12px; margin-top:16px; }
      .thumb { width: 100%; aspect-ratio: 1; background:#fff; display:flex; align-items:center; justify-content:center; border:1px solid #e5e7eb; border-radius:8px; overflow:hidden; cursor: pointer; position:relative; }
      .thumb img { width: 100%; height: 100%; object-fit: cover; }
      .thumb .noimg { color:#6b7280; font-size:11px; text-align:center; padding:8px; }
      .thumb:hover { border-color:#0b57d0; }
      .thumb .face-actions { position:absolute; bottom:4px; left:4px; right:4px; display:none; gap:4px; flex-wrap:wrap; }
      .thumb:hover .face-actions { display:flex; }
      .thumb .face-btn { background:rgba(0,0,0,0.8); color:#fff; border:none; border-radius:4px; padding:4px 6px; font-size:10px; cursor:pointer; flex:1; min-width:0; position:relative; }
      .thumb .face-btn:hover { background:rgba(0,0,0,0.95); }
      .thumb .face-btn.dropdown { position:relative; }
      .reassign-dropdown-menu { position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); min-width:200px; max-width:300px; max-height:400px; overflow-y:auto; z-index:10001; display:none; }
      .reassign-dropdown-menu.open { display:block; }
      .reassign-dropdown-menu .menu-section { padding:4px 0; border-bottom:1px solid #f3f4f6; }
      .reassign-dropdown-menu .menu-section:last-child { border-bottom:none; }
      .reassign-dropdown-menu .menu-section-title { padding:6px 12px; font-size:11px; font-weight:700; color:#6b7280; text-transform:uppercase; }
      .reassign-dropdown-menu .menu-item { display:block; width:100%; padding:8px 12px; text-align:left; background:none; border:none; color:#111827; cursor:pointer; font-size:12px; transition:background 0.15s; }
      .reassign-dropdown-menu .menu-item:hover { background:#f9fafb; }
      .reassign-dropdown-menu .menu-item:last-child { border-bottom:none; }
      .thumb.avatar { border:3px solid #0b57d0; }
      .info-section { background:#f9fafb; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:20px; }
      .info-section h3 { margin:0 0 12px 0; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; font-size:13px; }
      .loading { opacity: 0.6; pointer-events: none; }
      .form-group { margin-bottom:12px; }
      .form-group label { display:block; margin-bottom:4px; font-weight:700; }
      .form-group input { width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px; }
      /* Lightbox */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 92vw; max-height: 92vh; width: min(1200px, 92vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; position: relative; }
      .lb-body img { max-width: 92vw; max-height: calc(92vh - 56px); width: auto; height: auto; display: block; object-fit: contain; background: #111827; }
      .lb-rectangle { position: absolute; border: 3px solid #0b57d0; pointer-events: none; box-shadow: 0 0 0 2px rgba(11, 87, 208, 0.3); z-index: 1001; }
      .lb-rectangle.other { border-color: #fbbf24; box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.3); z-index: 1000; pointer-events: auto; cursor: pointer; }
      .lb-rectangle-label { 
        position: absolute; 
        background: rgba(251, 191, 36, 0.95); 
        color: #111827; 
        padding: 3px 8px; 
        font-size: 12px; 
        font-weight: 700; 
        border-radius: 4px; 
        white-space: nowrap; 
        z-index: 10001; 
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(251, 191, 36, 1);
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .lb-rectangle-label:hover {
        background: rgba(251, 191, 36, 1);
        cursor: pointer;
      }
      /* Modal */
      .modal { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .modal.show { display: flex; }
      .modal-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(500px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .modal-header { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display:flex; justify-content:space-between; align-items:center; }
      .modal-body { padding: 16px; max-height: calc(94vh - 120px); overflow-y: auto; }
      .modal-footer { padding: 12px 16px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; justify-content:flex-end; }
      /* Tabs */
      .tabs { display: flex; gap: 8px; border-bottom: 2px solid #e5e7eb; margin-bottom: 12px; }
      .tab { appearance: none; border: none; background: transparent; padding: 10px 16px; cursor: pointer; font-weight: 600; font-size: 14px; color: #6b7280; border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.2s; }
      .tab:hover { color: #111827; }
      .tab.active { color: #0b57d0; border-bottom-color: #0b57d0; }
      .subtabs { display: flex; gap: 6px; margin-bottom: 12px; align-items: center; }
      .subtab { appearance: none; border: 1px solid #e5e7eb; background: #fff; padding: 6px 12px; cursor: pointer; font-weight: 500; font-size: 13px; color: #6b7280; border-radius: 6px; transition: all 0.2s; }
      .subtab:hover { background: #f9fafb; border-color: #d1d5db; }
      .subtab.active { background: #0b57d0; color: #fff; border-color: #0b57d0; }
      #manualFilterSelect { min-width: 140px; padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; background: #fff; font-size: 13px; color: #374151; cursor: pointer; }
      #manualFilterSelect:hover { border-color: #9ca3af; }
      /* Бейджи типов привязки */
      .assignment-type-badge {
        position: absolute;
        top: 4px;
        left: 4px;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: 700;
        color: #fff;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 10;
      }
      .assignment-type-badge.badge-cluster {
        background: #0b57d0; /* Синий - кластеры */
      }
      .assignment-type-badge.badge-manual {
        background: #f59e0b; /* Оранжевый - ручные привязки */
      }
      .assignment-type-badge.badge-rectangle {
        background: #6b7280; /* Серый - прямоугольники */
      }
      .assignment-type-badge.badge-file {
        background: #10b981; /* Зеленый - прямая привязка файла */
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <div>
          <h2 style="margin:0; display:flex; align-items:center; gap:12px;">
            <span id="personName">Загрузка...</span>
            <span id="personAvatar" style="display:none;"></span>
          </h2>
          <div class="muted" style="margin-top:6px;" id="personInfo">Загрузка...</div>
        </div>
        <div>
          <a href="/persons" class="muted">← к списку персон</a> · 
          <a href="/persons/{{ person_id }}/clusters" class="muted">Кластеры персоны</a>
        </div>
      </div>

      <div class="info-section">
        <h3>Управление персоной</h3>
        <div class="form-group">
          <label>Имя персоны:</label>
          <div style="display:flex; gap:8px;">
            <input type="text" id="inputPersonName" placeholder="Имя персоны" />
            <button class="btn primary" id="btnUpdateName" type="button">Сохранить</button>
          </div>
        </div>
        <div class="form-group" style="margin-top:12px;">
          <label>Группа:</label>
          <div style="display:flex; gap:8px;">
            <select id="selectPersonGroup" style="flex:1; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px;">
              <option value="">Без группы</option>
              <option value="Я и Супруга">Я и Супруга</option>
              <option value="Дети">Дети</option>
              <option value="Родственники">Родственники</option>
              <option value="Синяя диагональ">Синяя диагональ</option>
              <option value="Работа">Работа</option>
            </select>
            <button class="btn primary" id="btnUpdateGroup" type="button">Сохранить</button>
          </div>
        </div>
        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn primary" id="btnSaveToGold" type="button">Сохранить в gold</button>
        </div>
      </div>

      <div>
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
          <h3 style="margin:0;">Все элементы персоны (<span id="facesCount">-</span>)</h3>
          <div style="display:flex; gap:8px; align-items:center;">
            <button class="btn" id="btnViewModeGeneral" type="button" style="padding:6px 12px; font-size:13px;">Общий</button>
            <button class="btn primary" id="btnViewModeDetailed" type="button" style="padding:6px 12px; font-size:13px;">Детальный</button>
          </div>
        </div>
        <div class="muted" style="margin-top:6px; margin-bottom:12px;">Двойной клик на элемент — открыть полную фотографию</div>
        
        <!-- Общий режим просмотра -->
        <div id="viewModeGeneral" style="display:none;">
          <div class="thumb-grid" id="facesGridGeneralContent"></div>
        </div>
        
        <!-- Детальный режим просмотра -->
        <div id="viewModeDetailed" style="display:block;">
          <!-- Основные вкладки: Фотоархив / Сортируется -->
          <div class="tabs" style="margin-bottom:12px;">
            <button class="tab active" id="tabArchive" type="button" data-tab="archive">Фотоархив <span id="tabArchiveCount" class="pill" style="margin-left:6px; font-size:11px;">0</span></button>
            <button class="tab" id="tabRun" type="button" data-tab="run">Сортируется <span id="tabRunCount" class="pill" style="margin-left:6px; font-size:11px;">0</span></button>
          </div>
          
          <!-- Подвкладки для Фотоархив -->
          <div class="subtabs" id="subtabsArchive" style="display:flex; margin-bottom:12px;">
            <button class="subtab active" id="subArchiveFaces" type="button" data-subtab="faces">Через лица <span id="subArchiveFacesCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
            <button class="subtab" id="subArchiveRectangles" type="button" data-subtab="rectangles">Через прямоугольники <span id="subArchiveRectanglesCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
            <button class="subtab" id="subArchiveDirect" type="button" data-subtab="direct">Прямая привязка <span id="subArchiveDirectCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
          </div>
          
          <!-- Подвкладки для Сортируется -->
          <div class="subtabs" id="subtabsRun" style="display:none; margin-bottom:12px;">
            <button class="subtab active" id="subRunFaces" type="button" data-subtab="faces">Через лица <span id="subRunFacesCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
            <button class="subtab" id="subRunRectangles" type="button" data-subtab="rectangles">Через прямоугольники <span id="subRunRectanglesCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
            <button class="subtab" id="subRunDirect" type="button" data-subtab="direct">Прямая привязка <span id="subRunDirectCount" class="pill" style="margin-left:4px; font-size:10px; padding:2px 6px;">0</span></button>
            <select id="manualFilterSelect" style="display:none; margin-left:auto; padding:6px 12px; border:1px solid #d1d5db; border-radius:6px; background:#fff; font-size:13px; color:#374151; cursor:pointer;">
              <option value="all">Все</option>
              <option value="manual_only">Только ручные</option>
              <option value="no_manual">Кроме ручных</option>
            </select>
          </div>
          
          <!-- Контент для Фотоархив -->
          <div id="contentArchive" style="display:block;">
            <!-- Через лица -->
            <div id="contentArchiveFaces" style="display:block;">
              <div class="thumb-grid" id="facesGridArchiveFacesContent"></div>
            </div>
            <!-- Через прямоугольники -->
            <div id="contentArchiveRectangles" style="display:none;">
              <div class="thumb-grid" id="facesGridArchiveRectanglesContent"></div>
            </div>
            <!-- Прямая привязка -->
            <div id="contentArchiveDirect" style="display:none;">
              <div class="thumb-grid" id="facesGridArchiveDirectContent"></div>
            </div>
          </div>
          
          <!-- Контент для Сортируется -->
          <div id="contentRun" style="display:none;">
            <!-- Через лица -->
            <div id="contentRunFaces" style="display:block;">
              <div class="thumb-grid" id="facesGridRunFacesContent"></div>
            </div>
            <!-- Через прямоугольники -->
            <div id="contentRunRectangles" style="display:none;">
              <div class="thumb-grid" id="facesGridRunRectanglesContent"></div>
            </div>
            <!-- Прямая привязка -->
            <div id="contentRunDirect" style="display:none;">
              <div class="thumb-grid" id="facesGridRunDirectContent"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Lightbox для просмотра полной фотографии -->
    <div class="lb" id="lightbox" style="display: none;">
      <div class="lb-panel">
        <div class="lb-top">
          <div class="muted"><code id="lbPath"></code></div>
          <div style="display:flex; gap:10px; align-items:center;">
            <a id="lbOpen" class="pill" href="#" target="_blank" rel="noopener noreferrer" style="display:none;">Открыть</a>
            <button class="btn" id="lbFixClipping" type="button" style="display:none;" title="Пересчитать координаты bbox с исправленным клиппингом">Исправить клипинг</button>
            <button class="btn" type="button" onclick="closeLightbox()">Закрыть</button>
          </div>
        </div>
        <div class="lb-body" id="lbBody">
          <img id="lbImg" alt="preview" />
          <div id="lbRectangle" class="lb-rectangle"></div>
        </div>
      </div>
    </div>

    <!-- Modal для переназначения лица -->
    <div class="modal" id="modalReassign">
      <div class="modal-panel">
        <div class="modal-header">
          <h3 style="margin:0;">Переназначить лицо</h3>
          <button class="btn" type="button" onclick="closeModal('modalReassign')">✕</button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Выберите персону:</label>
            <select id="selectReassignPerson" style="width:100%; border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-size:14px;">
              <option value="">Загрузка...</option>
            </select>
          </div>
          <div style="margin-top:16px; padding-top:16px; border-top:1px solid #e5e7eb;">
            <button class="btn" type="button" onclick="clearFaceAssignment()" style="width:100%;">Очистить (найти ближайший кластер)</button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn" type="button" onclick="closeModal('modalReassign')">Отмена</button>
          <button class="btn primary" type="button" onclick="confirmReassign()">Переназначить</button>
        </div>
      </div>
    </div>

    <script src="/static/face_rectangles_viewer.js"></script>
    <script>
      const personId = {{ person_id }};
      let personData = null;
      let allPersons = [];
      let currentReassignFaceId = null;
      let currentFaceBbox = null; // Bbox текущего отображаемого лица
      let currentFaceId = null; // ID текущего отображаемого лица
      let currentFilePath = null; // Путь к текущему файлу для исправления клиппинга
      let allFacesOnImage = []; // Все лица на текущем изображении
      let isDrawingFaces = false; // Флаг для предотвращения множественных вызовов drawAllFaceRectangles
      
      // Режимы просмотра и вкладки
      let viewMode = 'detailed'; // 'general' или 'detailed'
      let mainTab = 'archive'; // 'archive' или 'run'
      let subtab = 'faces'; // 'faces', 'rectangles', 'direct'
      let manualFilterMode = 'all'; // Фильтр для вкладки "Сортируется - через лица": 'all' | 'manual_only' | 'no_manual'
      
      // Сохраняем ссылку на функцию из модуля ПЕРЕД любыми переопределениями
      // Проверяем сразу после загрузки скрипта
      let drawAllFaceRectanglesFromModule = null;
      let drawFaceRectangleFromModule = null;
      
      // Пробуем получить функции из глобальной области видимости
      if (typeof drawAllFaceRectangles !== 'undefined') {
        drawAllFaceRectanglesFromModule = drawAllFaceRectangles;
      }
      
      if (typeof drawFaceRectangle !== 'undefined') {
        drawFaceRectangleFromModule = drawFaceRectangle;
      }
      
      // Проверяем, что модуль загрузился
      if (!drawAllFaceRectanglesFromModule || !drawFaceRectangleFromModule) {
        console.error('face_rectangles_viewer.js module not loaded!', {
          drawAllFaceRectangles: typeof drawAllFaceRectangles,
          drawFaceRectangle: typeof drawFaceRectangle
        });
      }

      function showToast(msg, isError = false) {
        // Тихий toast - только в консоль, без модальных окон
        if (msg) {
          console.log(isError ? '[ERROR]' : '[INFO]', msg);
        }
      }

      async function loadPerson() {
        // Сразу восстанавливаем вкладку из hash, чтобы при обновлении карточки она не слетала
        handleUrlAnchors();
        try {
          const resp = await fetch(`/api/persons/${personId}`);
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
          }
          personData = await resp.json();
          
          // Обновляем заголовок
          document.getElementById('personName').textContent = personData.person.name;
          document.getElementById('inputPersonName').value = personData.person.name;
          
          // Обновляем группу
          const groupSelect = document.getElementById('selectPersonGroup');
          if (groupSelect) {
            groupSelect.value = personData.person.group || '';
          }
          
          // Загружаем аватар если есть
          if (personData.person.avatar_face_id) {
            const avatarUrl = await getFaceThumbnail(personData.person.avatar_face_id);
            if (avatarUrl) {
              const avatarEl = document.getElementById('personAvatar');
              avatarEl.innerHTML = `<img src="${avatarUrl}" alt="Avatar" style="width:48px; height:48px; object-fit:cover; border-radius:50%; border:2px solid #0b57d0;" />`;
              avatarEl.style.display = 'block';
            }
          }
          
          // Обновляем информацию с разделением на архив и текущий прогон
          const facesCount = personData.faces.length;
          const facesArchive = personData.faces.filter(f => f.is_archive || f.source === 'archive').length;
          const facesRun = personData.faces.filter(f => f.is_run || f.source === 'run').length;
          document.getElementById('facesCount').textContent = facesCount;
          document.getElementById('personInfo').textContent = `${facesCount} элементов (Фотоархив: ${facesArchive}, Сортируется: ${facesRun})`;
          
          // Обновляем счетчики на вкладках
          updateTabCounts();
          
          // Рендерим элементы (вкладка уже восстановлена из hash в начале loadPerson)
          renderFaces();
        } catch (e) {
          console.error('Ошибка загрузки персоны:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function getFaceThumbnail(faceId) {
        try {
          const resp = await fetch(`/api/face-rectangles/${faceId}/thumbnail`);
          if (!resp.ok) return null;
          const data = await resp.json();
          if (data.thumb_jpeg_base64) {
            return `data:image/jpeg;base64,${data.thumb_jpeg_base64}`;
          }
        } catch (e) {
          console.error('Ошибка загрузки thumbnail:', e);
        }
        return null;
      }

      // Обработка якорей URL для перехода на нужную закладку
      function handleUrlAnchors() {
        const hash = window.location.hash;
        if (!hash) return;
        
        // Формат: #faces-archive, #rectangles-run, #direct-archive и т.д.
        const match = hash.match(/^#(faces|rectangles|direct)-(archive|run)$/);
        if (match) {
          const [, subtabName, mainTabName] = match;
          mainTab = mainTabName;
          subtab = subtabName;
          viewMode = 'detailed';
          updateViewMode();
          updateTabs();
        }
      }
      
      // Переключение режима просмотра
      function setViewMode(mode) {
        viewMode = mode;
        updateViewMode();
        renderFaces();
      }
      
      function updateViewMode() {
        const generalView = document.getElementById('viewModeGeneral');
        const detailedView = document.getElementById('viewModeDetailed');
        const btnGeneral = document.getElementById('btnViewModeGeneral');
        const btnDetailed = document.getElementById('btnViewModeDetailed');
        
        if (viewMode === 'general') {
          generalView.style.display = 'block';
          detailedView.style.display = 'none';
          btnGeneral.classList.add('primary');
          btnDetailed.classList.remove('primary');
        } else {
          generalView.style.display = 'none';
          detailedView.style.display = 'block';
          btnGeneral.classList.remove('primary');
          btnDetailed.classList.add('primary');
        }
      }
      
      // Переключение основных вкладок
      function setMainTab(tab) {
        mainTab = tab;
        updateTabs();
        renderFaces();
        window.location.hash = `${subtab}-${mainTab}`;
      }
      
      // Переключение подвкладок
      function setSubtab(sub) {
        subtab = sub;
        updateTabs();
        renderFaces();
        window.location.hash = `${subtab}-${mainTab}`;
      }
      
      // Функция для обновления счетчиков на вкладках
      function updateTabCounts() {
        if (!personData || !personData.faces) return;
        
        const faces = personData.faces;
        
        // Подсчет для основных вкладок
        const archiveFaces = faces.filter(f => f.is_archive || f.source === 'archive');
        const runFaces = faces.filter(f => f.is_run || f.source === 'run');
        
        const archiveCountEl = document.getElementById('tabArchiveCount');
        const runCountEl = document.getElementById('tabRunCount');
        if (archiveCountEl) archiveCountEl.textContent = archiveFaces.length;
        if (runCountEl) runCountEl.textContent = runFaces.length;
        
        // Подсчет для подвкладок архива
        const archiveFacesItems = archiveFaces.filter(f => f.assignment_type === 'cluster' || f.assignment_type === 'manual_face');
        const archiveRectanglesItems = archiveFaces.filter(f => f.assignment_type === 'person_rectangle');
        const archiveDirectItems = archiveFaces.filter(f => f.assignment_type === 'file_person');
        
        const subArchiveFacesCountEl = document.getElementById('subArchiveFacesCount');
        const subArchiveRectanglesCountEl = document.getElementById('subArchiveRectanglesCount');
        const subArchiveDirectCountEl = document.getElementById('subArchiveDirectCount');
        if (subArchiveFacesCountEl) subArchiveFacesCountEl.textContent = archiveFacesItems.length;
        if (subArchiveRectanglesCountEl) subArchiveRectanglesCountEl.textContent = archiveRectanglesItems.length;
        if (subArchiveDirectCountEl) subArchiveDirectCountEl.textContent = archiveDirectItems.length;
        
        // Подсчет для подвкладок прогона
        const runFacesItems = runFaces.filter(f => f.assignment_type === 'cluster' || f.assignment_type === 'manual_face');
        const runRectanglesItems = runFaces.filter(f => f.assignment_type === 'person_rectangle');
        const runDirectItems = runFaces.filter(f => f.assignment_type === 'file_person');
        
        const subRunFacesCountEl = document.getElementById('subRunFacesCount');
        const subRunRectanglesCountEl = document.getElementById('subRunRectanglesCount');
        const subRunDirectCountEl = document.getElementById('subRunDirectCount');
        if (subRunFacesCountEl) subRunFacesCountEl.textContent = runFacesItems.length;
        if (subRunRectanglesCountEl) subRunRectanglesCountEl.textContent = runRectanglesItems.length;
        if (subRunDirectCountEl) subRunDirectCountEl.textContent = runDirectItems.length;
      }
      
      function updateTabs() {
        // Основные вкладки
        document.querySelectorAll('.tabs .tab').forEach(btn => {
          btn.classList.toggle('active', btn.getAttribute('data-tab') === mainTab);
        });
        
        // Подвкладки
        const subtabsContainer = mainTab === 'archive' ? 
          document.getElementById('subtabsArchive') : 
          document.getElementById('subtabsRun');
        const otherSubtabsContainer = mainTab === 'archive' ? 
          document.getElementById('subtabsRun') : 
          document.getElementById('subtabsArchive');
        
        if (subtabsContainer) subtabsContainer.style.display = 'flex';
        if (otherSubtabsContainer) otherSubtabsContainer.style.display = 'none';
        
        document.querySelectorAll('.subtabs .subtab').forEach(btn => {
          const container = btn.closest('.subtabs');
          if (container && container.style.display !== 'none') {
            btn.classList.toggle('active', btn.getAttribute('data-subtab') === subtab);
          }
        });
        
        // Контент основных вкладок
        document.getElementById('contentArchive').style.display = mainTab === 'archive' ? 'block' : 'none';
        document.getElementById('contentRun').style.display = mainTab === 'run' ? 'block' : 'none';
        
        // Контент подвкладок для архива
        document.getElementById('contentArchiveFaces').style.display = 
          (mainTab === 'archive' && subtab === 'faces') ? 'block' : 'none';
        document.getElementById('contentArchiveRectangles').style.display = 
          (mainTab === 'archive' && subtab === 'rectangles') ? 'block' : 'none';
        document.getElementById('contentArchiveDirect').style.display = 
          (mainTab === 'archive' && subtab === 'direct') ? 'block' : 'none';
        
        // Контент подвкладок для прогона
        document.getElementById('contentRunFaces').style.display = 
          (mainTab === 'run' && subtab === 'faces') ? 'block' : 'none';
        document.getElementById('contentRunRectangles').style.display = 
          (mainTab === 'run' && subtab === 'rectangles') ? 'block' : 'none';
        document.getElementById('contentRunDirect').style.display = 
          (mainTab === 'run' && subtab === 'direct') ? 'block' : 'none';
        
        // Показываем/скрываем переключатель фильтра только для "Сортируется - через лица"
        const manualFilterSelect = document.getElementById('manualFilterSelect');
        if (manualFilterSelect) {
          manualFilterSelect.style.display = (mainTab === 'run' && subtab === 'faces') ? 'block' : 'none';
          // Синхронизируем состояние переключателя с переменной
          manualFilterSelect.value = manualFilterMode;
        }
      }
      
      async function renderFaces() {
        if (!personData || !personData.faces) {
          clearAllGrids();
          return;
        }
        
        const faces = personData.faces;
        if (faces.length === 0) {
          clearAllGrids();
          return;
        }
        
        if (viewMode === 'general') {
          // Общий режим: единый список всех элементов
          await renderGeneralView(faces);
        } else {
          // Детальный режим: разделение по вкладкам и подвкладкам
          await renderDetailedView(faces);
        }
      }
      
      function clearAllGrids() {
        const grids = [
          'facesGridGeneralContent',
          'facesGridArchiveFacesContent', 'facesGridArchiveRectanglesContent', 'facesGridArchiveDirectContent',
          'facesGridRunFacesContent', 'facesGridRunRectanglesContent', 'facesGridRunDirectContent'
        ];
        grids.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.innerHTML = '<div class="muted">Нет элементов</div>';
        });
      }
      
      async function renderGeneralView(faces) {
        const grid = document.getElementById('facesGridGeneralContent');
        if (!grid) return;
        
        const html = await Promise.all(faces.map(async (face) => renderItemThumb(face))).then(h => h.join(''));
        grid.innerHTML = html || '<div class="muted">Нет элементов</div>';
      }
      
      async function renderDetailedView(faces) {
        // Фильтруем элементы по основной вкладке (archive/run)
        const filteredFaces = faces.filter(f => {
          const source = f.source || (f.is_archive ? 'archive' : (f.is_run ? 'run' : 'unknown'));
          return source === mainTab;
        });
        
        // Фильтруем по подвкладке (faces/rectangles/direct)
        const assignmentTypeMap = {
          'faces': ['cluster', 'manual_face'],
          'rectangles': ['person_rectangle'],
          'direct': ['file_person']
        };
        
        const allowedTypes = assignmentTypeMap[subtab] || [];
        let subtabFaces = filteredFaces.filter(f => allowedTypes.includes(f.assignment_type));
        
        // Временная отладка для проверки person_rectangle элементов
        if (subtab === 'rectangles') {
          const allPersonRectangles = faces.filter(f => f.assignment_type === 'person_rectangle');
          const filteredPersonRectangles = filteredFaces.filter(f => f.assignment_type === 'person_rectangle');
          console.log('[DEBUG] person_rectangle elements:', {
            total: allPersonRectangles.length,
            filtered_by_source: filteredPersonRectangles.length,
            after_subtab_filter: subtabFaces.length,
            mainTab,
            allPersonRectangles: allPersonRectangles.map(f => ({
              assignment_type: f.assignment_type,
              source: f.source,
              is_archive: f.is_archive,
              is_run: f.is_run,
              person_rectangle_id: f.person_rectangle_id,
              file_path: f.file_path
            }))
          });
        }
        
        // Применяем фильтр для вкладки "Сортируется - через лица"
        if (mainTab === 'run' && subtab === 'faces') {
          if (manualFilterMode === 'manual_only') {
            // Только ручные привязки
            subtabFaces = subtabFaces.filter(f => f.assignment_type === 'manual_face');
          } else if (manualFilterMode === 'no_manual') {
            // Все кроме ручных (только кластеры)
            subtabFaces = subtabFaces.filter(f => f.assignment_type !== 'manual_face');
          }
          // Если manualFilterMode === 'all', показываем все (не фильтруем)
        }
        
        // Определяем ID контейнера для текущей подвкладки
        const gridId = `facesGrid${mainTab.charAt(0).toUpperCase() + mainTab.slice(1)}${subtab.charAt(0).toUpperCase() + subtab.slice(1)}Content`;
        const grid = document.getElementById(gridId);
        
        if (grid) {
          const html = await Promise.all(subtabFaces.map(async (face) => renderItemThumb(face))).then(h => h.join(''));
          grid.innerHTML = html || '<div class="muted">Нет элементов</div>';
        }
      }
      
      async function renderItemThumb(item) {
        // Определяем тип элемента и соответствующие данные
        const itemId = item.face_id || item.person_rectangle_id || item.file_id;
        const thumbUrl = item.thumb_jpeg_base64 ? 
          `data:image/jpeg;base64,${item.thumb_jpeg_base64}` : null;
        
        const isAvatar = personData.person.avatar_face_id === item.face_id;
        const avatarClass = isAvatar ? ' avatar' : '';
        
        const escapedPath = (item.file_path || '').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        const bboxJson = item.bbox ? JSON.stringify(item.bbox).replace(/"/g, '&quot;') : '';
        
        // Иконка/подпись типа привязки с цветовым кодированием
        let typeLabel = '';
        let typeBadgeClass = '';
        if (item.assignment_type === 'cluster') {
          typeLabel = 'Кластер';
          typeBadgeClass = 'badge-cluster'; // Синий цвет для кластеров
        } else if (item.assignment_type === 'manual_face') {
          typeLabel = 'Ручное';
          typeBadgeClass = 'badge-manual'; // Оранжевый цвет для ручных привязок
        } else if (item.assignment_type === 'person_rectangle') {
          typeLabel = 'Прямоугольник';
          typeBadgeClass = 'badge-rectangle'; // Серый цвет
        } else if (item.assignment_type === 'file_person') {
          typeLabel = 'Файл';
          typeBadgeClass = 'badge-file'; // Зеленый цвет
        }
        
        // Для прямой привязки (file_person) показываем файл целиком, без кропа; по dblclick открываем карточку
        const hasBbox = item.bbox && item.bbox.x !== null && item.bbox.y !== null;
        const canDoubleClick = item.face_id || (item.person_rectangle_id && hasBbox) || (item.assignment_type === 'file_person' && item.file_path);
        
        let actionsHtml = '';
        if (item.face_id) {
          // Действия только для лиц. Аватар — только для карточек из архива (не сортируется).
          const showAvatar = item.is_archive;
          const avatarBtn = showAvatar
            ? `<button class="face-btn" onclick="event.stopPropagation(); setAvatar(${item.face_id})" title="Назначить аватаром" ${isAvatar ? 'disabled' : ''}>Аватар</button>`
            : '';
          
          // Кнопка "Посторонний" - показываем всегда для лиц
          const escapedFilePathForOutsider = escapedPath || '';
          const fileIdForOutsider = item.file_id || null;
          const outsiderBtn = `<button class="face-btn" onclick="event.stopPropagation(); assignOutsider(${item.face_id}, '${escapedFilePathForOutsider}', ${fileIdForOutsider || 'null'})" title="Назначить персоне 'Посторонний'">Посторонний</button>`;
          
          actionsHtml = `
            <div class="face-actions">
              <button class="face-btn" onclick="event.stopPropagation(); ignoreFace(${item.face_id})" title="Это не лицо">Не лицо</button>
              <button class="face-btn dropdown" onclick="event.stopPropagation(); showReassignDropdown(${item.face_id}, this)" title="Это другой человек">Другой</button>
              ${outsiderBtn}
              ${avatarBtn}
            </div>
          `;
        }
        
        const dataAttrs = [
          item.face_id ? `data-face-id="${item.face_id}"` : '',
          item.person_rectangle_id ? `data-person-rectangle-id="${item.person_rectangle_id}"` : '',
          item.file_id ? `data-file-id="${item.file_id}"` : '',
          `data-file-path="${escapedPath}"`,
          bboxJson ? `data-bbox="${bboxJson}"` : '',
          `data-assignment-type="${item.assignment_type || ''}"`
        ].filter(Boolean).join(' ');
        
        const doubleClickHandler = canDoubleClick ? 'ondblclick="handleItemDoubleClick(this)"' : '';
        
        const typeBadgeHtml = typeLabel ? `
          <div class="assignment-type-badge ${typeBadgeClass}" title="Тип привязки: ${typeLabel}">
            ${typeLabel}
          </div>
        ` : '';
        
        return `
          <div class="thumb${avatarClass}" ${dataAttrs} ${doubleClickHandler}>
            ${thumbUrl ? `<img src="${thumbUrl}" alt="Item ${itemId}" />` : '<div class="noimg">Нет превью</div>'}
            ${typeBadgeHtml}
            ${actionsHtml}
          </div>
        `;
      }
      
      function handleItemDoubleClick(element) {
        const faceId = element.getAttribute('data-face-id');
        const personRectId = element.getAttribute('data-person-rectangle-id');
        const filePath = element.getAttribute('data-file-path');
        const bboxStr = element.getAttribute('data-bbox');
        
        if (faceId) {
          // Для лиц используем существующую функцию
          handleFaceDoubleClick(element);
        } else if (personRectId && bboxStr) {
          // Для прямоугольников открываем фото с выделением области
          let bboxData = null;
          if (bboxStr) {
            try {
              bboxData = JSON.parse(bboxStr.replace(/&quot;/g, '"'));
            } catch (e) {
              console.error('Ошибка парсинга bbox:', e);
            }
          }
          openFaceImage(null, filePath, bboxData, personRectId);
        } else if (filePath) {
          // Для прямой привязки открываем файл целиком
          openFaceImage(null, filePath, null, null);
        }
      }

      function handleFaceDoubleClick(element) {
        const faceId = parseInt(element.getAttribute('data-face-id'));
        const filePath = element.getAttribute('data-file-path');
        const bboxStr = element.getAttribute('data-bbox');
        let bboxData = null;
        if (bboxStr) {
          try {
            bboxData = JSON.parse(bboxStr.replace(/&quot;/g, '"'));
          } catch (e) {
            console.error('Ошибка парсинга bbox:', e);
          }
        }
        
        openFaceImage(faceId, filePath, bboxData);
      }

      function openFaceImage(faceId, filePath, bboxData, personRectangleId = null) {
        // Находим информацию об элементе
        const faces = personData?.faces || [];
        let face = null;
        if (faceId) {
          face = faces.find(f => f.face_id === faceId);
        } else if (personRectangleId) {
          face = faces.find(f => f.person_rectangle_id === personRectangleId);
        } else if (filePath) {
          // Для прямой привязки ищем по file_path
          face = faces.find(f => f.file_path === filePath && f.assignment_type === 'file_person');
        }
        
        const path = face?.file_path || filePath;
        if (!path) {
          console.error('openFaceImage: нет пути к файлу');
          return;
        }
        currentFilePath = path; // Сохраняем путь для исправления клиппинга
        const lb = document.getElementById('lightbox');
        const lbPath = document.getElementById('lbPath');
        const lbImg = document.getElementById('lbImg');
        const lbOpen = document.getElementById('lbOpen');
        const lbRectangle = document.getElementById('lbRectangle');
        const lbFixClipping = document.getElementById('lbFixClipping');
        
        // Показываем кнопку "Исправить клипинг" только для изображений (не для видео)
        if (lbFixClipping) {
          lbFixClipping.style.display = (path && !path.match(/\.(mp4|mov|avi|mkv|webm|m4v|3gp)$/i)) ? '' : 'none';
        }
        
        if (lbPath) lbPath.textContent = path;
        
        // Сохраняем faceId и bbox для отрисовки
        currentFaceId = faceId || personRectangleId;
        if (bboxData && typeof bboxData === 'object') {
          currentFaceBbox = bboxData;
        } else if (face && face.bbox) {
          currentFaceBbox = face.bbox;
        } else {
          currentFaceBbox = null;
        }
        
        
        // Убеждаемся, что currentFaceBbox установлен
        if (!currentFaceBbox) {
          console.error('openFaceImage: ОШИБКА - currentFaceBbox не установлен!', {
            bboxData,
            faceBbox: face?.bbox,
            faceId: face?.face_id
          });
        }
        
        // Проверяем наличие размеров изображения и EXIF orientation, загружаем их, если нужно
        const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
        const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
        if (!hasImageSize || (!hasExifOrientation && path)) {
          // Загружаем размеры изображения и сохраняем в БД
          fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
            .then(res => res.json())
            .then(data => {
              if (data.ok && data.width && data.height) {
                // Обновляем размеры в personData для текущего лица
                if (face) {
                  face.image_size = { 
                    width: data.width, 
                    height: data.height,
                    exif_orientation: data.exif_orientation || null
                  };
                }
                // Перерисовываем rectangles с новыми размерами
                if (lbImg && lbImg.complete) {
                  // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                }
              }
            })
            .catch(err => {
              console.error('Failed to load image dimensions:', err);
            });
        }
        
        // Скрываем rectangle до загрузки изображения
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
        
        // Определяем URL для превью
        let previewUrl = '';
        let openUrl = '';
        
        if (path.startsWith('disk:')) {
          previewUrl = `/api/yadisk/preview-image?size=XL&path=${encodeURIComponent(path)}`;
          openUrl = `/api/yadisk/open?path=${encodeURIComponent(path)}`;
        } else if (path.startsWith('local:')) {
          previewUrl = `/api/local/preview?path=${encodeURIComponent(path)}`;
          openUrl = '#';
        }
        
        if (lbOpen) {
          if (openUrl && openUrl !== '#') {
            lbOpen.href = openUrl;
            lbOpen.style.display = 'inline-block';
          } else {
            lbOpen.style.display = 'none';
          }
        }
        
        // Используем новую карточку фотографий, если доступна
        if (window.openPhotoCard) {
          // Формируем list_context из всех лиц персоны
          const allFaces = personData?.faces || [];
          const currentIndex = allFaces.findIndex(f => f.face_id === currentFaceId);
          
          const items = allFaces.map(f => ({
            file_id: f.file_id || null,
            file_path: f.file_path || null,
            face_rectangle_id: f.face_id || null,
            person_rectangle_id: null,
            pipeline_run_id: f.pipeline_run_id || null,
            run_id: f.run_id || null,
            taken_at: f.taken_at ?? null,
            place_country: f.place_country ?? null,
            place_city: f.place_city ?? null
          }));
          
          const listContext = {
            source_page: "person_detail",
            items: items,
            current_index: currentIndex >= 0 ? currentIndex : 0,
            total_count: items.length,
            api_fallback: null,
            tab: mainTab,
            person_id: personId
          };
          
          // Определяем pipeline_run_id из данных текущего лица (если есть)
          const faceData = allFaces.find(f => f.face_id === currentFaceId);
          const pipelineRunId = faceData?.pipeline_run_id || null;
          
          window.openPhotoCard({
            file_id: face?.file_id || null,
            file_path: path,
            pipeline_run_id: pipelineRunId,
            list_context: listContext,
            highlight_rectangle: {
              type: 'face_rectangle',
              id: currentFaceId
            }
          });
          return; // Выходим, не используем старый lightbox
        }
        
        // Открываем lightbox сразу, не дожидаясь загрузки изображения (fallback)
        openLightbox();
        
        // Загружаем все лица на этом фото
        fetch(`/api/file-faces?file_path=${encodeURIComponent(path)}`)
          .then(res => res.json())
          .then(data => {
            allFacesOnImage = data.faces || [];
            console.log('Loaded faces on image:', allFacesOnImage.length, 'currentFaceId:', currentFaceId, 'faces:', allFacesOnImage);
            // Данные о лицах загружены, но изображение может еще не загрузиться
            // tryDrawAllFaces будет вызван из onload, когда изображение точно загрузится
            // Но если изображение уже загружено, вызываем сразу
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              // Получаем размеры исходного изображения для масштабирования
              const face = personData?.faces?.find(f => f.face_id === currentFaceId);
              const originalImageSize = face?.image_size;
              if (drawAllFaceRectanglesFromModule) {
                drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
              }
              drawFaceRectangleLocal();
            }
          })
          .catch(err => {
            console.error('Failed to load faces on image:', err);
            allFacesOnImage = [];
            // Даже если ошибка, пытаемся нарисовать текущее лицо, если изображение уже загружено
            const lbImgCheck = document.getElementById('lbImg');
            if (lbImgCheck && lbImgCheck.complete) {
              // Получаем размеры исходного изображения для масштабирования
              const face = personData?.faces?.find(f => f.face_id === currentFaceId);
              const originalImageSize = face?.image_size;
              if (drawAllFaceRectanglesFromModule) {
                drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
              }
              drawFaceRectangleLocal();
            }
          });
        
        // Загружаем изображение
        if (lbImg && previewUrl) {
          // Устанавливаем обработчик onload
          lbImg.onload = function() {
            // Проверяем, что элементы действительно готовы в DOM
            const checkAndDraw = () => {
              const lbImgCheck = document.getElementById('lbImg');
              const lbBodyCheck = document.getElementById('lbBody');
              if (lbImgCheck && lbBodyCheck && lbImgCheck.complete) {
                // Теперь изображение точно загружено, рисуем rectangles (если данные о лицах уже загружены)
                if (allFacesOnImage !== undefined) {
                  // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                }
              } else {
                requestAnimationFrame(checkAndDraw);
              }
            };
            
            // Используем requestAnimationFrame для гарантии, что DOM обновлен
            requestAnimationFrame(() => {
              requestAnimationFrame(checkAndDraw);
            });
            
            // Если размеры еще не загружены, пытаемся их получить
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                      // Получаем размеры исходного изображения для масштабирования
                  const face = personData?.faces?.find(f => f.face_id === currentFaceId);
                  const originalImageSize = face?.image_size;
                  if (drawAllFaceRectanglesFromModule) {
                    drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
                  }
                  drawFaceRectangleLocal();
                    });
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawAllFaceRectanglesLocal();
              });
            }
          };
          
          // Если изображение уже загружено и это тот же URL, не перезагружаем
          if (lbImg.src !== previewUrl && !lbImg.src.includes(previewUrl)) {
            lbImg.src = previewUrl;
          } else if (lbImg.complete) {
            // Изображение уже загружено, проверяем размеры и рисуем rectangle
            const face = personData?.faces?.find(f => f.face_id === currentFaceId);
            const hasImageSize = face?.image_size && face.image_size.width && face.image_size.height;
            const hasExifOrientation = face?.image_size?.exif_orientation !== null && face?.image_size?.exif_orientation !== undefined;
            
            // Функция для отрисовки после проверки данных о лицах
            const drawWhenReady = () => {
              if (allFacesOnImage !== undefined) {
                drawAllFaceRectanglesLocal();
              }
            };
            
            if ((!hasImageSize || (!hasExifOrientation && path)) && path) {
              // Загружаем размеры изображения и сохраняем в БД
              fetch(`/api/image-dimensions?path=${encodeURIComponent(path)}&save=true`)
                .then(res => res.json())
                .then(data => {
                  if (data.ok && data.width && data.height) {
                    // Обновляем размеры в personData для текущего лица
                    if (face) {
                      face.image_size = { 
                        width: data.width, 
                        height: data.height,
                        exif_orientation: data.exif_orientation || null
                      };
                    }
                    // Перерисовываем rectangle с новыми размерами
                    // Используем один requestAnimationFrame для уменьшения задержки
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  } else {
                    // Если не удалось получить размеры, рисуем с эвристикой
                    requestAnimationFrame(() => {
                      drawWhenReady();
                    });
                  }
                })
                .catch(err => {
                  console.error('Failed to load image dimensions:', err);
                  // В случае ошибки рисуем с эвристикой
                  requestAnimationFrame(() => {
                    drawWhenReady();
                  });
                });
            } else {
              // Размеры уже есть, просто рисуем
              requestAnimationFrame(() => {
                drawWhenReady();
              });
            }
          }
        }
      }

      function openLightbox() {
        document.getElementById('lightbox').classList.add('open');
      }
      

      function drawFaceRectangleLocal() {
        // Всегда пытаемся получить bbox из personData, если currentFaceBbox не установлен
        if (!currentFaceBbox && currentFaceId) {
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          if (face && face.bbox) {
            currentFaceBbox = face.bbox;
          } else {
            return;
          }
        }
        
        if (!currentFaceBbox) {
          return;
        }
        
        const lbImg = document.getElementById('lbImg');
        if (!lbImg || !lbImg.complete) {
          return;
        }
        
        // Получаем размеры исходного изображения из данных лица
        const face = personData?.faces?.find(f => f.face_id === currentFaceId);
        const originalImageSize = face?.image_size;
        const currentPerson = personData?.person;
        
        // Вызываем функцию из модуля
        if (drawFaceRectangleFromModule) {
          drawFaceRectangleFromModule(
            currentFaceBbox,
            originalImageSize,
            currentPerson?.name,
            currentPerson?.is_me,
            face?.cluster_id
          );
        }
      }

      function drawAllFaceRectanglesLocal() {
        // Обёртка для drawAllFaceRectanglesFromModule
        if (!drawAllFaceRectanglesFromModule) {
          console.warn('[person_detail] drawAllFaceRectanglesFromModule not available');
          return;
        }
        
        const lbImg = document.getElementById('lbImg');
        if (!lbImg || !lbImg.complete) {
          return;
        }
        
        // Получаем размеры исходного изображения из данных лица
        const face = personData?.faces?.find(f => f.face_id === currentFaceId);
        const originalImageSize = face?.image_size;
        
        // Вызываем функцию из модуля
        if (allFacesOnImage && allFacesOnImage.length > 0) {
          drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
        }
      }

      function closeLightbox() {
        document.getElementById('lightbox').classList.remove('open');
        currentFaceBbox = null;
        const lbRectangle = document.getElementById('lbRectangle');
        if (lbRectangle) {
          lbRectangle.style.display = 'none';
        }
      }

      // Закрытие lightbox по клику вне изображения или Escape
      document.addEventListener('click', (e) => {
        const lb = document.getElementById('lightbox');
        if (lb && e.target === lb) {
          closeLightbox();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeLightbox();
        }
      });

      // Перерисовка rectangles при изменении размера окна
      window.addEventListener('resize', () => {
        if (document.getElementById('lightbox').classList.contains('open')) {
          // Получаем размеры исходного изображения для масштабирования
          const face = personData?.faces?.find(f => f.face_id === currentFaceId);
          const originalImageSize = face?.image_size;
          if (drawAllFaceRectanglesFromModule) {
            drawAllFaceRectanglesFromModule(allFacesOnImage || [], currentFaceId, originalImageSize, null);
          }
          drawFaceRectangleLocal();
        }
      });

      async function updatePersonName() {
        const newName = document.getElementById('inputPersonName').value.trim();
        if (!newName) {
          showToast('Имя не может быть пустым', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка обновления имени');
          }
          
          showToast('Имя обновлено');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка обновления имени:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function updatePersonGroup() {
        const groupSelect = document.getElementById('selectPersonGroup');
        const newGroup = groupSelect ? (groupSelect.value || null) : null;
        const currentName = document.getElementById('inputPersonName').value.trim();
        
        if (!currentName) {
          showToast('Имя не может быть пустым', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: currentName, group: newGroup }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка обновления группы');
          }
          
          showToast('Группа обновлена');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка обновления группы:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function saveToGold() {
        const btn = document.getElementById('btnSaveToGold');
        if (!btn) return;
        
        btn.disabled = true;
        btn.textContent = 'Сохранение...';
        
        try {
          const resp = await fetch(`/api/persons/${personId}/save-to-gold`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          });
          
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data.detail || data.error || 'Ошибка сохранения');
          }
          
          showToast(`Сохранено в gold: ${data.faces_count} лиц, ${data.files_updated} файлов`, false);
        } catch (e) {
          showToast(`Ошибка: ${e.message}`, true);
        } finally {
          btn.disabled = false;
          btn.textContent = 'Сохранить в gold';
        }
      }


      async function ignoreFace(faceId) {
        // Убрано подтверждение - выполняем действие сразу
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${faceId}/ignore`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо помечено как "не лицо"');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function assignOutsider(faceId, filePath = null, fileId = null) {
        // Назначаем лицо персоне "Посторонний"
        // faceId может быть как face_id, так и rectangle_id (в контексте photo_rectangles это одно и то же)
        console.log('[assignOutsider] Начинаем назначение на "Посторонний", faceId:', faceId, 'filePath:', filePath, 'fileId:', fileId);
        
        if (!faceId) {
          console.error('[assignOutsider] faceId не передан');
          showToast('Ошибка: не указан ID лица', true);
          return;
        }
        
        try {
          // Получаем список всех персон для поиска "Посторонний"
          if (!allPersons || allPersons.length === 0) {
            console.log('[assignOutsider] Загружаем список персон...');
            const resp = await fetch('/api/persons/list');
            if (!resp.ok) {
              throw new Error(`Не удалось загрузить список персон: HTTP ${resp.status}`);
            }
            const data = await resp.json();
            allPersons = data.persons || [];
            console.log('[assignOutsider] Загружено персон:', allPersons.length);
          }
          
          const outsiderPerson = allPersons.find(p => p.is_ignored === true);
          if (!outsiderPerson) {
            console.error('[assignOutsider] Персона "Посторонний" не найдена в списке');
            showToast('Персона "Посторонний" не найдена', true);
            return;
          }
          
          console.log('[assignOutsider] Найдена персона "Посторонний", ID:', outsiderPerson.id);
          
          // Назначаем лицо персоне "Посторонний" через API обновления rectangle
          // rectangle_id в photo_rectangles это и есть id (face_id)
          const rectangleId = parseInt(faceId);
          if (isNaN(rectangleId)) {
            throw new Error(`Некорректный ID лица: ${faceId}`);
          }
          
          console.log('[assignOutsider] Отправляем запрос на назначение, rectangle_id:', rectangleId, 'person_id:', outsiderPerson.id);
          
          const requestBody = {
            rectangle_id: rectangleId,
            person_id: outsiderPerson.id,
            assignment_type: 'manual_face'
          };
          
          // Для архивных фото добавляем file_id или path
          if (fileId && fileId !== 'null' && fileId !== null) {
            requestBody.file_id = parseInt(fileId);
          } else if (filePath && filePath !== '' && filePath !== 'null') {
            // Убираем экранирование из filePath
            requestBody.path = filePath.replace(/&quot;/g, '"').replace(/&#039;/g, "'");
          }
          
          const resp = await fetch('/api/faces/rectangle/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });
          
          console.log('[assignOutsider] Ответ от API, status:', resp.status, 'ok:', resp.ok);
          
          if (!resp.ok) {
            let errorMsg = 'Ошибка назначения';
            try {
              const errorData = await resp.json();
              errorMsg = errorData.detail || errorData.error || errorMsg;
              console.error('[assignOutsider] Ошибка API:', errorData);
            } catch (parseErr) {
              const text = await resp.text();
              errorMsg = `HTTP ${resp.status}: ${text || resp.statusText}`;
              console.error('[assignOutsider] Ошибка парсинга ответа:', parseErr, 'Текст ответа:', text);
            }
            throw new Error(errorMsg);
          }
          
          const result = await resp.json();
          console.log('[assignOutsider] Успешно назначено, результат:', result);
          
          showToast('Лицо назначено персоне "Посторонний"');
          
          // Оптимистичное обновление: сразу удаляем элемент из таблицы кластеров
          // (лицо больше не принадлежит этой персоне)
          const thumbElement = document.querySelector(`.thumb[data-face-id="${faceId}"]`);
          if (thumbElement) {
            thumbElement.style.opacity = '0.5';
            thumbElement.style.transition = 'opacity 0.3s';
            setTimeout(() => {
              thumbElement.remove();
              // Обновляем счетчик лиц в заголовке таблицы
              const container = thumbElement.closest('.thumb-grid')?.parentElement;
              if (container) {
                const header = container.querySelector('h3');
                if (header) {
                  const remainingThumbs = container.querySelectorAll('.thumb-grid .thumb').length;
                  const clustersCount = container.querySelectorAll('.thumb-grid .thumb').length > 0 ? 
                    new Set(Array.from(container.querySelectorAll('.thumb-grid .thumb')).map(t => t.getAttribute('data-cluster-id'))).size : 0;
                  if (remainingThumbs === 0) {
                    container.innerHTML = '<div class="muted">В кластерах нет лиц</div>';
                  } else {
                    header.textContent = `Кластеры (${clustersCount} кластеров, ${remainingThumbs} лиц)`;
                  }
                }
              }
            }, 300);
          }
          
          // Обновляем счетчики на вкладках в фоне (без блокировки UI)
          loadPerson().then(() => {
            updateTabCounts();
          }).catch(err => {
            console.error('[assignOutsider] Ошибка обновления данных персоны:', err);
          });
        } catch (e) {
          console.error('[assignOutsider] Ошибка назначения на "Посторонний":', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }
      
      async function showReassignDropdown(faceId, buttonElement) {
        // Закрываем все открытые меню
        document.querySelectorAll('.reassign-dropdown-menu.open').forEach(menu => {
          menu.remove();
        });
        
        // Проверяем, не открыто ли уже меню для этого лица
        const existingMenu = document.querySelector(`.reassign-dropdown-menu[data-face-id="${faceId}"]`);
        if (existingMenu) {
          existingMenu.remove();
          return; // Закрываем меню, если оно уже было открыто
        }
        
        currentReassignFaceId = faceId;
        
        // Загружаем список персон
        try {
          const resp = await fetch('/api/persons/list');
          if (!resp.ok) throw new Error('Не удалось загрузить список персон');
          const data = await resp.json();
          allPersons = data.persons || [];
          
          // Загружаем похожие лица
          const similarResp = await fetch(`/api/persons/${personId}/faces/${faceId}/similar?limit=3`);
          let similarFaces = [];
          if (similarResp.ok) {
            const similarData = await similarResp.json();
            similarFaces = similarData.similar_faces || [];
          }
          
          // Создаем меню
          const menu = document.createElement('div');
          menu.className = 'reassign-dropdown-menu open';
          menu.dataset.faceId = faceId;
          
          // Добавляем 3 ближайших по embeddings
          if (similarFaces.length > 0) {
            const section = document.createElement('div');
            section.className = 'menu-section';
            const title = document.createElement('div');
            title.className = 'menu-section-title';
            title.textContent = 'Ближайшие по embeddings:';
            section.appendChild(title);
            
            for (const sf of similarFaces) {
              if (sf.person_id && sf.person_id !== personId) {
                const person = allPersons.find(p => p.id === sf.person_id);
                if (person && !person.is_ignored) {
                  const item = document.createElement('button');
                  item.className = 'menu-item';
                  item.textContent = `${person.name} (${sf.distance.toFixed(3)})`;
                  item.onclick = (e) => {
                    e.stopPropagation();
                    menu.remove();
                    doReassign(faceId, sf.person_id);
                  };
                  section.appendChild(item);
                }
              }
            }
            
            if (section.children.length > 1) { // Больше чем только title
              menu.appendChild(section);
            }
          }
          
          // Группируем остальных персон по группам
          const groupedPersons = {};
          const noGroupPersons = [];
          
          for (const p of allPersons) {
            if (p.id === personId || p.is_ignored) continue;
            const groupName = p.group || null;
            if (groupName) {
              if (!groupedPersons[groupName]) {
                groupedPersons[groupName] = {
                  order: p.group_order || 999,
                  persons: []
                };
              }
              groupedPersons[groupName].persons.push(p);
            } else {
              noGroupPersons.push(p);
            }
          }
          
          // Сортируем группы по order
          const sortedGroups = Object.entries(groupedPersons).sort((a, b) => {
            return a[1].order - b[1].order;
          });
          
          // Сортируем персон внутри каждой группы по имени
          for (const [groupName, groupData] of sortedGroups) {
            groupData.persons.sort((a, b) => {
              const nameA = (a.name || '').toLowerCase();
              const nameB = (b.name || '').toLowerCase();
              return nameA.localeCompare(nameB);
            });
          }
          
          // Сортируем персон без группы по имени
          noGroupPersons.sort((a, b) => {
            const nameA = (a.name || '').toLowerCase();
            const nameB = (b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
          });
          
          // Рендерим группы
          for (const [groupName, groupData] of sortedGroups) {
            const section = document.createElement('div');
            section.className = 'menu-section';
            const title = document.createElement('div');
            title.className = 'menu-section-title';
            title.textContent = groupName;
            section.appendChild(title);
            
            for (const p of groupData.persons) {
              const item = document.createElement('button');
              item.className = 'menu-item';
              item.textContent = p.name + (p.is_me ? ' (я)' : '');
              item.onclick = (e) => {
                e.stopPropagation();
                menu.remove();
                doReassign(faceId, p.id);
              };
              section.appendChild(item);
            }
            menu.appendChild(section);
          }
          
          // Рендерим персон без группы (если есть)
          if (noGroupPersons.length > 0) {
            const section = document.createElement('div');
            section.className = 'menu-section';
            const title = document.createElement('div');
            title.className = 'menu-section-title';
            title.textContent = 'Без группы';
            section.appendChild(title);
            
            for (const p of noGroupPersons) {
              const item = document.createElement('button');
              item.className = 'menu-item';
              item.textContent = p.name + (p.is_me ? ' (я)' : '');
              item.onclick = (e) => {
                e.stopPropagation();
                menu.remove();
                doReassign(faceId, p.id);
              };
              section.appendChild(item);
            }
            menu.appendChild(section);
          }
          
          // Добавляем кнопку "Очистить"
          const clearSection = document.createElement('div');
          clearSection.className = 'menu-section';
          const clearItem = document.createElement('button');
          clearItem.className = 'menu-item';
          clearItem.textContent = 'Очистить (найти ближайший кластер)';
          clearItem.onclick = (e) => {
            e.stopPropagation();
            menu.remove();
            clearFaceAssignmentForFace(faceId);
          };
          clearSection.appendChild(clearItem);
          menu.appendChild(clearSection);
          
          // Позиционируем меню относительно thumb-grid, чтобы избежать обрезания overflow:hidden
          const thumbGrid = buttonElement.closest('.thumb-grid');
          
          if (thumbGrid) {
            // Позиционируем меню относительно thumb-grid (не thumb), чтобы избежать обрезания
            thumbGrid.style.position = 'relative';
            thumbGrid.appendChild(menu);
            
            // Ждем, пока меню отрендерится, чтобы получить его размеры
            setTimeout(() => {
              const buttonRect = buttonElement.getBoundingClientRect();
              const gridRect = thumbGrid.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              
              // Позиционируем меню снизу вверх от кнопки (относительно grid)
              let left = buttonRect.left - gridRect.left;
              let top = buttonRect.top - gridRect.top - menu.offsetHeight - 4; // Вверх от кнопки
              
              // Проверка левого края viewport
              const menuLeftAbsolute = gridRect.left + left;
              if (menuLeftAbsolute < 0) {
                left = -gridRect.left; // Позиционируем по левому краю viewport
              }
              
              // Проверка правого края viewport
              const menuRightAbsolute = gridRect.left + left + menu.offsetWidth;
              if (menuRightAbsolute > viewportWidth) {
                left = viewportWidth - gridRect.left - menu.offsetWidth;
                // Если меню все еще выходит (слишком широкое), позиционируем по правому краю viewport
                if (left < -gridRect.left) {
                  left = -gridRect.left;
                }
              }
              
              // Проверка правого края grid (внутренняя проверка)
              if (left + menu.offsetWidth > gridRect.width) {
                left = gridRect.width - menu.offsetWidth;
                if (left < 0) {
                  left = 0;
                }
              }
              
              // Проверка верхнего края viewport (меню показывается снизу вверх)
              const menuTopAbsolute = gridRect.top + top;
              if (menuTopAbsolute < 0) {
                // Если не влезает сверху, показываем снизу от кнопки
                top = buttonRect.bottom - gridRect.top + 4;
                // Проверяем, не выходит ли снизу за viewport
                const menuBottomAbsolute = gridRect.top + top + menu.offsetHeight;
                if (menuBottomAbsolute > viewportHeight) {
                  // Если не влезает снизу, позиционируем по верхнему краю viewport
                  top = -gridRect.top;
                  // Если все еще не влезает, позиционируем по нижнему краю viewport
                  if (top + menu.offsetHeight > gridRect.height) {
                    top = viewportHeight - gridRect.top - menu.offsetHeight;
                  }
                }
              }
              
              // Проверка нижнего края viewport
              const menuBottomAbsolute = gridRect.top + top + menu.offsetHeight;
              if (menuBottomAbsolute > viewportHeight) {
                // Если не влезает снизу, позиционируем по нижнему краю viewport
                top = viewportHeight - gridRect.top - menu.offsetHeight;
                // Если все еще не влезает, позиционируем по верхнему краю viewport
                if (top < -gridRect.top) {
                  top = -gridRect.top;
                }
              }
              
              // Проверка нижнего края grid (внутренняя проверка)
              if (top + menu.offsetHeight > gridRect.height) {
                // Если не влезает в grid, позиционируем по верхнему краю grid
                top = 0;
              }
              
              menu.style.position = 'absolute';
              menu.style.left = `${left}px`;
              menu.style.top = `${top}px`;
              menu.style.bottom = 'auto';
            }, 0);
          }
          
          // Закрываем меню при клике вне его
          const closeMenu = (e) => {
            if (!menu.contains(e.target) && !buttonElement.contains(e.target)) {
              menu.remove();
              document.removeEventListener('click', closeMenu);
            }
          };
          
          setTimeout(() => {
            document.addEventListener('click', closeMenu);
          }, 10);
        } catch (e) {
          console.error('Ошибка загрузки данных:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }
      
      async function doReassign(faceId, targetPersonId) {
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${faceId}/reassign`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target_person_id: parseInt(targetPersonId) }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка переназначения');
          }
          
          showToast('Лицо переназначено');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка переназначения:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }
      
      async function reassignFace(faceId) {
        // Старая функция для совместимости (если где-то еще используется)
        currentReassignFaceId = faceId;
        
        // Загружаем список персон
        try {
          const resp = await fetch('/api/persons/list');
          if (!resp.ok) throw new Error('Не удалось загрузить список персон');
          const data = await resp.json();
          allPersons = data.persons || [];
          
          // Загружаем похожие лица
          const similarResp = await fetch(`/api/persons/${personId}/faces/${faceId}/similar?limit=3`);
          let similarFaces = [];
          if (similarResp.ok) {
            const similarData = await similarResp.json();
            similarFaces = similarData.similar_faces || [];
          }
          
          // Заполняем выпадашку
          const select = document.getElementById('selectReassignPerson');
          select.innerHTML = '<option value="">Выберите персону...</option>';
          
          // Добавляем 3 ближайших по embeddings
          if (similarFaces.length > 0) {
            const optgroupSimilar = document.createElement('optgroup');
            optgroupSimilar.label = 'Ближайшие по embeddings:';
            for (const sf of similarFaces) {
              if (sf.person_id && sf.person_id !== personId) {
                const person = allPersons.find(p => p.id === sf.person_id);
                if (person && !person.is_ignored) {
                  const opt = document.createElement('option');
                  opt.value = sf.person_id;
                  opt.textContent = `${person.name} (расстояние: ${sf.distance.toFixed(3)})`;
                  optgroupSimilar.appendChild(opt);
                }
              }
            }
            if (optgroupSimilar.children.length > 0) {
              select.appendChild(optgroupSimilar);
            }
          }
          
          // Группируем остальных персон по группам
          const groupedPersons = {};
          const noGroupPersons = [];
          
          for (const p of allPersons) {
            if (p.id === personId || p.is_ignored) continue;
            const groupName = p.group || null;
            if (groupName) {
              if (!groupedPersons[groupName]) {
                groupedPersons[groupName] = {
                  order: p.group_order || 999,
                  persons: []
                };
              }
              groupedPersons[groupName].persons.push(p);
            } else {
              noGroupPersons.push(p);
            }
          }
          
          // Сортируем группы по order
          const sortedGroups = Object.entries(groupedPersons).sort((a, b) => {
            return a[1].order - b[1].order;
          });
          
          // Сортируем персон внутри каждой группы по имени
          for (const [groupName, groupData] of sortedGroups) {
            groupData.persons.sort((a, b) => {
              const nameA = (a.name || '').toLowerCase();
              const nameB = (b.name || '').toLowerCase();
              return nameA.localeCompare(nameB);
            });
          }
          
          // Сортируем персон без группы по имени
          noGroupPersons.sort((a, b) => {
            const nameA = (a.name || '').toLowerCase();
            const nameB = (b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
          });
          
          // Рендерим группы
          for (const [groupName, groupData] of sortedGroups) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = groupName;
            for (const p of groupData.persons) {
              const opt = document.createElement('option');
              opt.value = p.id;
              opt.textContent = p.name + (p.is_me ? ' (я)' : '');
              optgroup.appendChild(opt);
            }
            select.appendChild(optgroup);
          }
          
          // Рендерим персон без группы (если есть)
          if (noGroupPersons.length > 0) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = 'Без группы';
            for (const p of noGroupPersons) {
              const opt = document.createElement('option');
              opt.value = p.id;
              opt.textContent = p.name + (p.is_me ? ' (я)' : '');
              optgroup.appendChild(opt);
            }
            select.appendChild(optgroup);
          }
          
          openModal('modalReassign');
        } catch (e) {
          console.error('Ошибка загрузки данных:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function confirmReassign() {
        const targetPersonId = document.getElementById('selectReassignPerson').value;
        if (!targetPersonId) {
          showToast('Выберите персону', true);
          return;
        }
        
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/reassign`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target_person_id: parseInt(targetPersonId) }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка переназначения');
          }
          
          showToast('Лицо переназначено');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка переназначения:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function clearFaceAssignmentForFace(faceId) {
        // Убрано подтверждение - выполняем действие сразу
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${faceId}/clear`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо удалено из персоны');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }
      
      async function clearFaceAssignment() {
        // Старая функция для совместимости (используется в модальном окне)
        // Убрано подтверждение - выполняем действие сразу
        try {
          const resp = await fetch(`/api/persons/${personId}/faces/${currentReassignFaceId}/clear`, {
            method: 'POST',
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка');
          }
          
          showToast('Лицо удалено из персоны');
          closeModal('modalReassign');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      async function setAvatar(faceId) {
        try {
          const resp = await fetch(`/api/persons/${personId}/set-avatar`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ face_id: faceId }),
          });
          
          if (!resp.ok) {
            const err = await resp.json();
            throw new Error(err.detail || 'Ошибка установки аватара');
          }
          
          showToast('Аватар установлен');
          await loadPerson();
        } catch (e) {
          console.error('Ошибка установки аватара:', e);
          showToast(`Ошибка: ${e.message}`, true);
        }
      }

      function openModal(modalId) {
        document.getElementById(modalId).classList.add('show');
      }

      function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('show');
      }

      // Обработчик кнопки "Исправить клипинг"
      async function handleFixClipping() {
        if (!currentFilePath) {
          showToast('Нет пути к файлу', true);
          return;
        }
        
        // Получаем face_run_id из первого лица персоны (все лица персоны должны быть из одного run)
        const firstFace = personData?.faces?.[0];
        if (!firstFace || !firstFace.face_run_id) {
          showToast('Не найден run_id для исправления клиппинга', true);
          return;
        }
        
        const btn = document.getElementById('lbFixClipping');
        if (!btn) {
          return;
        }
        
        try {
          btn.disabled = true;
          const resp = await fetch('/api/faces/fix-clipping', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              face_run_id: Number(firstFace.face_run_id),
              path: currentFilePath,
            }),
          });
          
          if (!resp.ok) {
            let errorDetail = '';
            try {
              const errorJson = await resp.json();
              errorDetail = errorJson.detail || errorJson.error || JSON.stringify(errorJson);
            } catch {
              const errorText = await resp.text();
              errorDetail = errorText || `HTTP ${resp.status}`;
            }
            showToast(`Ошибка ${resp.status}: ${errorDetail}`, true);
            return;
          }
          
          const res = await resp.json();
          if (res.ok) {
            // Сохраняем текущие данные для обновления после перезагрузки
            const savedFaceId = currentFaceId;
            const savedFilePath = currentFilePath;
            
            // Перезагружаем персону, чтобы обновить bbox в отображении
            await loadPerson();
            
            // Если lightbox открыт, принудительно переоткрываем его
            if (savedFaceId) {
              const faceEl = document.querySelector(`[data-face-id="${savedFaceId}"]`);
              if (faceEl) {
                // Обновляем bbox из обновлённого personData перед переоткрытием
                const faces = personData?.faces || [];
                const face = faces.find(f => f.face_id === savedFaceId);
                if (face && face.bbox) {
                  const bboxJson = JSON.stringify(face.bbox).replace(/"/g, '&quot;');
                  faceEl.setAttribute('data-bbox', bboxJson);
                }
                handleFaceDoubleClick(faceEl);
              }
            }
          } else {
            const errorMsg = res.detail || 'Ошибка пересчёта';
            showToast(errorMsg, true);
          }
        } catch (e) {
          const errorMsg = e?.message || String(e);
          showToast('Ошибка: ' + errorMsg, true);
        } finally {
          btn.disabled = false;
        }
      }

      // Инициализация
      document.getElementById('btnUpdateName').addEventListener('click', updatePersonName);
      document.getElementById('btnUpdateGroup').addEventListener('click', updatePersonGroup);
      document.getElementById('btnSaveToGold').addEventListener('click', saveToGold);
      document.getElementById('inputPersonName').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') updatePersonName();
      });
      
      // Обработчик кнопки "Исправить клипинг"
      const btnFixClipping = document.getElementById('lbFixClipping');
      if (btnFixClipping) {
        btnFixClipping.onclick = handleFixClipping;
      }
      
      // Функция для позиционирования на нужный элемент после обновления списка
      function focusOnRectangle(focusData) {
        if (!focusData) return;
        
        // Ищем элемент в обновленном списке по file_id + rectangle_id
        const { file_id, file_path, face_rectangle_id, person_rectangle_id } = focusData;
        
        // Ищем элемент в сетке лиц
        const thumbElements = document.querySelectorAll('.thumb[data-face-id], .thumb[data-person-rectangle-id], .thumb[data-file-id], .thumb[data-file-path]');
        
        for (const thumb of thumbElements) {
          const thumbFileId = thumb.getAttribute('data-file-id');
          const thumbFilePath = thumb.getAttribute('data-file-path');
          const thumbFaceId = thumb.getAttribute('data-face-id');
          const thumbPersonRectId = thumb.getAttribute('data-person-rectangle-id');
          
          // Проверяем совпадение по file_id или file_path
          const fileMatches = (file_id && thumbFileId && parseInt(thumbFileId) === file_id) ||
                             (file_path && thumbFilePath === file_path);
          
          if (fileMatches) {
            // Проверяем совпадение rectangle_id
            const rectMatches = (face_rectangle_id && thumbFaceId && parseInt(thumbFaceId) === face_rectangle_id) ||
                               (person_rectangle_id && thumbPersonRectId && parseInt(thumbPersonRectId) === person_rectangle_id);
            
            if (rectMatches || (!face_rectangle_id && !person_rectangle_id)) {
              // Прокручиваем к элементу и выделяем его
              thumb.scrollIntoView({ behavior: 'smooth', block: 'center' });
              thumb.focus(); // Если элемент фокусируемый
              
              // Визуальное выделение (опционально)
              thumb.style.outline = '3px solid #0b57d0';
              setTimeout(() => {
                thumb.style.outline = '';
              }, 2000);
              
              console.log('[person_detail] Элемент найден и сфокусирован:', focusData);
              return; // Найден и сфокусирован
            }
          }
        }
        
        console.warn('[person_detail] Элемент для фокусировки не найден:', focusData);
      }
      
      // Обработчик события закрытия карточки фотографий
      window.addEventListener('photoCardClosed', async function(event) {
        if (event.detail.source_page === 'person_detail') {
          console.log('[person_detail] Карточка фотографий закрыта, обновляем список персоны');
          
          // Сохраняем данные для позиционирования после обновления
          const focusData = {
            file_id: event.detail.file_id,
            file_path: event.detail.file_path,
            face_rectangle_id: event.detail.face_rectangle_id,
            person_rectangle_id: event.detail.person_rectangle_id,
            rectangle_id: event.detail.rectangle_id
          };
          
          // Обновляем список
          await loadPerson();
          
          // Обновляем счетчики после обновления данных
          updateTabCounts();
          
          // Позиционируемся на нужный элемент после обновления
          // Используем setTimeout для того, чтобы DOM успел обновиться
          setTimeout(() => {
            focusOnRectangle(focusData);
          }, 100);
        }
      });
      
      // Инициализация обработчиков событий
      document.getElementById('btnViewModeGeneral')?.addEventListener('click', () => setViewMode('general'));
      document.getElementById('btnViewModeDetailed')?.addEventListener('click', () => setViewMode('detailed'));
      document.getElementById('tabArchive')?.addEventListener('click', () => setMainTab('archive'));
      document.getElementById('tabRun')?.addEventListener('click', () => setMainTab('run'));
      document.getElementById('subArchiveFaces')?.addEventListener('click', () => setSubtab('faces'));
      document.getElementById('subArchiveRectangles')?.addEventListener('click', () => setSubtab('rectangles'));
      document.getElementById('subArchiveDirect')?.addEventListener('click', () => setSubtab('direct'));
      document.getElementById('subRunFaces')?.addEventListener('click', () => setSubtab('faces'));
      document.getElementById('subRunRectangles')?.addEventListener('click', () => setSubtab('rectangles'));
      document.getElementById('subRunDirect')?.addEventListener('click', () => setSubtab('direct'));
      
      // Обработчик для переключателя фильтра
      document.getElementById('manualFilterSelect')?.addEventListener('change', (e) => {
        manualFilterMode = e.target.value;
        renderFaces();
      });
      
      // Инициализация при загрузке страницы
      loadPerson();
    </script>
    
    <!-- Подключение единой карточки фотографий -->
    {% include "photo_card.html" %}
    <script src="/static/photo_card.js?v=48"></script>
  </body>
</html>
