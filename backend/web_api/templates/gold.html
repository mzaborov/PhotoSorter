<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- YaDisk preview hotlink защита: просим браузер не слать Referer при загрузке картинок -->
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Gold (debug)</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1200px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.primary { border-color:#0b57d0; background:#0b57d0; color:#fff; }
      .btn.primary:hover { background:#0948b3; border-color:#0948b3; }
      .btn.danger { border-color:#fecaca; background:#fff5f5; color:#991b1b; }
      .btn.danger:hover { background:#ffecec; }
      .tabs { display:flex; gap:8px; margin-top: 14px; flex-wrap:wrap; }
      .tab { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:999px; cursor:pointer; font-weight:700; }
      .tab.active { background:#111827; color:#fff; border-color:#111827; }
      .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 12px; }
      input[type="text"], input[type="number"] { padding: 8px 10px; border: 1px solid #e5e7eb; border-radius: 10px; min-width: 280px; }
      /* like /faces */
      .grid { display:flex; gap:10px; flex-wrap:wrap; margin-top: 14px; }
      .card { width: 240px; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; background:#fff; }
      .thumb { height: 140px; background:#fff; display:flex; align-items:center; justify-content:center; position:relative; cursor: zoom-in; }
      .thumb img { width: 100%; height: 100%; object-fit: contain; display:block; background:#fff; }
      .thumb video { width: 100%; height: 100%; object-fit: contain; display:block; background:#111827; }
      .thumb .noimg { color:#6b7280; font-size:12px; padding:10px; text-align:center; }
      .vfbtn {
        position: absolute;
        right: 8px;
        top: 8px;
        z-index: 5;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.55);
        background: rgba(17,24,39,0.72);
        color: #fff;
        font-size: 12px;
        font-weight: 800;
        cursor: pointer;
        user-select: none;
      }
      .vfbtn:hover { background: rgba(17,24,39,0.85); }
      .card-body { padding: 10px 10px 12px 10px; }
      .path { font-size: 12px; word-break: break-all; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; font-size:12px; color:#374151; }
      .actions { display:flex; gap:8px; align-items:center; margin-top: 10px; flex-wrap: wrap; }
      .toast { font-size: 13px; }
      .toast.err { color: #991b1b; }
      .small { font-size: 12px; }
      .pager { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 12px; }
      .sentinel { height: 1px; }

      /* Lightbox */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(1200px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-top code { font-size: 11px; }
      .lb-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; padding: 10px; }
      .imgwrap { position: relative; display: inline-block; }
      .imgwrap img { max-width: 92vw; max-height: calc(92vh - 140px); width: auto; height: auto; display: block; background: #111827; }
      .imgwrap canvas { position: absolute; left: 0; top: 0; pointer-events: none; }
      .lb-bottom { padding: 10px 12px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
      .rectlist { display:flex; gap:8px; flex-wrap:wrap; }
      .rectpill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#1f2937; font-size:12px; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <div>
          <h2 style="margin:0;">Gold (debug)</h2>
          <div class="muted" style="margin-top:6px;">
            Тут редактируем `regression/cases/*_gold.txt` и можем обновить gold из SQLite по ручным правкам (append-only).
          </div>
        </div>
        <div class="muted">
          <a href="/">← на главную</a>
        </div>
      </div>

      <div class="toolbar">
        <span class="pill">файл: <b id="curName">—</b></span>
        <span class="pill">строк: <b id="curCount">—</b></span>
        <button class="btn primary" id="btnReload" type="button">Обновить список</button>
        <button class="btn primary" id="btnUpdateFromDb" type="button" title="Append-only: дописывает новые пути из БД, старые не трогает.">
          Обновить gold из базы
        </button>
        <button class="btn primary" id="btnApplyToDb" type="button" title="Append-only: переносит разметку из gold в БД, НЕ перетирая уже размеченные файлы.">
          Заполнить ручную разметку из gold
        </button>
        <span class="muted" id="toast"></span>
      </div>

      <!-- 1st-level tabs -->
      <div class="tabs" id="level1Tabs">
        <button class="tab active" data-view="lists" type="button">Списки</button>
        <button class="tab" data-view="faces" type="button">Лица</button>
        <button class="tab" data-view="reports" type="button">Отчёты</button>
      </div>

      <div id="viewLists">
        <div class="tabs" id="tabs"></div>
      </div>

      <div id="viewFaces" style="display:none;">
        <div class="tabs" id="facesTabs"></div>
        <div class="grid" id="facesGrid" style="margin-top:14px;"></div>
      </div>

      <div id="viewReports" style="display:none;">
        <div class="tabs" id="reportTabs">
          <button class="tab active" data-report="duplicates" type="button">Дубли</button>
          <button class="tab" data-report="runs" type="button">Статистика прогонов</button>
        </div>

        <div class="section" id="reportsDuplicates" style="margin-top:14px; border:1px solid #e5e7eb; border-radius:14px; padding:12px 14px; background:#fff;">
          <div class="row" style="justify-content: space-between;">
            <div>
              <div style="font-weight:800;">Duplicates в gold</div>
              <div class="muted small" style="margin-top:6px;">Пути, которые встречаются в нескольких `*_gold.txt` одновременно.</div>
            </div>
            <div class="muted small">Кнопки “Оставить в …” удаляют путь из остальных gold‑списков.</div>
          </div>
        </div>

        <div class="section" id="reportsRuns" style="display:none; margin-top:14px; border:1px solid #e5e7eb; border-radius:14px; padding:12px 14px; background:#fff;">
          <div class="row" style="justify-content: space-between;">
            <div>
              <div style="font-weight:800;">Прогоны и метрики (по gold)</div>
              <div class="muted small" style="margin-top:6px;">
                Метрики считаются “как в UI” (effective). Для старых прогонов без снапшота может быть “—”.
              </div>
            </div>
            <div class="row">
              <input id="runsLimit" type="number" min="5" step="5" value="20" style="min-width:120px;" title="Сколько последних прогонов показать" />
              <label class="muted small" style="display:flex; align-items:center; gap:6px; user-select:none;">
                <input id="runsIncludeFailed" type="checkbox" />
                показывать failed
              </label>
              <button class="btn" id="btnRunsReload" type="button">Обновить</button>
            </div>
          </div>
          <div style="overflow:auto; margin-top:10px;">
            <table style="border-collapse: collapse; width: 100%; min-width: 980px;">
              <thead>
                <tr>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Прогон</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Статус</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Начало</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Окончание</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Отсортировано (шаг 2)</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Коты мимо</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Лица мимо</th>
                  <th style="border-bottom:1px solid #e5e7eb; padding:8px 6px;">Нет лиц мимо</th>
                </tr>
              </thead>
              <tbody id="runsTbody">
                <tr><td colspan="8" class="muted" style="padding:10px 6px;">—</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- shared list UI (used by: Lists + Reports/Duplicates) -->
      <div id="listUi">
        <div class="toolbar" style="margin-top:12px;">
          <input id="q" type="text" placeholder="поиск по подстроке (например IMG-2024)" />
          <input id="pipelineRunId" type="number" min="0" step="1" placeholder="pipeline_run_id (по умолчанию: последний)" />
          <input id="limit" type="number" min="20" step="20" value="120" style="min-width:120px;" title="Размер пачки для дочитки (infinite scroll)" />
        </div>

        <div class="muted small" style="margin-top:6px;">
          Подсказка: если `pipeline_run_id` пустой — берём последний прогон. Если указан — ограничиваем только root этого прогона.
        </div>

        <div class="pager">
          <span class="pill">всего: <b id="curTotal">—</b></span>
          <span class="pill">загружено: <b id="curLoaded">0</b></span>
          <button class="btn" id="btnLoadMore" type="button">Дочитать ещё</button>
        </div>

        <div class="grid" id="grid"></div>
        <div class="sentinel" id="sentinel"></div>
      </div>
    </div>

    <div class="lb" id="lightbox" aria-hidden="true">
      <div class="lb-panel" role="dialog" aria-modal="true">
        <div class="lb-top">
          <code id="lbPath">—</code>
          <div class="lb-actions">
            <button class="btn" id="lbClose" type="button">Закрыть</button>
          </div>
        </div>
        <div class="lb-body">
          <div class="imgwrap" id="imgWrap">
            <img id="lbImg" alt="preview" />
            <canvas id="lbCanvas"></canvas>
          </div>
        </div>
        <div class="lb-bottom">
          <div class="muted">Прямоугольники:</div>
          <div class="rectlist" id="rectList"></div>
        </div>
      </div>
    </div>

    <script>
      function qs(sel, el=document) { return el.querySelector(sel); }
      function qsa(sel, el=document) { return Array.from(el.querySelectorAll(sel)); }
      function escapeHtml(s) {
        return (s ?? "").toString()
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#039;");
      }
      async function fetchJson(url, opts={}) {
        const r = await fetch(url, { cache:"no-store", ...opts });
        const t = await r.text();
        let j = null;
        try { j = t ? JSON.parse(t) : null; } catch (e) { j = null; }
        if (!r.ok) throw new Error((j && (j.detail || j.error || j.message)) ? (j.detail || j.error || j.message) : (t || `HTTP ${r.status}`));
        return j;
      }
      async function postJson(url, payload) {
        return await fetchJson(url, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload ?? {}) });
      }
      function setToast(msg, isErr=false) {
        const el = qs("#toast");
        el.textContent = msg || "";
        el.classList.toggle("err", !!isErr);
      }
      function getIntVal(id) {
        const v = Number(qs(id)?.value ?? "");
        return Number.isFinite(v) && v > 0 ? Math.floor(v) : null;
      }

      let names = [];
      let listNames = [];
      let nameCounts = {};
      let cur = null;
      let nextCursor = null;
      let hasMore = false;
      let loading = false;
      const cardByRaw = new Map();
      const itemByRaw = new Map();
      let view = "lists";      // 'lists'|'reports'
      let report = "duplicates"; // 'duplicates'|'runs'

      function fmtMiss(obj) {
        if (obj && obj.total === null) return "—";
        const total = Number(obj?.total ?? 0);
        const mism = Number(obj?.mism ?? 0);
        if (!Number.isFinite(total) || total <= 0) return "—";
        const pct = (100.0 * mism / total);
        return `${mism}/${total} (${pct.toFixed(1)}%)`;
      }

      function fmtSorted(proc, total) {
        const t = (total == null) ? null : Number(total);
        const p = (proc == null) ? null : Number(proc);
        if (t == null || !Number.isFinite(t) || t <= 0) return "—";
        if (p == null || !Number.isFinite(p)) return `${t}`;
        return `${p}/${t}`;
      }

      async function loadRunsMetrics() {
        const tb = qs("#runsTbody");
        if (!tb) return;
        const lim = Number(qs("#runsLimit")?.value ?? 20);
        const limit = Number.isFinite(lim) ? Math.max(5, Math.min(200, Math.floor(lim))) : 20;
        const includeFailed = !!qs("#runsIncludeFailed")?.checked;
        tb.innerHTML = `<tr><td colspan="8" class="muted" style="padding:10px 6px;">загрузка…</td></tr>`;
        try {
          const q = `limit=${encodeURIComponent(String(limit))}&include_failed=${includeFailed ? "1" : "0"}`;
          const j = await fetchJson(`/api/gold/runs-metrics?${q}`, { cache:"no-store" });
          const items = Array.isArray(j?.items) ? j.items : [];
          if (!items.length) {
            tb.innerHTML = `<tr><td colspan="8" class="muted" style="padding:10px 6px;">нет прогонов</td></tr>`;
            return;
          }
          tb.innerHTML = items.map(r => {
            const rid = r?.pipeline_run_id ?? "—";
            const st = (r?.status ?? "—").toString();
            const sa = (r?.started_at ?? "—").toString();
            const fa = (r?.finished_at ?? "—").toString();
            const sorted = fmtSorted(r?.sorted_step2_processed, r?.sorted_step2_total);
            const src = (r?.metrics_source ?? "").toString();
            const hint = (src === "snapshot")
              ? "снапшот (стабильно)"
              : ((src === "pending")
                ? "прогон ещё идёт: метрики появятся после завершения (снапшот)"
                : "нет снапшота для этого прогона");
            return `
              <tr>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;"><a href="/faces?pipeline_run_id=${encodeURIComponent(String(rid))}" target="_blank" rel="noopener noreferrer">${escapeHtml(String(rid))}</a></td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;">${escapeHtml(st)}</td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;"><code>${escapeHtml(sa)}</code></td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;"><code>${escapeHtml(fa)}</code></td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;">${escapeHtml(String(sorted))}</td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;" title="${escapeHtml(hint)}">${escapeHtml(fmtMiss(r?.cats))}</td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;" title="${escapeHtml(hint)}">${escapeHtml(fmtMiss(r?.faces))}</td>
                <td style="border-bottom:1px solid #f3f4f6; padding:8px 6px;" title="${escapeHtml(hint)}">${escapeHtml(fmtMiss(r?.no_faces))}</td>
              </tr>
            `;
          }).join("");
        } catch (e) {
          tb.innerHTML = `<tr><td colspan="8" class="muted" style="padding:10px 6px;">ошибка: ${escapeHtml(e?.message || String(e))}</td></tr>`;
        }
      }

      // lightbox
      const lb = qs("#lightbox");
      const lbImg = qs("#lbImg");
      const lbPath = qs("#lbPath");
      const lbCanvas = qs("#lbCanvas");
      const lbCtx = lbCanvas.getContext("2d");
      const rectList = qs("#rectList");
      let curRects = [];
      function closeLb() {
        lb.classList.remove("open");
        lb.setAttribute("aria-hidden","true");
        lbImg.src = "";
        lbPath.textContent = "—";
        curRects = [];
        if (rectList) rectList.innerHTML = "";
        if (lbCtx) lbCtx.clearRect(0,0,lbCanvas.width, lbCanvas.height);
      }
      function resizeCanvasToImage() {
        const w = lbImg.clientWidth;
        const h = lbImg.clientHeight;
        lbCanvas.width = Math.max(1, Math.floor(w));
        lbCanvas.height = Math.max(1, Math.floor(h));
        lbCanvas.style.width = w + "px";
        lbCanvas.style.height = h + "px";
      }
      function drawRects() {
        if (!lbCtx) return;
        resizeCanvasToImage();
        lbCtx.clearRect(0,0,lbCanvas.width, lbCanvas.height);
        const iw = lbImg.naturalWidth || 1;
        const ih = lbImg.naturalHeight || 1;
        const sx = lbCanvas.width / iw;
        const sy = lbCanvas.height / ih;
        lbCtx.lineWidth = 2;
        lbCtx.strokeStyle = "rgba(59,130,246,0.95)";
        (curRects || []).forEach(r => {
          lbCtx.strokeRect(Number(r.x||0) * sx, Number(r.y||0) * sy, Number(r.w||0) * sx, Number(r.h||0) * sy);
        });
      }
      function renderRectList() {
        if (!rectList) return;
        if (!curRects || !curRects.length) {
          rectList.innerHTML = `<span class="muted">—</span>`;
          return;
        }
        rectList.innerHTML = curRects.map((r, i) => `<span class="rectpill">#${i+1} ${Number(r.w||0)}×${Number(r.h||0)}</span>`).join("");
      }
      function openLb(it) {
        const pv = it?.preview_url || "";
        if (!pv) return;
        lbImg.src = pv;
        lbPath.textContent = it?.raw_path || it?.path || "—";
        curRects = Array.isArray(it?.manual_rects) ? it.manual_rects : [];
        lb.classList.add("open");
        lb.setAttribute("aria-hidden","false");
        renderRectList();
        // draw after image loads
        lbImg.onload = () => drawRects();
        lbImg.onerror = () => { curRects = []; renderRectList(); drawRects(); };
      }
      qs("#lbClose").onclick = () => closeLb();
      lb.addEventListener("click", (e) => { if (e.target === lb) closeLb(); });
      document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeLb(); });

      function renderTabs() {
        const el = qs("#tabs");
        const show = (view === "lists") ? (listNames || []) : [];
        el.innerHTML = show.map(n => {
          const active = (n === cur) ? "active" : "";
          const cnt = Number(nameCounts?.[n] ?? 0);
          const badge = Number.isFinite(cnt) ? ` <span class="pill" style="margin-left:6px;">${cnt}</span>` : "";
          return `<button class="tab ${active}" data-name="${escapeHtml(n)}" type="button">${escapeHtml(n)}${badge}</button>`;
        }).join("");
        el.querySelectorAll("button.tab[data-name]").forEach(b => {
          b.addEventListener("click", () => {
            cur = b.getAttribute("data-name");
            resetList();
            renderTabs();
            loadList();
          });
        });
      }

      async function loadNames() {
        const data = await fetchJson("/api/gold/names");
        names = Array.isArray(data?.names) ? data.names : [];
        nameCounts = (data?.counts && typeof data.counts === "object") ? data.counts : {};
        listNames = (names || []).filter(n => n !== "duplicates" && n !== "faces_manual_rects");
        if (view === "lists") {
          if (!cur && listNames.length) cur = listNames[0];
          if (cur && !listNames.includes(cur)) cur = listNames[0] || null;
        }
        renderTabs();
      }

      function renderLevel1Tabs() {
        qsa("#level1Tabs button.tab[data-view]").forEach(b => {
          const v = b.getAttribute("data-view") || "";
          b.classList.toggle("active", v === view);
        });
      }
      function renderReportTabs() {
        qsa("#reportTabs button.tab[data-report]").forEach(b => {
          const r = b.getAttribute("data-report") || "";
          b.classList.toggle("active", r === report);
        });
      }
      function setReport(next) {
        report = next || "duplicates";
        renderReportTabs();
        const dup = qs("#reportsDuplicates");
        const runs = qs("#reportsRuns");
        if (dup) dup.style.display = (report === "duplicates") ? "" : "none";
        if (runs) runs.style.display = (report === "runs") ? "" : "none";
        if (report === "runs") {
          // hide list UI, show metrics
          qs("#listUi").style.display = "none";
          loadRunsMetrics();
        } else {
          // show list UI in duplicates mode, but without gold tabs
          qs("#listUi").style.display = "";
          qs("#tabs").style.display = "none";
          cur = "duplicates";
          resetList();
          loadList(true);
        }
      }
      let facesPersons = [];
      let currentPersonId = null;

      async function loadFacesByPersons() {
        try {
          const data = await fetchJson("/api/gold/faces-by-persons");
          facesPersons = Array.isArray(data?.persons) ? data.persons : [];
          // Устанавливаем первую персону (исключая "Не назначено" и "Посторонние" для первой загрузки)
          if (facesPersons.length > 0 && currentPersonId === null) {
            // Ищем первую персону, которая не "Не назначено" и не "Посторонние"
            const firstRegularPerson = facesPersons.find(p => 
              p.person_id !== null && 
              p.person_name !== "Не назначено" && 
              p.person_name !== "Посторонние"
            );
            currentPersonId = firstRegularPerson ? firstRegularPerson.person_id : facesPersons[0].person_id;
          }
          renderFacesTabs();
          renderFacesGrid();
        } catch (e) {
          setToast(`Ошибка загрузки лиц: ${e.message}`, true);
        }
      }

      function renderFacesTabs() {
        const el = qs("#facesTabs");
        if (!el) return;
        el.innerHTML = facesPersons.map(p => {
          // Сравниваем person_id с учетом null
          let isActive = false;
          if (currentPersonId === null) {
            isActive = (p.person_id === null);
          } else {
            isActive = (p.person_id === currentPersonId);
          }
          const active = isActive ? "active" : "";
          const count = Array.isArray(p.faces) ? p.faces.length : 0;
          const name = escapeHtml(p.person_name || "Неизвестно");
          return `<button class="tab ${active}" data-person-id="${p.person_id !== null ? p.person_id : 'null'}" type="button">${name} <span class="pill" style="margin-left:6px;">${count}</span></button>`;
        }).join("");
        el.querySelectorAll("button.tab[data-person-id]").forEach(b => {
          b.addEventListener("click", () => {
            const pid = b.getAttribute("data-person-id");
            currentPersonId = (pid === "null") ? null : (pid ? Number(pid) : null);
            renderFacesTabs();
            renderFacesGrid();
          });
        });
      }

      async function renderFacesGrid() {
        const el = qs("#facesGrid");
        if (!el) return;
        // Ищем персону с учетом null для "Не назначено"
        const person = facesPersons.find(p => {
          if (currentPersonId === null) {
            return p.person_id === null;
          }
          return p.person_id === currentPersonId;
        });
        if (!person) {
          el.innerHTML = `<div class="muted">Выберите персону</div>`;
          return;
        }
        const faces = Array.isArray(person.faces) ? person.faces : [];
        if (!faces.length) {
          el.innerHTML = `<div class="muted">Нет лиц для этой персоны</div>`;
          return;
        }
        // Используем тот же паттерн, что в cardHtml() - просто img с loading="lazy"
        el.innerHTML = faces.map((face) => {
          const raw = face.file_path || "";
          const path = face.file_path || raw;
          const display = face.path_short || raw;
          const kind = face.preview_kind || "none";
          let pv = face.preview_url || "";
          const bbox = face.bbox || {};
          
          // Используем тот же паттерн, что в duplicates.html - всегда через прокси для disk: путей
          // Для disk: путей ВСЕГДА используем прокси URL, даже если есть preview_url
          // (прокси возвращает redirect, браузер автоматически следует за redirect)
          if (path && path.startsWith("disk:")) {
            pv = `/api/yadisk/preview-image?size=M&path=${encodeURIComponent(path)}`;
          }
          // Для других путей используем preview_url если есть
          
          const thumb = (kind === "image" && pv)
            ? `<img loading="lazy" referrerpolicy="no-referrer" src="${escapeHtml(pv)}" alt="preview" />`
            : (kind === "video" && pv)
              ? `<video controls muted preload="metadata" src="${escapeHtml(pv)}"></video>`
              : `<div class="noimg">—</div>`;
          
          return `
            <div class="card" data-path="${escapeHtml(path)}" data-bbox-x="${bbox.x || 0}" data-bbox-y="${bbox.y || 0}" data-bbox-w="${bbox.w || 0}" data-bbox-h="${bbox.h || 0}">
              <div class="thumb" data-act="lb">
                ${thumb}
              </div>
              <div class="card-body">
                <div class="path"><code title="${escapeHtml(raw)}">${escapeHtml(display)}</code></div>
                <div class="kv">
                  <span class="pill">x: ${bbox.x || 0}, y: ${bbox.y || 0}</span>
                  <span class="pill">w: ${bbox.w || 0}, h: ${bbox.h || 0}</span>
                </div>
              </div>
            </div>
          `;
        }).join("");
        // Добавляем обработчики кликов для lightbox
        el.querySelectorAll(".thumb[data-act='lb']").forEach(thumb => {
          thumb.addEventListener("click", () => {
            const card = thumb.closest(".card");
            if (!card) return;
            const path = card.getAttribute("data-path") || "";
            const bboxX = Number(card.getAttribute("data-bbox-x") || 0);
            const bboxY = Number(card.getAttribute("data-bbox-y") || 0);
            const bboxW = Number(card.getAttribute("data-bbox-w") || 0);
            const bboxH = Number(card.getAttribute("data-bbox-h") || 0);
            const face = faces.find(f => f.file_path === path && f.bbox.x === bboxX && f.bbox.y === bboxY);
            if (face) {
              // Используем preview_url из face или создаем из path
              let previewUrl = face.preview_url || "";
              if (!previewUrl && path) {
                if (path.startsWith("disk:")) {
                  previewUrl = `/api/yadisk/preview-image?size=M&path=${encodeURIComponent(path)}`;
                } else if (path.startsWith("local:")) {
                  previewUrl = `/api/local/preview?path=${encodeURIComponent(path)}`;
                }
              }
              if (previewUrl) {
                openLb({
                  raw_path: path,
                  path: path,
                  preview_url: previewUrl,
                  manual_rects: [face.bbox],
                });
              }
            }
          });
        });
      }

      function setView(next) {
        view = next || "lists";
        renderLevel1Tabs();
        const vLists = qs("#viewLists");
        const vFaces = qs("#viewFaces");
        const vReports = qs("#viewReports");
        if (view === "lists") {
          if (vReports) vReports.style.display = "none";
          if (vFaces) vFaces.style.display = "none";
          if (vLists) vLists.style.display = "";
          qs("#listUi").style.display = "";
          qs("#tabs").style.display = "";
          if (!cur || !listNames.includes(cur)) cur = listNames[0] || null;
          renderTabs();
          resetList();
          loadList(true);
        } else if (view === "faces") {
          if (vReports) vReports.style.display = "none";
          if (vLists) vLists.style.display = "none";
          if (vFaces) vFaces.style.display = "";
          if (qs("#listUi")) qs("#listUi").style.display = "none";
          loadFacesByPersons();
        } else {
          if (vReports) vReports.style.display = "";
          if (vLists) vLists.style.display = "none";
          if (vFaces) vFaces.style.display = "none";
          // default report tab
          setReport(report || "duplicates");
        }
      }

      // bind view switches
      qsa("#level1Tabs button.tab[data-view]").forEach(b => {
        b.addEventListener("click", () => setView(b.getAttribute("data-view")));
      });
      qsa("#reportTabs button.tab[data-report]").forEach(b => {
        b.addEventListener("click", () => setReport(b.getAttribute("data-report")));
      });

      // runs metrics reload
      const btnRunsReload = qs("#btnRunsReload");
      if (btnRunsReload) btnRunsReload.addEventListener("click", () => loadRunsMetrics());

      function cardHtml(it) {
        const raw = it?.raw_path || "";
        const path = it?.path || raw;
        const display = it?.path_short || raw;
        const kind = it?.preview_kind || "none";
        const pv = it?.preview_url || "";
        const mt = it?.mime_type ? `${escapeHtml(it.mime_type)}` : "—";
        const rects = Array.isArray(it?.manual_rects) ? it.manual_rects : [];
        const rectPill = ((cur === "faces_gold" || cur === "faces_manual_rects") && rects.length) ? `<span class="pill">rects: ${rects.length}</span>` : ``;
        const dupNames = Array.isArray(it?.dup_names) ? it.dup_names : [];
        const dupPills = (cur === "duplicates" && dupNames.length)
          ? dupNames.map(n => `<span class="pill">${escapeHtml(n)}</span>`).join("")
          : ``;
        const framesBtn = (kind === "video" && pv)
          ? `<button class="vfbtn" data-act="frames" data-path="${escapeHtml(path)}" type="button">Кадры</button>`
          : ``;
        const thumb = (kind === "image" && pv)
          ? `<img loading="lazy" src="${escapeHtml(pv)}" alt="preview" />`
          : (kind === "video" && pv)
            ? `<video controls muted preload="metadata" src="${escapeHtml(pv)}"></video>`
            : `<div class="noimg">—</div>`;
        let actionsHtml = `<button class="btn danger" data-act="del" data-path="${escapeHtml(raw)}" type="button">Удалить</button>`;
        if (cur === "duplicates") {
          // Resolve: keep in exactly one gold list
          const btns = (dupNames || []).map(n => `<button class="btn" data-act="keep" data-keep="${escapeHtml(n)}" type="button">Оставить в ${escapeHtml(n)}</button>`).join("");
          actionsHtml = btns || `<span class="muted small">Нет дублей.</span>`;
        }
        return `
          <div class="card" data-raw="${escapeHtml(raw)}">
            <div class="thumb" data-act="lb">
              ${framesBtn}
              ${thumb}
            </div>
            <div class="card-body">
              <div class="path"><code title="${escapeHtml(raw)}">${escapeHtml(display)}</code></div>
              <div class="kv">
                <span class="pill">${mt}</span>
                ${rectPill}
                ${dupPills}
              </div>
              <div class="actions">
                ${actionsHtml}
              </div>
            </div>
          </div>
        `;
      }

      function resetList() {
        nextCursor = null;
        hasMore = false;
        loading = false;
        cardByRaw.clear();
        qs("#curLoaded").textContent = "0";
        qs("#curTotal").textContent = "—";
        qs("#grid").innerHTML = `<div class="muted">Загрузка…</div>`;
        qs("#btnLoadMore").disabled = true;
      }

      function updateLoadMoreUi() {
        qs("#btnLoadMore").disabled = loading || !hasMore;
      }

      async function loadList(reset=false) {
        if (!cur) return;
        if (loading) return;
        loading = true;
        updateLoadMoreUi();
        if (reset) resetList();
        setToast("");
        qs("#curName").textContent = cur;
        try {
          const q = (qs("#q")?.value || "").trim();
          const rid = getIntVal("#pipelineRunId");
          const lim = getIntVal("#limit") || 120;
          const curParam = nextCursor ? `&cursor=${encodeURIComponent(String(nextCursor))}` : "";
          const url = `/api/gold/list?name=${encodeURIComponent(cur)}&q=${encodeURIComponent(q)}${curParam}&limit=${encodeURIComponent(String(lim))}${rid ? `&pipeline_run_id=${encodeURIComponent(String(rid))}` : ""}`;
          const data = await fetchJson(url);
          const effectiveRid = Number(data?.pipeline_run_id ?? 0) || null;
          const items = Array.isArray(data?.items) ? data.items : [];
          const total = Number(data?.total ?? 0);
          qs("#curTotal").textContent = String(total);
          qs("#curCount").textContent = String(data?.count ?? items.length ?? 0);

          nextCursor = data?.next_cursor || null;
          hasMore = !!data?.has_more;

          const grid = qs("#grid");
          if (cardByRaw.size === 0) grid.innerHTML = "";
          if (!items.length && cardByRaw.size === 0) {
            grid.innerHTML = `<div class="muted">Пусто.</div>`;
          } else {
            const html = [];
            for (const it of items) {
              const raw = it?.raw_path || "";
              if (!raw || cardByRaw.has(raw)) continue;
              html.push(cardHtml(it));
            }
            if (html.length) {
              grid.insertAdjacentHTML("beforeend", html.join(""));
            }
            // bind new cards
            qsa("#grid .card").forEach(card => {
              const raw = card.getAttribute("data-raw") || "";
              if (!raw || cardByRaw.has(raw)) return;
              cardByRaw.set(raw, card);
              // store item meta for lightbox (including manual_rects)
              const it = items.find(x => (x?.raw_path || "") === raw);
              if (it) itemByRaw.set(raw, it);
              const thumb = card.querySelector(".thumb[data-act='lb']");
              if (thumb) {
                // double click like /faces
                thumb.addEventListener("dblclick", () => openLb(itemByRaw.get(raw) || { raw_path: raw }));
              }
              const framesBtn = card.querySelector("button.vfbtn[data-act='frames']");
              if (framesBtn) {
                framesBtn.addEventListener("click", (e) => {
                  try { e.preventDefault(); e.stopPropagation(); } catch (ee) {}
                  if (!effectiveRid) { setToast("Нужен pipeline_run_id (выбери прогон в поле pipeline_run_id).", true); return; }
                  // Открываем /faces и сразу показываем модалку (open_video_path).
                  const p = framesBtn.getAttribute("data-path") || "";
                  if (!p) return;
                  const u = `/faces?pipeline_run_id=${encodeURIComponent(String(effectiveRid))}&open_video_path=${encodeURIComponent(String(p))}`;
                  window.open(u, "_blank", "noopener");
                });
              }
              const btn = card.querySelector("button[data-act='del'][data-path]");
              if (btn && cur !== "duplicates") {
                btn.addEventListener("click", async () => {
                  const p = btn.getAttribute("data-path") || "";
                  if (!p) return;
                  if (!confirm(`Удалить из ${cur}?\n\n${p}`)) return;
                  const el = card;
                  let adjust = 0;
                  if (el) {
                    const r = el.getBoundingClientRect();
                    if (r.bottom < 0) adjust = el.offsetHeight || 0;
                  }
                  try {
                    await postJson("/api/gold/delete", { name: cur, path: p });
                    if (el) el.remove();
                    cardByRaw.delete(p);
                    itemByRaw.delete(p);
                    qs("#curLoaded").textContent = String(cardByRaw.size);
                    const curTot = Number(qs("#curTotal").textContent || "0");
                    if (Number.isFinite(curTot) && curTot > 0) qs("#curTotal").textContent = String(curTot - 1);
                    if (adjust > 0) window.scrollBy(0, adjust);
                    setToast("Удалено.");
                  } catch (e) {
                    setToast(e?.message || String(e), true);
                  }
                });
              }

              // resolve duplicates
              if (cur === "duplicates") {
                card.querySelectorAll("button[data-act='keep'][data-keep]").forEach(b => {
                  b.addEventListener("click", async () => {
                    const keep = b.getAttribute("data-keep") || "";
                    if (!keep) return;
                    const p = (itemByRaw.get(raw)?.path) || raw;
                    const msg = `Оставить путь только в ${keep}?\n\n${p}`;
                    if (!confirm(msg)) return;
                    try {
                      b.disabled = true;
                      await postJson("/api/gold/resolve-duplicate", { path: p, keep_name: keep });
                      // remove from view (no longer a duplicate)
                      card.remove();
                      cardByRaw.delete(raw);
                      itemByRaw.delete(raw);
                      qs("#curLoaded").textContent = String(cardByRaw.size);
                      setToast("Готово: дубль разрешён.");
                      // refresh counts/tabs lazily
                      await loadNames();
                    } catch (e) {
                      setToast(e?.message || String(e), true);
                    } finally {
                      b.disabled = false;
                    }
                  });
                });
              }
            });
          }

          qs("#curLoaded").textContent = String(cardByRaw.size);
        } catch (e) {
          qs("#grid").innerHTML = `<div class="muted"><span class="toast err">Ошибка: ${escapeHtml(e?.message || e)}</span></div>`;
          qs("#curCount").textContent = "—";
          qs("#curTotal").textContent = "—";
          qs("#curLoaded").textContent = "0";
          nextCursor = null;
          hasMore = false;
          cardByRaw.clear();
        } finally {
          loading = false;
          updateLoadMoreUi();
        }
      }

      async function updateFromDb() {
        setToast("");
        try {
          const rid = getIntVal("#pipelineRunId");
          qs("#btnUpdateFromDb").disabled = true;
          const data = await postJson("/api/gold/update-from-db", { pipeline_run_id: rid });
          const notes = [];
          const r = data?.results || {};
          for (const k of Object.keys(r)) {
            const rr = r[k] || {};
            notes.push(`${k}: +${Number(rr.added ?? 0)} (db_total=${Number(rr.db_total ?? 0)})`);
          }
          setToast(`Готово. ${notes.join(" · ")}`);
          await loadNames();
          await loadList(true);
        } catch (e) {
          setToast(e?.message || String(e), true);
        } finally {
          qs("#btnUpdateFromDb").disabled = false;
        }
      }

      async function applyToDb() {
        setToast("");
        try {
          const rid = getIntVal("#pipelineRunId");
          const msg = [
            "Заполнить ручную разметку из gold (append-only)?",
            "",
            "Правило: не перетираем уже размеченные файлы; только дополняем пустые поля.",
            rid ? `Ограничение: только root прогона pipeline_run_id=${rid}` : "Ограничение: нет (вся БД).",
          ].join("\n");
          if (!confirm(msg)) return;
          qs("#btnApplyToDb").disabled = true;
          const data = await postJson("/api/gold/apply-to-db", { pipeline_run_id: rid });
          const notes = [];
          const r = data?.results || {};
          for (const k of Object.keys(r)) {
            const rr = r[k] || {};
            notes.push(`${k}: applied=${Number(rr.applied ?? 0)} skipped=${Number(rr.skipped ?? 0)} missing=${Number(rr.missing ?? 0)}`);
          }
          setToast(`Готово. total_applied=${Number(data?.total_applied ?? 0)} · ${notes.join(" · ")}`);
        } catch (e) {
          setToast(e?.message || String(e), true);
        } finally {
          qs("#btnApplyToDb").disabled = false;
        }
      }

      qs("#btnReload").onclick = () => loadList(true);
      qs("#btnUpdateFromDb").onclick = () => updateFromDb();
      qs("#btnApplyToDb").onclick = () => applyToDb();
      qs("#q").addEventListener("input", () => { loadList(true); });
      qs("#limit").addEventListener("change", () => { loadList(true); });
      qs("#btnLoadMore").onclick = () => loadList(false);

      // infinite scroll: auto-load when sentinel becomes visible
      const io = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (e.isIntersecting && hasMore && !loading) loadList(false);
        }
      }, { root: null, rootMargin: "1200px 0px", threshold: 0.01 });
      io.observe(qs("#sentinel"));

      // init
      loadNames().then(() => { renderLevel1Tabs(); renderReportTabs(); setView("lists"); }).catch(e => setToast(e?.message || String(e), true));
    </script>
  </body>
</html>



