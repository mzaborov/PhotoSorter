<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PhotoSorter — Фотоархив</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      .header { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; max-width: 1200px; }
      .muted { color: #6b7280; }
      table { border-collapse: collapse; width: 100%; max-width: 1200px; margin-top: 14px; }
      th, td { border-bottom: 1px solid #e5e7eb; padding: 10px 8px; vertical-align: top; text-align: left; }
      th { font-weight: 600; color: #111827; background: #fafafa; position: sticky; top: 0; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #f3f4f6; color: #374151; font-size: 12px; }
      .num { width: 64px; }
      .nowrap { white-space: nowrap; }
      .right { text-align: right; }
      .count-cell { font-variant-numeric: tabular-nums; }
      .err { color: #b91c1c; }
      .topline { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; max-width: 1200px; }
      .btn { display: inline-flex; align-items: center; gap: 8px; border: 1px solid #e5e7eb; background: #fff; padding: 6px 10px; border-radius: 10px; cursor: pointer; }
      .btn:hover { background: #fafafa; }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .status { font-variant-numeric: tabular-nums; }
      .section { max-width: 1200px; margin-top: 18px; border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px 14px; background: #fff; }
      .section-title { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; }
      .bar { height: 10px; background: #f3f4f6; border-radius: 999px; overflow: hidden; border: 1px solid #e5e7eb; }
      .bar > div { height: 100%; width: 0%; background: #0b57d0; transition: width 200ms linear; }
      .form-row { display: flex; flex-wrap: wrap; gap: 10px 12px; align-items: center; margin-top: 10px; }
      .field { display: flex; align-items: center; gap: 8px; }
      .field input { width: 96px; padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 10px; }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <h2 style="margin: 0;">Фотоархив</h2>
      </div>
      <div class="muted">
        <a href="/">Главная</a>
        &nbsp;·&nbsp;
        <a href="#" id="recount">Пересчитать</a>
      </div>
    </div>
    <div class="topline" style="margin-top: 10px;">
      <div class="muted" id="progress">Готово: 0 / 0</div>
      <div class="muted status" id="hint"></div>
    </div>

    <table>
      <thead>
        <tr>
          <th class="num">Порядок</th>
          <th>Имя</th>
          <th class="right">Файлов</th>
          <th>Путь</th>
          <th class="nowrap">Код</th>
          <th class="nowrap">Роль</th>
        </tr>
      </thead>
      <tbody>
        {% for f in folders %}
        <tr>
          <td class="num">
            {% if f.sort_order is not none %}
              <span class="pill">{{ f.sort_order }}</span>
            {% endif %}
          </td>
          <td>{{ f.name or "" }}</td>
          <td class="right count-cell" data-code="{{ f.code }}">…</td>
          <td>
            <code>{{ f.path }}</code>
            &nbsp;
            <a href="/browse?path={{ f.path | urlencode }}" title="Открыть вложенные папки">↗</a>
          </td>
          <td class="nowrap"><code>{{ f.code }}</code></td>
          <td class="nowrap"><span class="pill">{{ f.role }}</span></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>

    <div class="section" id="dedupArchiveSection">
      <div class="section-title">
        <div>
          <div style="font-weight: 600;">Дедупликация архива</div>
          <div class="muted">Архив: <code>disk:/Фото</code>. Запуск доступен после завершения подсчёта “Файлов” по папкам выше.</div>
        </div>
        <div>
          <div class="field">
            <span class="muted">max GB:</span>
            <input id="dedupMaxGb" type="number" min="0" step="1" value="5" />
          </div>
          <button class="btn" id="dedupArchiveStart" type="button" disabled
            title="Запустить/продолжить дедупликацию архива (resume по данным)">
            Запустить / Продолжить
          </button>
          <button class="btn" id="reconcileArchiveStart" type="button"
            title="Синхронизировать БД с Я.Диском и досчитать лица (актуализация списка файлов + append недостающих лиц без дублирования)">
            Синхронизировать и досчитать лица
          </button>
        </div>
      </div>

      <div style="margin-top: 10px;">
        <div class="bar" aria-label="Dedup progress"><div id="dedupBarFill"></div></div>
        <div class="muted status" id="dedupText" style="margin-top: 8px;">Дедупликация: статус загружается…</div>
        <div class="bar" aria-label="Reconcile progress" style="margin-top: 10px;"><div id="reconcileBarFill"></div></div>
        <div class="muted status" id="reconcileText" style="margin-top: 8px;">Синхронизация: статус загружается…</div>
        <div class="muted" style="margin-top: 8px;">
          <a href="/duplicates">Посмотреть дубли</a>
        </div>
      </div>
    </div>

    <script>
      const CONCURRENCY = 10;
      const DEDUP_POLL_MS = 2000;
      let folderCountsDone = false;
      let dedupArchiveRunning = false;
      let reconcileArchiveRunning = false;

      function setProgress(done, total) {
        const el = document.getElementById("progress");
        if (el) el.textContent = `Готово: ${done} / ${total}`;
      }

      function setHint(text) {
        const el = document.getElementById("hint");
        if (el) el.textContent = text ?? "";
      }

      function setDedupText(text) {
        const el = document.getElementById("dedupText");
        if (el) el.textContent = text ?? "";
      }

      function setDedupBar(percent) {
        const el = document.getElementById("dedupBarFill");
        if (!el) return;
        const p = Math.max(0, Math.min(100, Number(percent) || 0));
        el.style.width = `${p}%`;
      }

      function setReconcileText(text) {
        const el = document.getElementById("reconcileText");
        if (el) el.textContent = text ?? "";
      }

      function setReconcileBar(percent) {
        const el = document.getElementById("reconcileBarFill");
        if (!el) return;
        const p = Math.max(0, Math.min(100, Number(percent) || 0));
        el.style.width = `${p}%`;
      }

      function fmtBytes(n) {
        const v = Number(n);
        if (!Number.isFinite(v)) return "";
        const units = ["B","KB","MB","GB","TB"];
        let i = 0;
        let x = v;
        while (x >= 1024 && i < units.length - 1) { x /= 1024; i += 1; }
        return `${x.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
      }

      function updateArchiveButtonsDisabled() {
        const btn = document.getElementById("dedupArchiveStart");
        const disabled = Boolean(dedupArchiveRunning) || Boolean(reconcileArchiveRunning) || !folderCountsDone;
        const title = !folderCountsDone
          ? "Дождитесь окончания подсчёта файлов по папкам (верхняя таблица)."
          : ((dedupArchiveRunning || reconcileArchiveRunning) ? "Операция по архиву уже запущена." : "");
        if (btn) {
          btn.disabled = disabled;
          if (title) btn.title = title;
        }

        const btnR = document.getElementById("reconcileArchiveStart");
        if (btnR) {
          btnR.disabled = Boolean(dedupArchiveRunning) || Boolean(reconcileArchiveRunning);
          if (dedupArchiveRunning || reconcileArchiveRunning) btnR.title = "Операция по архиву уже запущена.";
        }
      }

      async function pollDedupArchiveStatusOnce() {
        try {
          const resp = await fetch(`/api/dedup/archive/status`, { cache: "no-store" });
          if (!resp.ok) throw new Error("HTTP " + resp.status);
          const data = await resp.json();

          const latest = data.latest || null;
          dedupArchiveRunning = Boolean(data.running);
          updateArchiveButtonsDisabled();

          if (!latest) {
            setDedupBar(0);
            setDedupText("Дедупликация: ещё не запускалась.");
            const btn0 = document.getElementById("dedupArchiveStart");
            if (btn0) btn0.textContent = "Запуск";
            return;
          }

          const p = latest.processed_files ?? 0;
          const h = latest.hashed_files ?? 0;
          const mh = latest.meta_hashed_files ?? 0;
          const dh = latest.downloaded_hashed_files ?? 0;
          const sk = latest.skipped_large_files ?? 0;
          const er = latest.errors_count ?? 0;
          const total = latest.total_files ?? null;
          const maxB = latest.max_download_bytes ?? null;
          const st = latest.status ?? "";

          const totalText = total ? `всего=${total}` : "всего=…";
          const maxText = maxB ? `max=${fmtBytes(maxB)}` : "max=нет";

          const denom = total ?? 0;
          const pct = denom > 0 ? Math.round((p / denom) * 100) : 0;
          setDedupBar(pct);
          setDedupText(
            `Дедупликация: ${dedupArchiveRunning ? "идёт" : st} · прогресс=${pct}% (${p}/${denom || "…"}) · с хэшем=${h} (meta=${mh}, download=${dh}) · пропущено(>max)=${sk} · ошибок=${er} · ${totalText} · ${maxText}`
          );

          const btn = document.getElementById("dedupArchiveStart");
          if (btn) {
            if (dedupArchiveRunning) {
              btn.textContent = "Идёт…";
            } else if (st === "completed") {
              btn.textContent = "Запустить заново";
            } else if (st === "failed" || st === "running") {
              btn.textContent = "Продолжить / запустить заново";
            } else {
              btn.textContent = "Запуск";
            }
          }
        } catch (e) {
          setDedupText("Дедупликация: ошибка статуса: " + String(e));
        }
      }

      async function pollArchiveReconcileStatusOnce() {
        try {
          const resp = await fetch(`/api/archive/reconcile/status`, { cache: "no-store" });
          if (!resp.ok) throw new Error("HTTP " + resp.status);
          const data = await resp.json();
          const latest = data.latest || null;
          reconcileArchiveRunning = Boolean(data.running);
          updateArchiveButtonsDisabled();

          if (!latest) {
            setReconcileBar(0);
            setReconcileText("Сверка архива: ещё не запускалась.");
            return;
          }

          const p = latest.processed_files ?? 0;
          const total = latest.total_files ?? null;
          const er = latest.errors_count ?? 0;
          const st = latest.status ?? "";
          const denom = total ?? 0;
          const pct = denom > 0 ? Math.round((p / denom) * 100) : 0;

          setReconcileBar(pct);
          const statusText = reconcileArchiveRunning 
            ? "идёт (после завершения автоматически запустится досчёт лиц)"
            : st;
          setReconcileText(
            `Синхронизация и досчёт лиц: ${statusText} · прогресс=${pct}% (${p}/${denom || "…"}) · ошибок=${er}`
          );
        } catch (e) {
          setReconcileText("Сверка архива: ошибка статуса: " + String(e));
        }
      }

      function getMaxGb() {
        const v = Number(document.getElementById("dedupMaxGb")?.value ?? 5);
        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : 5;
      }

      async function startDedupArchive() {
        dedupArchiveRunning = true;
        updateArchiveButtonsDisabled();
        setDedupText("Дедупликация: запуск…");
        try {
          const maxGb = getMaxGb();
          const url = `/api/dedup/archive/start?max_download_gb=${encodeURIComponent(String(maxGb))}`;
          const resp = await fetch(url, { method: "POST" });
          const data = await resp.json().catch(() => ({}));
          if (!resp.ok || !data.ok) throw new Error(data.message || ("HTTP " + resp.status));
          setDedupText(`Дедупликация: запущено (run_id=${data.run_id}).`);
        } catch (e) {
          setDedupText("Дедупликация: не удалось запустить: " + String(e));
        } finally {
          // сразу обновим статус
          await pollDedupArchiveStatusOnce();
        }
      }

      async function startReconcileArchive() {
        reconcileArchiveRunning = true;
        updateArchiveButtonsDisabled();
        setReconcileText("Сверка архива: запуск…");
        try {
          const resp = await fetch(`/api/archive/reconcile/start`, { method: "POST" });
          const data = await resp.json().catch(() => ({}));
          if (!resp.ok || !data.ok) throw new Error(data.message || ("HTTP " + resp.status));
          setReconcileText(`Сверка архива: запущено (run_id=${data.run_id}).`);
        } catch (e) {
          setReconcileText("Сверка архива: не удалось запустить: " + String(e));
        } finally {
          await pollArchiveReconcileStatusOnce();
        }
      }

      async function loadCountsRowByRow() {
        const cells = Array.from(document.querySelectorAll("td.count-cell[data-code]"));
        const total = cells.length;
        let done = 0;
        setProgress(done, total);

        folderCountsDone = false;
        updateArchiveButtonsDisabled();
        setHint("Подсчитываем файлы по папкам…");

        for (const c of cells) {
          c.textContent = "…";
          c.classList.remove("err");
          c.title = "";
        }

        const queue = cells.slice();

        async function worker() {
          while (queue.length) {
            const cell = queue.shift();
            const code = cell?.getAttribute("data-code");
            if (!cell || !code) continue;

            try {
              const resp = await fetch(`/api/folder-count/${encodeURIComponent(code)}`, { cache: "no-store" });
              if (!resp.ok) throw new Error("HTTP " + resp.status);
              const data = await resp.json();

              if (data.error) {
                cell.textContent = "ошибка";
                cell.classList.add("err");
                cell.title = data.error;
              } else {
                cell.textContent = (data.count ?? "").toString();
                cell.title = data.seconds ? `Время: ${data.seconds}с` : "";
              }
            } catch (e) {
              cell.textContent = "ошибка";
              cell.classList.add("err");
              cell.title = String(e);
            } finally {
              done += 1;
              setProgress(done, total);
            }
          }
        }

        const workers = Array.from({ length: Math.min(CONCURRENCY, total) }, () => worker());
        await Promise.all(workers);

        folderCountsDone = true;
        updateArchiveButtonsDisabled();
        setHint("");
      }

      document.getElementById("recount")?.addEventListener("click", (e) => {
        e.preventDefault();
        loadCountsRowByRow();
      });

      document.getElementById("dedupArchiveStart")?.addEventListener("click", (e) => {
        e.preventDefault();
        startDedupArchive();
      });

      document.getElementById("reconcileArchiveStart")?.addEventListener("click", (e) => {
        e.preventDefault();
        startReconcileArchive();
      });

      loadCountsRowByRow();
      pollDedupArchiveStatusOnce();
      pollArchiveReconcileStatusOnce();
      setInterval(() => {
        pollDedupArchiveStatusOnce();
        pollArchiveReconcileStatusOnce();
      }, DEDUP_POLL_MS);
    </script>
  </body>
</html>


