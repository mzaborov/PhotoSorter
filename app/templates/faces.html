<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- YaDisk preview hotlink защита: просим браузер не слать Referer при загрузке картинок -->
    <meta name="referrer" content="no-referrer" />
    <title>PhotoSorter — Результаты лиц</title>
    <style>
      :root { color-scheme: light; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
      a { color: #0b57d0; text-decoration: none; }
      a:hover { text-decoration: underline; }
      code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { color: #6b7280; }
      .wrap { max-width: 1400px; }
      .header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; color:#374151; font-size:12px; }
      .inp { border:1px solid #d1d5db; border-radius:10px; padding:8px 10px; font-weight:700; width: 110px; }
      .inp:focus { outline: 2px solid rgba(59,130,246,0.35); outline-offset: 1px; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700; }
      .btn:hover { background:#f9fafb; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .btn.danger { border-color:#fecaca; background:#fff5f5; color:#991b1b; }
      .btn.danger:hover { background:#ffecec; }
      .tabs { display:flex; gap:8px; margin-top: 14px; }
      .tab { appearance:none; border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:999px; cursor:pointer; font-weight:700; }
      .tab.active { background:#111827; color:#fff; border-color:#111827; }
      .subtabs { display:flex; gap:8px; margin-top: 10px; }
      .subtab { appearance:none; border:1px solid #e5e7eb; background:#fff; padding:6px 10px; border-radius:999px; cursor:pointer; font-weight:700; font-size: 12px; color:#111827; }
      .subtab.active { background:#eef2ff; border-color:#c7d2fe; }
      .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 12px; }
      .grid { display:flex; gap:10px; flex-wrap:wrap; margin-top: 14px; }
      .card { width: 240px; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; background:#fff; }
      .thumb { height: 140px; background:#fff; display:flex; align-items:center; justify-content:center; position:relative; cursor: zoom-in; }
      .thumb img { width: 100%; height: 100%; object-fit: contain; display:block; background:#fff; }
      .thumb video { width: 100%; height: 100%; object-fit: contain; display:block; background:#111827; }
      .thumb .noimg { color:#6b7280; font-size:12px; padding:10px; text-align:center; }
      .card-body { padding: 10px 10px 12px 10px; }
      .kv { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; font-size:12px; color:#374151; }
      .path { font-size: 12px; word-break: break-all; }
      .actions { display:flex; gap:8px; align-items:center; margin-top: 10px; }
      /* Вариант A: "мимо gold" — делаем заметно */
      .card.past-gold {
        background: #ffe4e6;         /* rose-200 */
        border-color: #fb7185;       /* rose-400 */
        box-shadow: 0 0 0 2px rgba(244, 63, 94, 0.35); /* rose-500 ring */
      }

      /* Modal viewer + drawing */
      .lb { position: fixed; inset: 0; background: rgba(17,24,39,0.82); display: none; align-items: center; justify-content: center; padding: 18px; z-index: 9999; }
      .lb.open { display: flex; }
      .lb-panel { background: #fff; border-radius: 14px; max-width: 94vw; max-height: 94vh; width: min(1200px, 94vw); overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
      .lb-top { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .lb-top code { font-size: 11px; }
      .lb-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .lb-body { background: #111827; display: flex; align-items: center; justify-content: center; padding: 10px; }
      .imgwrap { position: relative; display: inline-block; }
      .imgwrap img { max-width: 92vw; max-height: calc(92vh - 130px); width: auto; height: auto; display: block; background: #111827; }
      .imgwrap canvas { position: absolute; left: 0; top: 0; pointer-events: auto; }
      .lb-bottom { padding: 10px 12px; border-top: 1px solid #e5e7eb; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
      .rectlist { display:flex; gap:8px; flex-wrap:wrap; }
      .rectpill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#1f2937; font-size:12px; }
      .draw-on { cursor: crosshair; }

      /* Sticky header (всё, что на верхнем блоке со вкладками/кнопками) */
      .sticky-top {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(255,255,255,0.98);
        backdrop-filter: blur(6px);
        border-bottom: 1px solid #e5e7eb;
        padding-bottom: 12px;
        margin-bottom: 14px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="sticky-top" id="stickyTop">
        <div class="header">
          <div>
            <h2 style="margin:0;">Результаты “лица / нет лиц” (шаг 2)</h2>
            <div class="muted" style="margin-top:6px;">Двойной клик по превью — показать прямоугольники лиц. В “Нет лиц” можно разметить лица вручную.</div>
          </div>
          <div class="muted"><a href="/">← на главную</a></div>
        </div>

        <div class="toolbar">
          <span class="pill">pipeline_run_id: <b id="prId">—</b></span>
          <span class="pill">face_run_id: <b id="frId">—</b></span>
          <span class="pill">root: <code id="rootPath">—</code></span>
          <span class="muted" id="toast"></span>
        </div>

        <div class="tabs">
          <button class="tab active" id="tabFaces" type="button">Есть лица</button>
          <button class="tab" id="tabQuarantine" type="button">Карантин</button>
          <button class="tab" id="tabAnimals" type="button">Животные</button>
          <button class="tab" id="tabPeopleNoFace" type="button">Есть люди (без лиц)</button>
          <button class="tab" id="tabNoFaces" type="button">Нет лиц</button>
        </div>

        <!-- 2-й уровень (постепенно): пока только для "Есть лица" -->
        <div class="subtabs" id="subtabsFaces" style="display:none;">
          <button class="subtab active" id="subFacesAll" type="button">Неотсортировано</button>
          <button class="subtab" id="subFacesMany" type="button">Много лиц</button>
        </div>

        <div class="toolbar">
          <button class="btn" id="btnPrev" type="button">←</button>
          <span class="pill">страница: <b id="page">1</b></span>
          <button class="btn" id="btnNext" type="button">→</button>
          <span class="pill">всего: <b id="total">—</b></span>
          <button class="btn" id="btnReload" type="button">Обновить</button>
        </div>

        <div class="toolbar">
          <span class="pill" id="posPill">позиция: —</span>
          <span class="muted">строка:</span>
          <input class="inp" id="jumpRow" type="number" inputmode="numeric" min="1" step="1" placeholder="№" />
          <button class="btn" id="btnJump" type="button">Перейти</button>
          <span class="muted" id="jumpHint"></span>
        </div>
      </div>

      <div class="grid" id="grid"></div>
    </div>

    <div class="lb" id="lightbox" aria-hidden="true">
      <div class="lb-panel" role="dialog" aria-modal="true">
        <div class="lb-top">
          <code id="lbPath">—</code>
          <div class="lb-actions">
            <span class="pill" id="lbMode">просмотр</span>
            <button class="btn" id="lbAnnotate" type="button" style="display:none;">Разметить</button>
            <button class="btn" id="lbClear" type="button" style="display:none;">Очистить</button>
            <button class="btn" id="lbSave" type="button" style="display:none;">Сохранить</button>
            <button class="btn" id="lbClose" type="button">Закрыть</button>
          </div>
        </div>
        <div class="lb-body">
          <div class="imgwrap" id="imgWrap">
            <img id="lbImg" alt="preview" />
            <canvas id="lbCanvas"></canvas>
          </div>
        </div>
        <div class="lb-bottom">
          <div class="muted">Прямоугольники:</div>
          <div class="rectlist" id="rectList"></div>
        </div>
      </div>
    </div>

    <script>
      function qs(sel, el=document) { return el.querySelector(sel); }
      function qsa(sel, el=document) { return Array.from(el.querySelectorAll(sel)); }
      function escapeHtml(s) {
        return (s ?? "").toString()
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#039;");
      }
      async function fetchJson(url, opts={}) {
        const r = await fetch(url, { cache:"no-store", ...opts });
        const t = await r.text();
        let j = null;
        try { j = t ? JSON.parse(t) : null; } catch (e) { j = null; }
        if (!r.ok) throw new Error((j && (j.detail || j.error)) ? (j.detail || j.error) : (t || `HTTP ${r.status}`));
        return j;
      }
      async function postJson(url, payload) {
        return await fetchJson(url, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload ?? {}) });
      }
      function setToast(msg, isErr=false) {
        const el = qs("#toast");
        el.textContent = msg || "";
        el.style.color = isErr ? "#991b1b" : "#6b7280";
      }
      function getParam(name) {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      }

      let pipelineRunId = null;
      let tab = "faces";
      let subtab = "all"; // 2-й уровень (используем пока только для tab=faces)
      let page = 1;
      const pageSize = 60;
      let loading = false;
      let hasMore = true;
      let totalCount = null;
      let loadedCount = 0;
      let jumpTargetRow = null; // 1-based

      // visible-range tracking (for "где я?")
      const visibleRows = new Set();
      let _posRaf = 0;
      function _posScheduleUpdate() {
        if (_posRaf) return;
        _posRaf = requestAnimationFrame(() => {
          _posRaf = 0;
          updatePositionPill();
        });
      }
      function _asInt(v) {
        const n = Number(v);
        return Number.isFinite(n) ? Math.trunc(n) : null;
      }
      function _cards() { return qsa("#grid .card[data-row]"); }
      function updatePositionPill() {
        const el = qs("#posPill");
        if (!el) return;
        const tot = (typeof totalCount === "number") ? totalCount : null;
        if (!visibleRows.size) {
          el.textContent = "позиция: —";
          return;
        }
        const sorted = Array.from(visibleRows).sort((a,b) => a-b);
        const first = sorted[0];
        const last = sorted[sorted.length - 1];
        const top = Math.max(0, first - 1);
        const bottom = (tot != null) ? Math.max(0, tot - last) : null;
        el.textContent = `позиция: ${first}–${last}` + (tot != null ? ` из ${tot}; сверху ${top}; снизу ${bottom}` : `; сверху ${top}`);
      }
      const cardIo = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          const el = e.target;
          const row = _asInt(el?.getAttribute?.("data-row"));
          if (!row) return;
          if (e.isIntersecting) visibleRows.add(row);
          else visibleRows.delete(row);
        });
        _posScheduleUpdate();
      }, { root: null, threshold: 0.1 });

      function observeNewCards() {
        _cards().forEach(el => {
          if (el.getAttribute("data-observed") === "1") return;
          el.setAttribute("data-observed", "1");
          try { cardIo.observe(el); } catch (e) {}
        });
      }

      function removeCardByPath(path) {
        const p = (path || "").toString();
        if (!p) return false;
        const cards = qsa("#grid .card");
        const card = cards.find(c => (c.getAttribute("data-path") || "") === p);
        if (!card) return false;
        const row = _asInt(card.getAttribute("data-row"));
        try { cardIo.unobserve(card); } catch (e) {}
        if (row) visibleRows.delete(row);
        card.remove();
        _posScheduleUpdate();
        return true;
      }

      // init tab/subtab from query (до первого load)
      tab = (getParam("tab") || tab || "faces").toString().trim().toLowerCase() || "faces";
      if (!["faces","quarantine","animals","people_no_face","no_faces"].includes(tab)) tab = "faces";
      subtab = (getParam("subtab") || subtab || "all").toString().trim().toLowerCase() || "all";
      if (!["all","many_faces"].includes(subtab)) subtab = "all";
      if (tab !== "faces") subtab = "all";

      function updateUrlParams() {
        const u = new URL(window.location.href);
        u.searchParams.set("tab", tab);
        if (tab === "faces" && subtab && subtab !== "all") {
          u.searchParams.set("subtab", subtab);
        } else {
          u.searchParams.delete("subtab");
        }
        window.history.replaceState({}, "", u.toString());
      }

      function updateSubtabsVisibility() {
        const row = qs("#subtabsFaces");
        if (!row) return;
        row.style.display = (tab === "faces") ? "flex" : "none";
        const bAll = qs("#subFacesAll");
        const bMany = qs("#subFacesMany");
        if (bAll) bAll.classList.toggle("active", tab === "faces" && subtab === "all");
        if (bMany) bMany.classList.toggle("active", tab === "faces" && subtab === "many_faces");
      }

      function applyTabUI() {
        qs("#tabFaces").classList.toggle("active", tab === "faces");
        qs("#tabQuarantine").classList.toggle("active", tab === "quarantine");
        qs("#tabAnimals").classList.toggle("active", tab === "animals");
        qs("#tabPeopleNoFace").classList.toggle("active", tab === "people_no_face");
        qs("#tabNoFaces").classList.toggle("active", tab === "no_faces");
        updateSubtabsVisibility();
      }

      function setSubtab(st) {
        if (tab !== "faces") return;
        subtab = st;
        if (!["all","many_faces"].includes(subtab)) subtab = "all";
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/6ba4f132-2ab7-473c-8c73-3e4f328ef941',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app/templates/faces.html:setSubtab',message:'ui_set_subtab',data:{tab:tab,subtab:subtab},timestamp:Date.now(),sessionId:'debug-session',runId:'pre-fix',hypothesisId:'HUI_SUBTAB'})}).catch(()=>{});
        // #endregion agent log
        updateSubtabsVisibility();
        updateUrlParams();
        page = 1;
        load(true);
      }

      function setTab(t) {
        tab = t;
        if (!["faces","quarantine","animals","people_no_face","no_faces"].includes(tab)) tab = "faces";
        if (tab !== "faces") subtab = "all";
        applyTabUI();
        updateUrlParams();
        page = 1;
        load(true);
      }
      qs("#tabFaces").onclick = () => setTab("faces");
      qs("#tabQuarantine").onclick = () => setTab("quarantine");
      qs("#tabAnimals").onclick = () => setTab("animals");
      qs("#tabPeopleNoFace").onclick = () => setTab("people_no_face");
      qs("#tabNoFaces").onclick = () => setTab("no_faces");
      qs("#subFacesAll").onclick = () => setSubtab("all");
      qs("#subFacesMany").onclick = () => setSubtab("many_faces");
      // Пагинацию заменяем на бесконечную подгрузку при скролле.
      qs("#btnPrev").style.display = "none";
      qs("#btnNext").style.display = "none";
      qs("#page").textContent = "—";
      qs("#btnReload").onclick = () => load(true);

      function jumpToRow(n) {
        const nn = _asInt(n);
        const hint = qs("#jumpHint");
        if (!nn || nn < 1) {
          if (hint) hint.textContent = "Введите номер строки ≥ 1";
          return;
        }
        if (hint) hint.textContent = "";
        const targetPage = Math.floor((nn - 1) / pageSize) + 1;
        jumpTargetRow = nn;
        page = targetPage;
        load(true, { forcePage: targetPage });
      }
      qs("#btnJump").onclick = () => jumpToRow(qs("#jumpRow")?.value);
      qs("#jumpRow").addEventListener("keydown", (e) => {
        if (e.key === "Enter") jumpToRow(qs("#jumpRow")?.value);
      });

      async function refreshTabCounts() {
        if (!pipelineRunId) return;
        try {
          const data = await fetchJson(`/api/faces/tab-counts?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}`);
          const c = data?.counts || {};
          const scFaces = data?.subcounts?.faces || {};
          const manyCnt = Number(scFaces.many_faces ?? 0);
          const unsortedCnt = Number(scFaces.unsorted ?? 0);
          qs("#tabFaces").textContent = `Есть лица (${Number(c.faces ?? 0)})`;
          qs("#tabQuarantine").textContent = `Карантин (${Number(c.quarantine ?? 0)})`;
          qs("#tabAnimals").textContent = `Животные (${Number(c.animals ?? 0)})`;
          qs("#tabPeopleNoFace").textContent = `Есть люди (без лиц) (${Number(c.people_no_face ?? 0)})`;
          qs("#tabNoFaces").textContent = `Нет лиц (${Number(c.no_faces ?? 0)})`;
          const bMany = qs("#subFacesMany");
          if (bMany) bMany.textContent = `Много лиц (${manyCnt})`;
          const bAll = qs("#subFacesAll");
          if (bAll) bAll.textContent = `Неотсортировано (${unsortedCnt})`;
        } catch (e) {
          // best-effort
        }
      }

      function cardHtml(it, rowNum) {
        const path = it.path || "";
        const kind = it.preview_kind || "none";
        const pv = it.preview_url || "";
        const manual = (it.faces_manual_label || "").toLowerCase();
        const manualPill = manual ? `<span class="pill">manual: ${escapeHtml(manual)}</span>` : ``;
        const facesCnt = Number(it.faces_count || 0);
        const qReason = it.faces_quarantine_reason || "";
        const qPill = qReason ? `<span class="pill">q: ${escapeHtml(qReason)}</span>` : ``;
        const aKind = it.animals_kind || "";
        const aPill = aKind ? `<span class="pill">animal: ${escapeHtml(aKind)}</span>` : ``;
        const pnfPerson = it.people_no_face_person || "";
        const pnfPill = (tab === "people_no_face" && pnfPerson) ? `<span class="pill">person: ${escapeHtml(pnfPerson)}</span>` : ``;
        const thumb = (kind === "image" && pv)
          ? `<img loading="lazy" alt="preview" referrerpolicy="no-referrer" src="${escapeHtml(pv)}" />`
          : (kind === "video" && pv)
            ? `<video controls muted preload="metadata" src="${escapeHtml(pv)}"></video>`
            : `<div class="noimg">нет превью</div>`;
        let btn = "";
        if (tab === "faces") {
          btn = `
            <button class="btn" data-action="mark_cat">Кот</button>
            <button class="btn" data-action="mark_quarantine">Карантин</button>
            <button class="btn danger" data-action="no_faces">Лиц нет</button>
          `;
        } else if (tab === "no_faces") {
          btn = `
            <button class="btn" data-action="annotate_faces">Лица есть (разметить)</button>
            <button class="btn" data-action="mark_cat">Кот</button>
            <button class="btn" data-action="people_no_face">Есть люди (без лиц)</button>
          `;
        } else if (tab === "quarantine") {
          btn = `
            <button class="btn" data-action="mark_faces">Нормальные лица</button>
            <button class="btn" data-action="mark_cat">Кот</button>
            <button class="btn danger" data-action="no_faces">Лиц нет</button>
          `;
        } else if (tab === "animals") {
          btn = `<button class="btn" data-action="mark_faces">Это не животное (лица)</button>`;
        } else if (tab === "people_no_face") {
          btn = `<button class="btn" data-action="reset">Сброс</button>`;
        }
        const pastGold = !!it.sorted_past_gold;
        const cls = pastGold ? "card past-gold" : "card";
        return `
          <div class="${cls}" data-path="${escapeHtml(path)}" data-row="${Number(rowNum || 0) || ""}">
            <div class="thumb" data-path="${escapeHtml(path)}" data-kind="${escapeHtml(kind)}" data-src="${escapeHtml(pv)}">
              ${thumb}
            </div>
            <div class="card-body">
              <div class="path"><code>${escapeHtml(it.path_short || path)}</code></div>
              <div class="kv">
                ${rowNum ? `<span class="pill">#${Number(rowNum)}</span>` : ``}
                <span class="pill">лиц: ${facesCnt}</span>
                ${manualPill}
                ${qPill}
                ${aPill}
                ${pnfPill}
                ${it.size_human ? `<span class="pill">${escapeHtml(it.size_human)}</span>` : ``}
              </div>
              <div class="actions">
                ${btn}
              </div>
            </div>
          </div>
        `;
      }

      async function load(reset=false, opts={}) {
        if (!pipelineRunId) return;
        if (loading) return;
        if (!reset && !hasMore) return;
        loading = true;
        setToast("");
        try {
          if (reset && opts && typeof opts.forcePage === "number" && opts.forcePage >= 1) {
            page = Math.trunc(opts.forcePage);
          }
          if (reset) {
            hasMore = true;
            totalCount = null;
            loadedCount = 0;
            visibleRows.clear();
            try { cardIo.disconnect(); } catch (e) {}
            qs("#grid").innerHTML = `<div class="muted">Загрузка…</div>`;
          } else if (page === 1 && loadedCount === 0) {
            qs("#grid").innerHTML = `<div class="muted">Загрузка…</div>`;
          }
          const data = await fetchJson(`/api/faces/results?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&tab=${encodeURIComponent(tab)}&subtab=${encodeURIComponent(subtab)}&page=${encodeURIComponent(String(page))}&page_size=${encodeURIComponent(String(pageSize))}`);
          // #region agent log
          fetch('http://127.0.0.1:7242/ingest/6ba4f132-2ab7-473c-8c73-3e4f328ef941',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app/templates/faces.html:load',message:'ui_load_result',data:{tab:tab,subtab:subtab,total:Number(data?.total??-1),items_len:Array.isArray(data?.items)?data.items.length:-1},timestamp:Date.now(),sessionId:'debug-session',runId:'pre-fix',hypothesisId:'HAPI_FILTER'})}).catch(()=>{});
          // #endregion agent log
          qs("#prId").textContent = String(data.pipeline_run_id);
          qs("#frId").textContent = String(data.face_run_id);
          qs("#rootPath").textContent = data.root_path || "—";
          totalCount = (data.total != null) ? Number(data.total) : totalCount;
          qs("#total").textContent = String(totalCount ?? "—");
          const items = Array.isArray(data.items) ? data.items : [];
          const startRow = ((Number(page) - 1) * pageSize) + 1;
          if (reset) qs("#grid").innerHTML = "";
          if (!items.length && loadedCount === 0) {
            qs("#grid").innerHTML = `<div class="muted">Пусто.</div>`;
          } else if (items.length) {
            qs("#grid").insertAdjacentHTML("beforeend", items.map((it, i) => cardHtml(it, startRow + i)).join(""));
          }
          loadedCount += items.length;
          hasMore = items.length === pageSize && (totalCount == null || loadedCount < totalCount);
          await refreshTabCounts();
          observeNewCards();
          _posScheduleUpdate();

          // if jump requested: scroll to the exact row within this page
          if (reset && jumpTargetRow != null) {
            const target = jumpTargetRow;
            jumpTargetRow = null;
            const el = _cards().find(c => _asInt(c.getAttribute("data-row")) === target);
            if (el) {
              el.scrollIntoView({ block: "start", behavior: "auto" });
              el.style.boxShadow = "0 0 0 2px rgba(59,130,246,0.45)";
              setTimeout(() => { try { el.style.boxShadow = ""; } catch (e) {} }, 1200);
            } else {
              window.scrollTo({ top: 0, behavior: "auto" });
            }
          }

          // actions
          qsa(".card button[data-action]").slice(-items.length * 1 - 2000).forEach(btn => {
            btn.addEventListener("click", async () => {
              const card = btn.closest(".card");
              const p = card?.getAttribute("data-path") || "";
              const action = btn.getAttribute("data-action");
              if (!p) return;
              try {
                const removeCard = () => removeCardByPath(p);

                if (action === "no_faces") {
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "no_faces" });
                  if (tab === "faces" || tab === "quarantine") {
                    removeCard();
                    await refreshTabCounts();
                  } else {
                    await load(true);
                  }
                } else if (action === "mark_faces") {
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "faces" });
                  // В карантине/животных разметка идёт потоком: без перезагрузки списка.
                  if (tab === "quarantine" || tab === "animals") {
                    removeCard();
                    await refreshTabCounts();
                  } else {
                    await load(true);
                  }
                } else if (action === "mark_cat") {
                  // #region agent log
                  try {
                    const bn = (p || "").split(/[\\\\/]/).pop();
                    fetch('http://127.0.0.1:7242/ingest/6ba4f132-2ab7-473c-8c73-3e4f328ef941',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app/templates/faces.html:mark_cat',message:'ui_click_mark_cat',data:{tab:tab,basename:bn||""},timestamp:Date.now(),sessionId:'debug-session',runId:'pre-fix',hypothesisId:'HNOFACES_CAT'})}).catch(()=>{});
                  } catch (e) {}
                  // #endregion agent log
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "cat" });
                  // Потоковое действие: без прыжков/перезагрузки списка
                  if (tab === "faces" || tab === "quarantine" || tab === "no_faces") {
                    removeCard();
                    await refreshTabCounts();
                  } else {
                    await load(true);
                  }
                } else if (action === "mark_quarantine") {
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "quarantine" });
                  // На вкладке Faces не хотим дёргать список/скролл — просто убираем карточку.
                  if (tab === "faces") {
                    removeCard();
                    await refreshTabCounts();
                  } else {
                    await load(true);
                  }
                } else if (action === "annotate_faces") {
                  const thumb = card?.querySelector(".thumb[data-src]");
                  const src = thumb?.getAttribute("data-src") || "";
                  await openAnnotate(p, src);
                } else if (action === "people_no_face") {
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "people_no_face" });
                  // Потоковая разметка: уводим карточку без reload (иначе прыгает список).
                  removeCard();
                  await refreshTabCounts();
                } else if (action === "reset") {
                  await postJson("/api/faces/manual-label", { pipeline_run_id: Number(pipelineRunId), path: p, label: "" });
                  // На вкладке people_no_face это "потоковый" сброс: просто убираем карточку.
                  removeCard();
                  await refreshTabCounts();
                }
              } catch (e) {
                setToast(e?.message || String(e), true);
              }
            });
          });

          // double click: show rectangles overlay (images only)
          qsa(".thumb[data-kind='image'][data-src]").slice(-items.length * 1 - 2000).forEach(el => {
            el.addEventListener("dblclick", async () => {
              const p = el.getAttribute("data-path") || "";
              const src = el.getAttribute("data-src") || "";
              if (!p || !src) return;
              await openViewer(p, src, { mode: "view" });
            });
          });
        } catch (e) {
          setToast(e?.message || String(e), true);
          if (loadedCount === 0) qs("#grid").innerHTML = "";
          hasMore = false;
        } finally {
          loading = false;
        }
      }

      // --- viewer / annotate ---
      const lb = qs("#lightbox");
      const lbImg = qs("#lbImg");
      const lbCanvas = qs("#lbCanvas");
      const lbCtx = lbCanvas.getContext("2d");
      const lbPath = qs("#lbPath");
      const lbMode = qs("#lbMode");
      const lbAnnotate = qs("#lbAnnotate");
      const lbClear = qs("#lbClear");
      const lbSave = qs("#lbSave");
      const rectList = qs("#rectList");
      let curPath = "";
      let curAutoRects = [];   // auto (read-only)
      let curManualRects = []; // manual (editable)
      let drawEnabled = false;
      let dragging = false;
      let dragStart = null;
      let tempRect = null;
      let curSrc = "";

      function closeLb() {
        lb.classList.remove("open");
        lb.setAttribute("aria-hidden","true");
        curPath = "";
        curSrc = "";
        curAutoRects = [];
        curManualRects = [];
        drawEnabled = false;
        dragging = false;
        dragStart = null;
        tempRect = null;
        lbCanvas.classList.remove("draw-on");
        if (lbAnnotate) lbAnnotate.style.display = "none";
      }
      qs("#lbClose").onclick = closeLb;
      lb.addEventListener("click", (e) => { if (e.target === lb) closeLb(); });
      window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeLb(); });

      function renderRectList() {
        const all = [...(curAutoRects||[]), ...(curManualRects||[])];
        rectList.innerHTML = all.map((r, i) => `<span class="rectpill">#${i+1} ${r.w}×${r.h}</span>`).join("") || `<span class="muted">—</span>`;
      }

      function resizeCanvasToImage() {
        const w = lbImg.clientWidth;
        const h = lbImg.clientHeight;
        lbCanvas.width = Math.max(1, Math.floor(w));
        lbCanvas.height = Math.max(1, Math.floor(h));
        lbCanvas.style.width = w + "px";
        lbCanvas.style.height = h + "px";
      }

      function drawOverlay() {
        if (!lbCtx) return;
        resizeCanvasToImage();
        lbCtx.clearRect(0,0,lbCanvas.width, lbCanvas.height);
        const iw = lbImg.naturalWidth || 1;
        const ih = lbImg.naturalHeight || 1;
        const sx = lbCanvas.width / iw;
        const sy = lbCanvas.height / ih;
        lbCtx.lineWidth = 2;
        // auto rects (yellow)
        lbCtx.strokeStyle = "rgba(250,204,21,0.95)";
        (curAutoRects || []).forEach(r => {
          lbCtx.strokeRect(r.x * sx, r.y * sy, r.w * sx, r.h * sy);
        });
        // manual rects (blue)
        lbCtx.strokeStyle = "rgba(59,130,246,0.95)";
        (curManualRects || []).forEach(r => {
          lbCtx.strokeRect(r.x * sx, r.y * sy, r.w * sx, r.h * sy);
        });
        // temp
        if (tempRect) {
          lbCtx.strokeStyle = "rgba(16,185,129,0.95)";
          lbCtx.strokeRect(tempRect.x * sx, tempRect.y * sy, tempRect.w * sx, tempRect.h * sy);
        }
      }

      async function fetchRects(path) {
        const data = await fetchJson(`/api/faces/rectangles?pipeline_run_id=${encodeURIComponent(String(pipelineRunId))}&path=${encodeURIComponent(path)}`);
        const rects = Array.isArray(data.rectangles) ? data.rectangles : [];
        const auto = [];
        const manual = [];
        rects.forEach(r => {
          const rr = { x: Number(r.bbox_x||0), y: Number(r.bbox_y||0), w: Number(r.bbox_w||0), h: Number(r.bbox_h||0) };
          const im = Number(r.is_manual || 0) === 1;
          (im ? manual : auto).push(rr);
        });
        return { auto, manual };
      }

      async function openViewer(path, src, opts={}) {
        curPath = path;
        curSrc = src || "";
        lbPath.textContent = path;
        lbImg.referrerPolicy = "no-referrer";
        lbImg.draggable = false;
        lbImg.src = src;
        const isAnnotate = (opts.mode === "annotate");
        lbMode.textContent = isAnnotate ? "разметка" : "просмотр";
        lbClear.style.display = isAnnotate ? "" : "none";
        lbSave.style.display = isAnnotate ? "" : "none";
        // В режиме просмотра показываем кнопку "Разметить" (только для картинок)
        if (lbAnnotate) lbAnnotate.style.display = (!isAnnotate && !!curSrc) ? "" : "none";
        drawEnabled = isAnnotate;
        lbCanvas.classList.toggle("draw-on", !!drawEnabled);

        lb.classList.add("open");
        lb.setAttribute("aria-hidden","false");

        await new Promise((resolve) => {
          if (lbImg.complete) return resolve();
          lbImg.onload = () => resolve();
          lbImg.onerror = () => resolve();
        });

        const rr = await fetchRects(path).catch(() => ({ auto: [], manual: [] }));
        curAutoRects = rr.auto || [];
        curManualRects = rr.manual || [];
        renderRectList();
        drawOverlay();
      }

      // Переключение "просмотр" -> "разметка" прямо в модалке
      if (lbAnnotate) {
        lbAnnotate.onclick = async () => {
          if (!curPath || !curSrc) return;
          // Просто перевключаем UI-флаги, прямоугольники уже загружены в curAutoRects/curManualRects
          lbMode.textContent = "разметка";
          lbClear.style.display = "";
          lbSave.style.display = "";
          lbAnnotate.style.display = "none";
          drawEnabled = true;
          lbCanvas.classList.add("draw-on");
          drawOverlay();
          setToast("Режим разметки: потяни мышью по картинке, чтобы добавить прямоугольник.");
        };
      }

      function screenToNatural(pt) {
        const iw = lbImg.naturalWidth || 1;
        const ih = lbImg.naturalHeight || 1;
        const sx = iw / (lbImg.clientWidth || 1);
        const sy = ih / (lbImg.clientHeight || 1);
        return { x: pt.x * sx, y: pt.y * sy };
      }

      function getLocalPoint(e) {
        const rect = lbImg.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
        return { x, y };
      }

      function enableDrawingHandlers() {
        lbCanvas.onmousedown = (e) => {
          if (!drawEnabled) return;
          if (!(e instanceof MouseEvent)) return;
          e.preventDefault();
          dragging = true;
          dragStart = getLocalPoint(e);
          tempRect = null;
        };
        lbCanvas.onmousemove = (e) => {
          if (!drawEnabled || !dragging || !dragStart) return;
          e.preventDefault();
          const p = getLocalPoint(e);
          const x0 = Math.min(dragStart.x, p.x);
          const y0 = Math.min(dragStart.y, p.y);
          const w0 = Math.abs(dragStart.x - p.x);
          const h0 = Math.abs(dragStart.y - p.y);
          const n0 = screenToNatural({ x: x0, y: y0 });
          const n1 = screenToNatural({ x: x0 + w0, y: y0 + h0 });
          tempRect = { x: Math.round(n0.x), y: Math.round(n0.y), w: Math.round(n1.x - n0.x), h: Math.round(n1.y - n0.y) };
          drawOverlay();
        };
        lbCanvas.onmouseup = (e) => {
          if (!drawEnabled || !dragging) return;
          e.preventDefault();
          dragging = false;
          if (tempRect && tempRect.w >= 8 && tempRect.h >= 8) {
            curManualRects.push(tempRect);
            tempRect = null;
            renderRectList();
          } else {
            tempRect = null;
          }
          drawOverlay();
        };
      }
      enableDrawingHandlers();

      lbClear.onclick = () => {
        curManualRects = [];
        tempRect = null;
        renderRectList();
        drawOverlay();
      };
      lbSave.onclick = async () => {
        try {
          const savedPath = curPath;
          await postJson("/api/faces/manual-rectangles", { pipeline_run_id: Number(pipelineRunId), path: curPath, rects: curManualRects });
          closeLb();
          // На вкладке "Нет лиц" это потоковая операция: карточка должна уйти в "Есть лица" без прыжков списка.
          if (tab === "no_faces") {
            removeCardByPath(savedPath);
          }
          await refreshTabCounts();
          setToast("Сохранено.");
        } catch (e) {
          setToast(e?.message || String(e), true);
        }
      };

      async function openAnnotate(path, src) {
        if (!src) { setToast("Нет превью для разметки", true); return; }
        await openViewer(path, src, { mode: "annotate" });
      }

      // init from query
      const rid = getParam("pipeline_run_id");
      if (rid && /^\d+$/.test(rid)) pipelineRunId = Number(rid);
      qs("#prId").textContent = pipelineRunId != null ? String(pipelineRunId) : "—";
      applyTabUI();
      updateUrlParams();
      // sentinel for infinite scroll
      const sentinel = document.createElement("div");
      sentinel.id = "sentinel";
      sentinel.className = "muted";
      sentinel.style.padding = "18px 0";
      sentinel.textContent = "…";
      qs("#grid").after(sentinel);
      const io = new IntersectionObserver((entries) => {
        const e = entries && entries[0];
        if (e && e.isIntersecting) {
          if (!loading && hasMore) {
            page += 1;
            load(false);
          }
        }
      }, { root: null, rootMargin: "800px 0px", threshold: 0.01 });
      io.observe(sentinel);

      refreshTabCounts();
      load(true);
    </script>
  </body>
</html>


